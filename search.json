[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/P05_Matplot/P05_Matplot.html",
    "href": "posts/P05_Matplot/P05_Matplot.html",
    "title": "P05_Matplot",
    "section": "",
    "text": "## https://matplotlib.org/stable/users/explain/quick_start.html#quick-start\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nsubplots()를 통해서 산점도의 기본 프레임을 설정\n\n\nfig, ax = plt.subplots()             # Create a figure containing a single Axes.\nax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n\n\n\n\n\n\n\n\n행렬 도표 형식으로 그래프의 구조를 결정\n\n빈 그래프, 하나의 그래프, 2*2 그래프, 왼편과 오른편의 구조가 다른 그래프\n\n\n\nfig = plt.figure()\n# an empty figure with no Axes\nfig, ax = plt.subplots()\n# a figure with a single Axes\nfig, axs = plt.subplots(2, 2)\n# a figure with a 2x2 grid of Axes\nfig, axs = plt.subplot_mosaic([['left', 'right_top'],\n                               ['left', 'right_bottom']])\n# a figure with one Axes on the left, and two on the right:\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n산점도 b\\(\\sim\\)a\n\nxlabel / ylabel (x축과 y의 이름)\nfigsize (플랏의 크기)\nc는 색깔, s는 크기\n\n\n\nnp.random.seed(19680801)\n# seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\nText(0, 0.5, 'entry b')\n\n\n\n\n\n\n\n\n\n\n코딩 스타일\n\n기본적으로 하나의 플랏에 이어서 덧붙여서 그릴 수 있음\nlegend: 연달아 붙은 플랏들을 구별해 주는 범례\n\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\n\nax.plot(x, x, label='linear')\nax.plot(x, x**2, label='quadratic')\nax.plot(x, x**3, label='cubic')\nax.set_xlabel('x label')\nax.set_ylabel('y label')\nax.set_title(\"Simple Plot\")\nax.legend()\n\n\n\n\n\n\n\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')\nplt.plot(x, x**2, label='quadratic')\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n\n\n\n\n\n\n\n\n함수를 이용한 플랏\n\nmarker를 이용해서 점의 형태를 결정\n\n\n\ndef my_plotter(ax, data1, data2, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data1, data2, **param_dict)\n    return out\n\ndata1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))\nmy_plotter(ax1, data1, data2, {'marker': 'x'})\nmy_plotter(ax2, data3, data4, {'marker': 'o'})\n\n\n\n\n\n\n\n\n\n선과 형태에 대해서 옵션\n\nlinewidth: 선의 굵기\nlinestyle: 선의 형태\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nx = np.arange(len(data1))\nax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--')\nl, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2)\nl.set_linestyle(':')\n# 선의 형태\n\n\n\n\n\n\n\n\n\n점의 색깔 지정\n\nfacecolor: 안의 색깔\nedgecolor: 테두리 색깔\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.scatter(data1, data2, s=50, facecolor='C0', edgecolor='k')\n\n\n\n\n\n\n\n\n\n점의 형태로 구분을 지음\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(data1, 'o', label='data1')\nax.plot(data2, 'd', label='data2')\nax.plot(data3, 'v', label='data3')\nax.plot(data4, 's', label='data4')\nax.legend()\n\n\n\n\n\n\n\n\n\n히스토그램\n\n50개의 구간, density: 밀도함수는 표시\nfacecolor: 안의 색깔, alpha: 투명도\nax.text: 텍스트 집어 넣기 (가로, 세로 위치 및 문구)\n\n\n\nmu, sigma = 115, 15\nx = mu + sigma * np.random.randn(10000)\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\n\nn, bins, patches = ax.hist(x, 50, density=True, facecolor='C0', alpha=0.75)\n\nax.set_xlabel('Length [cm]')\nax.set_ylabel('Probability')\nax.set_title('Aardvark lengths\\n (not really)')\nax.text(75, .025, r'$\\mu=115,\\ \\sigma=15$')\nax.axis([55, 175, 0, 0.03])\nax.grid(True)\n\n\n\n\n\n\n\n\n\n화살표\n\n화살표 표시 가능\nxy: 화살표 지정 위치, xytext: 문구 위치, shrink: 어느 정도 가꾸이 갈지\nset_ylim: y축 값의 범위를 지정\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2 * np.pi * t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\nax.set_ylim(-2, 2)\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(np.arange(len(data1)), data1, label='data1')\nax.plot(np.arange(len(data2)), data2, label='data2')\nax.plot(np.arange(len(data3)), data3, 'd', label='data3')\nax.legend()\n\n\n\n\n\n\n\n\n\n스케일 지정\n\n원 값의 스케일을 변환해서 출력\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='constrained')\nxdata = np.arange(len(data1))\naxs[0].plot(xdata, data)\naxs[1].set_yscale('log')\n# y log transformation\naxs[1].plot(xdata, data)\n\n\n\n\n\n\n\n\n\nxticks / yticks\n\n눈금을 조정\n\n\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\naxs[0].plot(xdata, data1)\naxs[0].set_title('Automatic ticks')\naxs[1].plot(xdata, data1)\naxs[1].set_xticks(np.arange(0, 100, 30), ['zero', '30', 'sixty', '90'])\n# 0/30/60/90 에 이름을 지정\naxs[1].set_yticks([-1.5, 0, 1.5])\n# -1.5, 0. 1.5\naxs[1].set_title('Manual ticks')\n\nText(0.5, 1.0, 'Manual ticks')\n\n\n\n\n\n\n\n\n\n\n시계열 데이터 표시법\n\n날짜 표시 기법\n\n\n\nfrom matplotlib.dates import ConciseDateFormatter\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\ndates = np.arange(np.datetime64('2021-11-15'), np.datetime64('2021-12-25'),\n                  np.timedelta64(1, 'h'))\ndata = np.cumsum(np.random.randn(len(dates)))\nax.plot(dates, data)\nax.xaxis.set_major_formatter(ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\n\n\n\n\n\n\n\n\n막대 그래프\n\n범주의 이름과 값을 명기\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\ncategories = ['turnips', 'rutabaga', 'cucumber', 'pumpkins']\nax.bar(categories, 100*np.random.rand(len(categories)))\n\n\n\n\n\n\n\n\n\ntwinx 구문\n\n축에 대한 설정을 추가 (ax1, ax2 - 하나의 그림,\n\n\n\nfig, (ax1, ax3) = plt.subplots(1, 2, figsize=(7, 2.7), layout='constrained')\nl1, = ax1.plot(t, s)\nax2 = ax1.twinx()\n# 그림 위에 또 하나의 그림을 표시\nl2, = ax2.plot(t, range(len(t)), 'C1')\nax2.legend([l1, l2], ['Sine (left)', 'Straight (right)'])\n\nax3.plot(t, s)\nax3.set_xlabel('Angle [rad]')\nax4 = ax3.secondary_xaxis('top', functions=(np.rad2deg, np.deg2rad))\n# 위에 축을 하나 만들어서 각도로 표시\nax4.set_xlabel('Angle [°]')\n\nText(0.5, 0, 'Angle [°]')\n\n\n\n\n\n\n\n\n\n\n색 지도 (color map)\n\n(x,y,z): (x,y)는 위치 z는 값\nmesh: 색으로 명암 조정\ncontour: 등고선\nplasma: Z가 가지는 값들을 이용해서 히트 맵 구성\nscatter: (x,y)는 위치, z는 색깔\n\n\n\nfrom matplotlib.colors import LogNorm\n\nX, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128))\nZ = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\npc = axs[0, 0].pcolormesh(X, Y, Z, vmin=-1, vmax=1, cmap='RdBu_r')\nfig.colorbar(pc, ax=axs[0, 0])\naxs[0, 0].set_title('pcolormesh()')\n\nco = axs[0, 1].contourf(X, Y, Z, levels=np.linspace(-1.25, 1.25, 11))\nfig.colorbar(co, ax=axs[0, 1])\naxs[0, 1].set_title('contourf()')\n\npc = axs[1, 0].imshow(Z**2 * 100, cmap='plasma', norm=LogNorm(vmin=0.01, vmax=100))\nfig.colorbar(pc, ax=axs[1, 0], extend='both')\naxs[1, 0].set_title('imshow() with LogNorm()')\n\npc = axs[1, 1].scatter(data1, data2, c=data3, cmap='RdBu_r')\nfig.colorbar(pc, ax=axs[1, 1], extend='both')\naxs[1, 1].set_title('scatter()')\n\nText(0.5, 1.0, 'scatter()')\n\n\n\n\n\n\n\n\n\n\nsubplot_mosaic\n\n이름을 지정\n이름으로 위치에 있는 플랏을 반환해서 설정함\n\n\n\nfig, axd = plt.subplot_mosaic([['upleft', 'right'],\n                               ['lowleft', 'right']], layout='constrained')\naxd['upleft'].set_title('upleft')\naxd['lowleft'].set_title('lowleft')\naxd['right'].set_title('right')\n\nText(0.5, 1.0, 'right')"
  },
  {
    "objectID": "posts/P05_Matplot/P05_Matplot.html#python-graphics",
    "href": "posts/P05_Matplot/P05_Matplot.html#python-graphics",
    "title": "P05_Matplot",
    "section": "",
    "text": "## https://matplotlib.org/stable/users/explain/quick_start.html#quick-start\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nsubplots()를 통해서 산점도의 기본 프레임을 설정\n\n\nfig, ax = plt.subplots()             # Create a figure containing a single Axes.\nax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the Axes.\nplt.show()                           # Show the figure.\n\n\n\n\n\n\n\n\n\n행렬 도표 형식으로 그래프의 구조를 결정\n\n빈 그래프, 하나의 그래프, 2*2 그래프, 왼편과 오른편의 구조가 다른 그래프\n\n\n\nfig = plt.figure()\n# an empty figure with no Axes\nfig, ax = plt.subplots()\n# a figure with a single Axes\nfig, axs = plt.subplots(2, 2)\n# a figure with a 2x2 grid of Axes\nfig, axs = plt.subplot_mosaic([['left', 'right_top'],\n                               ['left', 'right_bottom']])\n# a figure with one Axes on the left, and two on the right:\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n산점도 b\\(\\sim\\)a\n\nxlabel / ylabel (x축과 y의 이름)\nfigsize (플랏의 크기)\nc는 색깔, s는 크기\n\n\n\nnp.random.seed(19680801)\n# seed the random number generator.\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set_xlabel('entry a')\nax.set_ylabel('entry b')\n\nText(0, 0.5, 'entry b')\n\n\n\n\n\n\n\n\n\n\n코딩 스타일\n\n기본적으로 하나의 플랏에 이어서 덧붙여서 그릴 수 있음\nlegend: 연달아 붙은 플랏들을 구별해 주는 범례\n\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\n\nax.plot(x, x, label='linear')\nax.plot(x, x**2, label='quadratic')\nax.plot(x, x**3, label='cubic')\nax.set_xlabel('x label')\nax.set_ylabel('y label')\nax.set_title(\"Simple Plot\")\nax.legend()\n\n\n\n\n\n\n\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7), layout='constrained')\nplt.plot(x, x, label='linear')\nplt.plot(x, x**2, label='quadratic')\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\n\n\n\n\n\n\n\n\n\n함수를 이용한 플랏\n\nmarker를 이용해서 점의 형태를 결정\n\n\n\ndef my_plotter(ax, data1, data2, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data1, data2, **param_dict)\n    return out\n\ndata1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))\nmy_plotter(ax1, data1, data2, {'marker': 'x'})\nmy_plotter(ax2, data3, data4, {'marker': 'o'})\n\n\n\n\n\n\n\n\n\n선과 형태에 대해서 옵션\n\nlinewidth: 선의 굵기\nlinestyle: 선의 형태\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nx = np.arange(len(data1))\nax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--')\nl, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2)\nl.set_linestyle(':')\n# 선의 형태\n\n\n\n\n\n\n\n\n\n점의 색깔 지정\n\nfacecolor: 안의 색깔\nedgecolor: 테두리 색깔\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.scatter(data1, data2, s=50, facecolor='C0', edgecolor='k')\n\n\n\n\n\n\n\n\n\n점의 형태로 구분을 지음\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(data1, 'o', label='data1')\nax.plot(data2, 'd', label='data2')\nax.plot(data3, 'v', label='data3')\nax.plot(data4, 's', label='data4')\nax.legend()\n\n\n\n\n\n\n\n\n\n히스토그램\n\n50개의 구간, density: 밀도함수는 표시\nfacecolor: 안의 색깔, alpha: 투명도\nax.text: 텍스트 집어 넣기 (가로, 세로 위치 및 문구)\n\n\n\nmu, sigma = 115, 15\nx = mu + sigma * np.random.randn(10000)\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\n\nn, bins, patches = ax.hist(x, 50, density=True, facecolor='C0', alpha=0.75)\n\nax.set_xlabel('Length [cm]')\nax.set_ylabel('Probability')\nax.set_title('Aardvark lengths\\n (not really)')\nax.text(75, .025, r'$\\mu=115,\\ \\sigma=15$')\nax.axis([55, 175, 0, 0.03])\nax.grid(True)\n\n\n\n\n\n\n\n\n\n화살표\n\n화살표 표시 가능\nxy: 화살표 지정 위치, xytext: 문구 위치, shrink: 어느 정도 가꾸이 갈지\nset_ylim: y축 값의 범위를 지정\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2 * np.pi * t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\nax.set_ylim(-2, 2)\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(np.arange(len(data1)), data1, label='data1')\nax.plot(np.arange(len(data2)), data2, label='data2')\nax.plot(np.arange(len(data3)), data3, 'd', label='data3')\nax.legend()\n\n\n\n\n\n\n\n\n\n스케일 지정\n\n원 값의 스케일을 변환해서 출력\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='constrained')\nxdata = np.arange(len(data1))\naxs[0].plot(xdata, data)\naxs[1].set_yscale('log')\n# y log transformation\naxs[1].plot(xdata, data)\n\n\n\n\n\n\n\n\n\nxticks / yticks\n\n눈금을 조정\n\n\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\naxs[0].plot(xdata, data1)\naxs[0].set_title('Automatic ticks')\naxs[1].plot(xdata, data1)\naxs[1].set_xticks(np.arange(0, 100, 30), ['zero', '30', 'sixty', '90'])\n# 0/30/60/90 에 이름을 지정\naxs[1].set_yticks([-1.5, 0, 1.5])\n# -1.5, 0. 1.5\naxs[1].set_title('Manual ticks')\n\nText(0.5, 1.0, 'Manual ticks')\n\n\n\n\n\n\n\n\n\n\n시계열 데이터 표시법\n\n날짜 표시 기법\n\n\n\nfrom matplotlib.dates import ConciseDateFormatter\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\ndates = np.arange(np.datetime64('2021-11-15'), np.datetime64('2021-12-25'),\n                  np.timedelta64(1, 'h'))\ndata = np.cumsum(np.random.randn(len(dates)))\nax.plot(dates, data)\nax.xaxis.set_major_formatter(ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\n\n\n\n\n\n\n\n\n막대 그래프\n\n범주의 이름과 값을 명기\n\n\n\nfig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')\ncategories = ['turnips', 'rutabaga', 'cucumber', 'pumpkins']\nax.bar(categories, 100*np.random.rand(len(categories)))\n\n\n\n\n\n\n\n\n\ntwinx 구문\n\n축에 대한 설정을 추가 (ax1, ax2 - 하나의 그림,\n\n\n\nfig, (ax1, ax3) = plt.subplots(1, 2, figsize=(7, 2.7), layout='constrained')\nl1, = ax1.plot(t, s)\nax2 = ax1.twinx()\n# 그림 위에 또 하나의 그림을 표시\nl2, = ax2.plot(t, range(len(t)), 'C1')\nax2.legend([l1, l2], ['Sine (left)', 'Straight (right)'])\n\nax3.plot(t, s)\nax3.set_xlabel('Angle [rad]')\nax4 = ax3.secondary_xaxis('top', functions=(np.rad2deg, np.deg2rad))\n# 위에 축을 하나 만들어서 각도로 표시\nax4.set_xlabel('Angle [°]')\n\nText(0.5, 0, 'Angle [°]')\n\n\n\n\n\n\n\n\n\n\n색 지도 (color map)\n\n(x,y,z): (x,y)는 위치 z는 값\nmesh: 색으로 명암 조정\ncontour: 등고선\nplasma: Z가 가지는 값들을 이용해서 히트 맵 구성\nscatter: (x,y)는 위치, z는 색깔\n\n\n\nfrom matplotlib.colors import LogNorm\n\nX, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128))\nZ = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\npc = axs[0, 0].pcolormesh(X, Y, Z, vmin=-1, vmax=1, cmap='RdBu_r')\nfig.colorbar(pc, ax=axs[0, 0])\naxs[0, 0].set_title('pcolormesh()')\n\nco = axs[0, 1].contourf(X, Y, Z, levels=np.linspace(-1.25, 1.25, 11))\nfig.colorbar(co, ax=axs[0, 1])\naxs[0, 1].set_title('contourf()')\n\npc = axs[1, 0].imshow(Z**2 * 100, cmap='plasma', norm=LogNorm(vmin=0.01, vmax=100))\nfig.colorbar(pc, ax=axs[1, 0], extend='both')\naxs[1, 0].set_title('imshow() with LogNorm()')\n\npc = axs[1, 1].scatter(data1, data2, c=data3, cmap='RdBu_r')\nfig.colorbar(pc, ax=axs[1, 1], extend='both')\naxs[1, 1].set_title('scatter()')\n\nText(0.5, 1.0, 'scatter()')\n\n\n\n\n\n\n\n\n\n\nsubplot_mosaic\n\n이름을 지정\n이름으로 위치에 있는 플랏을 반환해서 설정함\n\n\n\nfig, axd = plt.subplot_mosaic([['upleft', 'right'],\n                               ['lowleft', 'right']], layout='constrained')\naxd['upleft'].set_title('upleft')\naxd['lowleft'].set_title('lowleft')\naxd['right'].set_title('right')\n\nText(0.5, 1.0, 'right')"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "Pandas는 NumPy를 기반으로 만들어진 패키지로써 DataFrame이라는 효율적인 자료구조를 제공한다. DataFrame는 근본적으로 행과 열 레이블이 부착된 다차원의 배열로서, 여러 가지 타입의 데이터를 가질 수 있으며 결측치도 허용된다. 따라서, Pandas의 구조 및 사용법을 익히는 것은 데이터 분석을 위해서는 필수적이다. 좀 더 자세한 사항은 https://pandas.pydata.org 에 있다.\n\n\n\n!pip3 install pandas\n\nRequirement already satisfied: pandas in /usr/local/lib/python3.10/dist-packages (2.2.2)\nRequirement already satisfied: numpy&gt;=1.22.4 in /usr/local/lib/python3.10/dist-packages (from pandas) (1.26.4)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /usr/local/lib/python3.10/dist-packages (from pandas) (2.8.2)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas) (2024.2)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas) (2024.2)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&gt;=2.8.2-&gt;pandas) (1.16.0)\n\n\n\nimport numpy as np\nimport pandas as pd\nnp.__version__\npd.__version__\n\n'2.2.2'\n\n\n\n\n\n세 가지 기본 자료구조인 Series, DataFrame, 그리고 Index를 소개한다.\n\n\nSeries객체는 일차원 자료를 다룰 때 사용된다.\n\n\nPython에서 Series를 객체를 생성하는 기본적인 방법은 다음과 같다.\n&gt;&gt;&gt; pd.Series(data, index=index)\n참고. index는 옵션으로 사용자가 지정하지 않으면 정수가 기본이다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0])\nprint(data)\n\n0    0.25\n1    0.50\n2    0.75\n3    1.00\ndtype: float64\n\n\n\ndata.values\n\narray([0.25, 0.5 , 0.75, 1.  ])\n\n\n\ndata.index\n\nRangeIndex(start=0, stop=4, step=1)\n\n\n\ndata.dtype\n\ndtype('float64')\n\n\nindex를 통해 자료에 접근할 수 있다.\n\ndata[1]\n\n0.5\n\n\n\nprint(data[1:3])\n\n1    0.50\n2    0.75\ndtype: float64\n\n\nindex를 사용자가 지정할 수 있다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=['a', 'b', 'c', 'd'])\nprint(data)\n\na    0.25\nb    0.50\nc    0.75\nd    1.00\ndtype: float64\n\n\n\ndata['b']\n\n0.5\n\n\n\ndata[['b','c']]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n연속적이지 않은 index를 사용할 수 있다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=[2, 5, 3, 7])\nprint(data)\n\n2    0.25\n5    0.50\n3    0.75\n7    1.00\ndtype: float64\n\n\n\ndata[2]\n\n0.25\n\n\nPandas의 Series는 딕셔너리의 특수한 버전으로 생각할 수 있다.\n\npopulation_dict = {'California': 38332521,\n                   'Texas': 26448193,\n                   'New York': 19651127,\n                   'Florida': 19552860,\n                   'Illinois': 12882135}\npopulation = pd.Series(population_dict)\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\n\n\n\npopulation['California']\n\n38332521\n\n\n딕셔너리와 달리 Series는 슬라이싱 같이 배열 스타일의 연산도 가능\n\nprint(population['California':'Illinois'])\nprint(population['California':'Texas'])\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\nCalifornia    38332521\nTexas         26448193\ndtype: int64\n\n\ndata는 같은 값을 지정할 수 있다.\n\na = pd.Series(5, index=[100, 200, 300])\nprint(a)\n\n100    5\n200    5\n300    5\ndtype: int64\n\n\nindex를 명시적으로 설정할 수 있다.\n\na = pd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2])\nprint(a)\n\n3    c\n2    a\ndtype: object\n\n\n\n\n\n\nDataFrame객체는 이차원 배열을 다룰 때 사용된다. 데이터 분석에서의 가장 기본적으로 사용되는 자료형태이다.\n\n\nPython에서 DataFrame 객체를 생성하는 기본적인 방법은 다음과 같다.\n&gt;&gt;&gt; DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)\n\n\n\npopulation_dict = {'California': 38332521,\n                   'Texas': 26448193,\n                   'New York': 19651127,\n                   'Florida': 19552860,\n                   'Illinois': 12882135}\npopulation = pd.Series(population_dict)\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\n\n\n\npop = pd.DataFrame(population, columns=['population'])\nprint(pop)\n\n            population\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\n\n\n\npop.index\n# row.names\n\nIndex(['California', 'Texas', 'New York', 'Florida', 'Illinois'], dtype='object')\n\n\n\npop.columns\n\nIndex(['population'], dtype='object')\n\n\n\n\n\n\narea_dict = {'California': 423967, 'Texas': 695662, 'New York': 141297,\n             'Florida': 170312, 'Illinois': 149995}\narea = pd.Series(area_dict)\nprint(area)\n\nCalifornia    423967\nTexas         695662\nNew York      141297\nFlorida       170312\nIllinois      149995\ndtype: int64\n\n\n\nstates = pd.DataFrame({'population': population,\n                       'area': area})\nprint(states)\n\n            population    area\nCalifornia    38332521  423967\nTexas         26448193  695662\nNew York      19651127  141297\nFlorida       19552860  170312\nIllinois      12882135  149995\n\n\n\nstates.index\n\nIndex(['California', 'Texas', 'New York', 'Florida', 'Illinois'], dtype='object')\n\n\n\nstates.columns\n\nIndex(['population', 'area'], dtype='object')\n\n\nSeries에서는 data[0]는 첫 번째 행을 반환하고, DataFrame에서 data['col0']는 첫 번째 열을 반환한다.\n\na = states['area']\nprint(a)\n\nCalifornia    423967\nTexas         695662\nNew York      141297\nFlorida       170312\nIllinois      149995\nName: area, dtype: int64\n\n\n\n\n\n\ndata = [{'a': i, 'b': 2 * i} for i in range(3)]\ndata\n\n[{'a': 0, 'b': 0}, {'a': 1, 'b': 2}, {'a': 2, 'b': 4}]\n\n\n\na = pd.DataFrame(data)\nprint(a)\n\n   a  b\n0  0  0\n1  1  2\n2  2  4\n\n\nPandas에서는 딕셔너리의 일부 키가 생략되면 NaN(Not a number)를 채운다.\n\na = pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])\nprint(a)\n\n     a  b    c\n0  1.0  2  NaN\n1  NaN  3  4.0\n\n\n\n\n\n\ndata = np.random.rand(3, 2)\ndata\n\narray([[0.53463944, 0.82086275],\n       [0.12256724, 0.92698303],\n       [0.34134035, 0.40564263]])\n\n\n\na = pd.DataFrame(data,\n             columns=['foo', 'bar'],\n             index=['a', 'b', 'c'])\nprint(a)\n\n        foo       bar\na  0.534639  0.820863\nb  0.122567  0.926983\nc  0.341340  0.405643\n\n\n\n\n\n\n\n표 형식의 데이터 객체에서 각 행과 열에 대한 이름을 저장하는 객체이다.\n\nind = pd.Index([2, 3, 5, 7, 11])\nind\n\nIndex([2, 3, 5, 7, 11], dtype='int64')\n\n\n\n\n일반적인 방법으로 값을 변경할 수 없다.\n\nind[1]\n\n3\n\n\n\nind[::2]\n\nIndex([2, 5, 11], dtype='int64')\n\n\n\nprint(ind.size, ind.shape, ind.ndim, ind.dtype)\n\n5 (5,) 1 int64\n\n\n\nind[1] = 0\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-26-906a9fa1424c&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 ind[1] = 0\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in __setitem__(self, key, value)\n   5369     @final\n   5370     def __setitem__(self, key, value) -&gt; None:\n-&gt; 5371         raise TypeError(\"Index does not support mutable operations\")\n   5372 \n   5373     def __getitem__(self, key):\n\nTypeError: Index does not support mutable operations\n\n\n\n\n\n\n대체로 set데이터 구조에서 사용하는 표기법을 따른다.\n\nindA = pd.Index([1, 3, 5, 7, 9])\nindB = pd.Index([2, 3, 5, 7, 11])\n\nprint(indB)\n\nIndex([2, 3, 5, 7, 11], dtype='int64')\n\n\n\nprint(indA.intersection(indB))  # intersection\n\nIndex([3, 5, 7], dtype='int64')\n\n\n\nindA.union(indB)  # union\n\nIndex([1, 2, 3, 5, 7, 9, 11], dtype='int64')\n\n\n\nindA.difference(indB)  # symmetric difference\n\nIndex([1, 9], dtype='int64')\n\n\n\n\n\n\n\n\n\n\n\n키의 집합을 값의 집합에 매핑한다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=['a', 'b', 'c', 'd'])\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\nd\n1.00\n\n\n\n\ndtype: float64\n\n\n\ndata['b']\n\n0.5\n\n\n\n'a' in data\n\nTrue\n\n\n\ndata.keys()\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\n\nlist(data.items())\n\n[('a', 0.25), ('b', 0.5), ('c', 0.75), ('d', 1.0)]\n\n\n\ndata['e'] = 1.25\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\nd\n1.00\n\n\ne\n1.25\n\n\n\n\ndtype: float64\n\n\n\n\n\nSeries는 슬라이스, 마스킹, 팬시 인덱싱 등 NumPy배열과 똑같은 기본 메커니즘으로 배열 형태의 아이템을 선택할 수 있다.\n\n# slicing by explicit index\ndata['a':'c']\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n\n# slicing by implicit integer index\ndata[0:2]\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\n\n\ndtype: float64\n\n\n\n# masking\ndata[(data &gt; 0.3) & (data &lt; 0.8)]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n\n# fancy indexing\ndata[['a', 'e']]\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\ne\n1.25\n\n\n\n\ndtype: float64\n\n\n\n\n\n인덱서를 이용하면 명확하게 해당 요소를 지정할 수 있다.\n\nimport pandas as pd\ndata = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\n1\na\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\n\n# explicit index when indexing\ndata[1]\n\n'a'\n\n\n\n# implicit index when slicing\ndata[1:3]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\nloc 사용:\n\ndata.loc[1]\n\n'a'\n\n\n\ndata.loc[1:5]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n1\na\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\niloc 사용: 암묵적인 Python스타일\n\ndata.iloc[1]\n\n'b'\n\n\n\ndata.iloc[1:3]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\n\n\n\n\n\n\n\narea = pd.Series({'California': 423967, 'Texas': 695662,\n                  'New York': 141297, 'Florida': 170312,\n                  'Illinois': 149995})\npop = pd.Series({'California': 38332521, 'Texas': 26448193,\n                 'New York': 19651127, 'Florida': 19552860,\n                 'Illinois': 12882135})\ndata = pd.DataFrame({'area':area, 'pop':pop})\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\nFlorida\n170312\n19552860\n\n\nIllinois\n149995\n12882135\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\ndata['area']\n\n\n\n\n\n\n\n\narea\n\n\n\n\nCalifornia\n423967\n\n\nTexas\n695662\n\n\nNew York\n141297\n\n\nFlorida\n170312\n\n\nIllinois\n149995\n\n\n\n\ndtype: int64\n\n\n다음은 약식표현 방법을 자료를 선택하는 방법이다.\n\ndata.area\n\n\n\n\n\n\n\n\narea\n\n\n\n\nCalifornia\n423967\n\n\nTexas\n695662\n\n\nNew York\n141297\n\n\nFlorida\n170312\n\n\nIllinois\n149995\n\n\n\n\ndtype: int64\n\n\n\ndata.area\ndata.area is data['area']\n\nTrue\n\n\n주의. 약식표현이 항상 가능하지는 않다. 즉, DataFrame는 pop()메서드를 가지고 있다.\n\nprint(data.pop)\ndata.pop is data['pop']\n\n&lt;bound method DataFrame.pop of               area       pop\nCalifornia  423967  38332521\nTexas       695662  26448193\nNew York    141297  19651127\nFlorida     170312  19552860\nIllinois    149995  12882135&gt;\n\n\nFalse\n\n\n새로운 변수명과 해당 변수에 대한 자료 입력을 통해 객체를 추가할 수 있다.\n\ndata['density'] = data['pop'] / data['area']\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nCalifornia\n423967\n38332521\n90.413926\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n\n\ndata.values\n\narray([[4.23967000e+05, 3.83325210e+07, 9.04139261e+01],\n       [6.95662000e+05, 2.64481930e+07, 3.80187404e+01],\n       [1.41297000e+05, 1.96511270e+07, 1.39076746e+02],\n       [1.70312000e+05, 1.95528600e+07, 1.14806121e+02],\n       [1.49995000e+05, 1.28821350e+07, 8.58837628e+01]])\n\n\n\ndata.T   # Transpose\n\n\n  \n    \n\n\n\n\n\n\nCalifornia\nTexas\nNew York\nFlorida\nIllinois\n\n\n\n\narea\n4.239670e+05\n6.956620e+05\n1.412970e+05\n1.703120e+05\n1.499950e+05\n\n\npop\n3.833252e+07\n2.644819e+07\n1.965113e+07\n1.955286e+07\n1.288214e+07\n\n\ndensity\n9.041393e+01\n3.801874e+01\n1.390767e+02\n1.148061e+02\n8.588376e+01\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\n\n\n\ndata.values[0]\n\narray([4.23967000e+05, 3.83325210e+07, 9.04139261e+01])\n\n\n\ndata.iloc[:3, :2]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.loc[:'Illinois', :'pop']\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\nFlorida\n170312\n19552860\n\n\nIllinois\n149995\n12882135\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.loc[data.density &gt; 100, ['pop', 'density']]\n\n\n  \n    \n\n\n\n\n\n\npop\ndensity\n\n\n\n\nNew York\n19651127\n139.076746\n\n\nFlorida\n19552860\n114.806121\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.iloc[0, 2] = 90\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nCalifornia\n423967\n38332521\n90.000000\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n\n인덱싱은 열을 참조하고, 슬라이싱은 행을 참조한다.\n\ndata['Florida':'Illinois']\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata[1:3]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n마스킹 연산은 행 단위로 해석된다.\n\ndata[data.density &gt; 100]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\n\n\n\n\n부정 함수와 삼각함수 같은 단항 연산의 경우에는 유니버설 함수가 결과물에 인덱스와 열 레이블을 보존하고, 덧셈과 곱셈 같은 이항 연산의 경우에는 유니버설 함수에 객체를 전달할 때 자동으로 인덱스를 정렬한다.\n\n\n단항 연산은 인덱스를 보존한다.\n\n\n\n\nimport numpy as np\nrng = np.random.RandomState(42)\nser = pd.Series(rng.randint(0, 10, 4))\nser\n\n0    6\n1    3\n2    7\n3    4\ndtype: int64\n\n\n\nnp.exp(ser)\n\n0     403.428793\n1      20.085537\n2    1096.633158\n3      54.598150\ndtype: float64\n\n\n\n\n\n\ndf = pd.DataFrame(rng.randint(0, 10, (3, 4)),\n                  columns=['A', 'B', 'C', 'D'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n6\n9\n2\n6\n\n\n1\n7\n4\n3\n7\n\n\n2\n7\n2\n5\n4\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nnp.sin(df * np.pi / 4)\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n-1.000000\n7.071068e-01\n1.000000\n-1.000000e+00\n\n\n1\n-0.707107\n1.224647e-16\n0.707107\n-7.071068e-01\n\n\n2\n-0.707107\n1.000000e+00\n-0.707107\n1.224647e-16\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n이항 연산을 적용하는 경우 인덱스를 정렬한다.\n\n\n\n\narea = pd.Series({'Alaska': 1723337, 'Texas': 695662,\n                  'California': 423967}, name='area')\npopulation = pd.Series({'California': 38332521, 'Texas': 26448193,\n                        'New York': 19651127}, name='population')\n\n\nprint(area)\n\nAlaska        1723337\nTexas          695662\nCalifornia     423967\nName: area, dtype: int64\n\n\n\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nName: population, dtype: int64\n\n\n\npopulation / area\n\nAlaska              NaN\nCalifornia    90.413926\nNew York            NaN\nTexas         38.018740\ndtype: float64\n\n\n누락된 값을 다른 값으로 채워 계산할 수 있다.\n\npopulation.div(area, fill_value=1)\n# population / area (fill--)\n\nAlaska        5.802696e-07\nCalifornia    9.041393e+01\nNew York      1.965113e+07\nTexas         3.801874e+01\ndtype: float64\n\n\n\nA = pd.Series([2, 4, 6], index=[0, 1, 2])\nB = pd.Series([1, 3, 5], index=[1, 2, 3])\nA + B\n# Index에 주의해서 합쳐야 함\n\n0    NaN\n1    5.0\n2    9.0\n3    NaN\ndtype: float64\n\n\n\nA.add(B, fill_value=0)\n\n0    2.0\n1    5.0\n2    9.0\n3    5.0\ndtype: float64\n\n\n\n\n\n\nA = pd.DataFrame(rng.randint(0, 20, (2, 2)),\n                 columns=list('AB'))\nA\n\n\n  \n    \n\n\n\n\n\n\nA\nB\n\n\n\n\n0\n6\n11\n\n\n1\n7\n14\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nB = pd.DataFrame(rng.randint(0, 10, (3, 3)),\n                 columns=list('BAC'))\nB\n\n\n  \n    \n\n\n\n\n\n\nB\nA\nC\n\n\n\n\n0\n2\n0\n3\n\n\n1\n1\n7\n3\n\n\n2\n1\n5\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nA + B\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n6.0\n13.0\nNaN\n\n\n1\n14.0\n15.0\nNaN\n\n\n2\nNaN\nNaN\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nSeries와 같이 누락된 값을 채워넣을 수 있다.\n\nfill = A.stack().mean()\nfill\n\n9.5\n\n\n\nA.add(B, fill_value=fill)\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n6.0\n13.0\n12.5\n\n\n1\n14.0\n15.0\n12.5\n\n\n2\n14.5\n10.5\n14.5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n다음은 Python 연산자와 대응되는 Pandas 메소드이다.\n\n\n\nPython Operator\nPandas Method(s)\n\n\n\n\n+\nadd()\n\n\n-\nsub(), subtract()\n\n\n*\nmul(), multiply()\n\n\n/\ntruediv(), div(), divide()\n\n\n//\nfloordiv()\n\n\n%\nmod()\n\n\n**\npow()\n\n\n\n\n\n\nDataFrame과 Series 사이에서 연산할 때 인덱스와 열의 순서는 비슷하게 유지된다. DataFrame과 Series 사이의 연산은 2차원 NumPy배열과 1차원 NumPy배열 사이의 연산과 비슷하다.\n\n\n\nrng = np.random.RandomState(42)\n\nA = rng.randint(10, size=(3, 4))\nA\n\narray([[6, 3, 7, 4],\n       [6, 9, 2, 6],\n       [7, 4, 3, 7]])\n\n\n\nA[0]\n\narray([6, 3, 7, 4])\n\n\n\nA - A[0]\n\narray([[ 0,  0,  0,  0],\n       [ 0,  6, -5,  2],\n       [ 1,  1, -4,  3]])\n\n\n\n\n\nPandas에서도 연산 규칙이 기본적으로 행 방향으로 적용된다.\n\ndf = pd.DataFrame(A, columns=list('QRST'))\ndf\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n6\n3\n7\n4\n\n\n1\n6\n9\n2\n6\n\n\n2\n7\n4\n3\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.iloc[0]\n\nQ    6\nR    3\nS    7\nT    4\nName: 0, dtype: int64\n\n\n\ndf - df.iloc[0]\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n0\n0\n0\n0\n\n\n1\n0\n6\n-5\n2\n\n\n2\n1\n1\n-4\n3\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\naxis = 0을 지정하면 열 방향으로 연산이 가능한다.\n\nprint(df)\ndf.subtract(df['R'], axis=0)\n\n   Q  R  S  T\n0  6  3  7  4\n1  6  9  2  6\n2  7  4  3  7\n\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n3\n0\n4\n1\n\n\n1\n-3\n0\n-7\n-3\n\n\n2\n3\n0\n-1\n3\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nDataFrame/Series 연산\n\nhalfrow = df.iloc[0, ::2]\nhalfrow\n\nQ    6\nS    7\nName: 0, dtype: int64\n\n\n\ndf\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n6\n3\n7\n4\n\n\n1\n6\n9\n2\n6\n\n\n2\n7\n4\n3\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf - halfrow\n# 객체에 이름이 있다는 것에 주의\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n0.0\nNaN\n0.0\nNaN\n\n\n1\n0.0\nNaN\n-5.0\nNaN\n\n\n2\n1.0\nNaN\n-4.0\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\nPandas에서는 결측치를 NaN값과 Python의 None로 나타낸다.\n\n\nNone는 데이터 타입이 dtype=object(객체의 배열)에서만 사용가능하다.\n\nvals1 = np.array([1, None, 3, 4])\nvals1\n\narray([1, None, 3, 4], dtype=object)\n\n\n객체 배열의 연산은 기본 데이터 타입의 연산보다 많은 오버헤드가 발생한다.\n\nfor dtype in ['object', 'int']:\n    print(\"dtype =\", dtype)\n    %timeit np.arange(1E6, dtype=dtype).sum()\n    print()\n\ndtype = object\n44 ms ± 7.75 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\ndtype = int\n489 µs ± 9.86 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\n\n\nNone값을 가진 배열에서 sum과 같은 연산을 하면 일반적으로 오류가 발생한다.\n\nvals1.sum()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-86-30a3fc8c6726&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 vals1.sum()\n\n/usr/local/lib/python3.10/dist-packages/numpy/core/_methods.py in _sum(a, axis, dtype, out, keepdims, initial, where)\n     46 def _sum(a, axis=None, dtype=None, out=None, keepdims=False,\n     47          initial=_NoValue, where=True):\n---&gt; 48     return umr_sum(a, axis, dtype, out, keepdims, initial, where)\n     49 \n     50 def _prod(a, axis=None, dtype=None, out=None, keepdims=False,\n\nTypeError: unsupported operand type(s) for +: 'int' and 'NoneType'\n\n\n\n\n\n\nNaN(Not a Number)는 표준 IEEE부동 소수점 표기를 사용하는 모든 시스템이 인식하는 특수 부동 소수점 값이다.\n\nvals2 = np.array([1, np.nan, 3, 4])\nvals2.dtype\n\ndtype('float64')\n\n\n결측치가 있는 자료의 연산에 대한 결과는 NaN이다.\n\n1 + np.nan\n\nnan\n\n\n\n0 *  np.nan\n\nnan\n\n\n\nprint(vals2)\nvals2.sum(), vals2.min(), vals2.max()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n&lt;ipython-input-1-50f8d8a9f026&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 print(vals2)\n      2 vals2.sum(), vals2.min(), vals2.max()\n\nNameError: name 'vals2' is not defined\n\n\n\nNaN을 생략하고 연산할 수 있는 함수가 있다.\n\nnp.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)\n\n\n\n\nNaN과 None를 호환성 있게 처리하고 적절한 경우에는 서로 변환할 수 있다.\n\npd.Series([1, np.nan, 2, None])\n\n0    1.0\n1    NaN\n2    2.0\n3    NaN\ndtype: float64\n\n\n\nx = pd.Series(range(2), dtype=int)\nx\n\n0    0\n1    1\ndtype: int64\n\n\n\nx[0] = None\nx\n\n0    NaN\n1    1.0\ndtype: float64\n\n\n\n\n\n\n\n\n\ndata = pd.Series([1, np.nan, 'hello', None])\ndata\n\n0        1\n1      NaN\n2    hello\n3     None\ndtype: object\n\n\n\ndata.isnull()\n\n0    False\n1     True\n2    False\n3     True\ndtype: bool\n\n\n\ndata[data.notnull()]\n\n0        1\n2    hello\ndtype: object\n\n\n\n\n\n\n\n\ndata = pd.Series([1, np.nan, 'hello', None])\ndata\n\n0        1\n1      NaN\n2    hello\n3     None\ndtype: object\n\n\n\ndata.dropna()\n\n0        1\n2    hello\ndtype: object\n\n\n\n\n\n\ndf = pd.DataFrame([[1,      np.nan, 2],\n                   [2,      3,      5],\n                   [np.nan, 4,      6]])\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\nNaN\n2\n\n\n1\n2.0\n3.0\n5\n\n\n2\nNaN\n4.0\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n기본 메소드는 널 값을 가진 행을 삭제한다.\n\ndf.dropna()\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n1\n2.0\n3.0\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n축 지정을 통해 널 값이 있는 열을 삭제할 수 있다.\n\ndf.dropna(axis='columns')\n\n\n  \n    \n\n\n\n\n\n\n2\n\n\n\n\n0\n2\n\n\n1\n5\n\n\n2\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nhow = 'any'를 사용하여 널 값을 포함하는 열 혹은 행을 모두 삭제하거나, how = 'all'을 사용하여 모두 널 값인 행 혹은 열을 삭제할 수 있다.\n\ndf[3] = np.nan\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n1.0\nNaN\n2\nNaN\n\n\n1\n2.0\n3.0\n5\nNaN\n\n\n2\nNaN\n4.0\n6\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.dropna(axis='columns', how='any')\n\n\n  \n    \n\n\n\n\n\n\n2\n\n\n\n\n0\n2\n\n\n1\n5\n\n\n2\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nnon-null의 개수를 지정할 수 있다.\n\ndf.dropna(axis='rows', thresh=3)\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n1\n2.0\n3.0\n5\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n\n\n\n\n널 값(결측치)를 다른 값으로 채울 수 있다.\n\n\n\ndata = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))\ndata\n\na    1.0\nb    NaN\nc    2.0\nd    NaN\ne    3.0\ndtype: float64\n\n\n0으로 채운다.\n\ndata.fillna(-1)\n\na    1.0\nb   -1.0\nc    2.0\nd   -1.0\ne    3.0\ndtype: float64\n\n\n앞 혹은 뒤의 값을 이용하여 널 값을 채울 수 있다.\n\n# forward-fill (전의 값))\ndata.fillna(method='ffill')\n\na    1.0\nb    1.0\nc    2.0\nd    2.0\ne    3.0\ndtype: float64\n\n\n\n# back-fill (후의 값))\ndata.fillna(method='bfill')\n\na    1.0\nb    2.0\nc    2.0\nd    3.0\ne    3.0\ndtype: float64\n\n\n\n\n\n\ndf = pd.DataFrame([[1,      np.nan, 2],\n                   [2,      3,      5],\n                   [np.nan, 4,      6]])\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\nNaN\n2\n\n\n1\n2.0\n3.0\n5\n\n\n2\nNaN\n4.0\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.fillna(method='ffill', axis=1)\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\n1.0\n2.0\n\n\n1\n2.0\n3.0\n5.0\n\n\n2\nNaN\n4.0\n6.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\nPandas에서는 계층적 인덱싱을 통해 고차원의 데이터를 효율적으로 표현할 수 있다.\n\n\n튜플로부터 다중 인덱스를 생성할 수 있다.\n\nindex = [('California', 2000), ('California', 2010),\n         ('New York', 2000), ('New York', 2010),\n         ('Texas', 2000), ('Texas', 2010)]\npopulations = [33871648, 37253956,\n               18976457, 19378102,\n               20851820, 25145561]\npop = pd.Series(populations, index=index)\npop\n\n(California, 2000)    33871648\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\n(Texas, 2010)         25145561\ndtype: int64\n\n\n\nindex = pd.MultiIndex.from_tuples(index)\nindex\n\nMultiIndex([('California', 2000),\n            ('California', 2010),\n            (  'New York', 2000),\n            (  'New York', 2010),\n            (     'Texas', 2000),\n            (     'Texas', 2010)],\n           )\n\n\n\npop = pop.reindex(index)\npop\n\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\nunstack()와 stack()는 차원을 변경해 준다:\n\npop_df = pop.unstack()\npop_df\n\n\n  \n    \n\n\n\n\n\n\n2000\n2010\n\n\n\n\nCalifornia\n33871648\n37253956\n\n\nNew York\n18976457\n19378102\n\n\nTexas\n20851820\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop_df.stack()\n\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\nMultiIndex를 이용하면 쉽게 자료를 추가할 수 있다.\n\npop_df = pd.DataFrame({'total': pop,\n                       'under18': [9267089, 9284094,\n                                   4687374, 4318033,\n                                   5906301, 6879014]})\npop_df\n\n\n  \n    \n\n\n\n\n\n\n\ntotal\nunder18\n\n\n\n\nCalifornia\n2000\n33871648\n9267089\n\n\n2010\n37253956\n9284094\n\n\nNew York\n2000\n18976457\n4687374\n\n\n2010\n19378102\n4318033\n\n\nTexas\n2000\n20851820\n5906301\n\n\n2010\n25145561\n6879014\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n유니버설 함수도 MultiIndex와 잘 동작한다.\n\n항목 추가\n항목 추가\n\n\nf_u18 = pop_df['under18'] / pop_df['total']\nf_u18.unstack()\n\n\n  \n    \n\n\n\n\n\n\n2000\n2010\n\n\n\n\nCalifornia\n0.273594\n0.249211\n\n\nNew York\n0.247010\n0.222831\n\n\nTexas\n0.283251\n0.273568\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n다중 인덱스를 가진 Series나 DataFrame을 생성하는 가장 간단한 방식은 생성자에 2개 이상의 인덱스 배열 리스트를 전달하는 것이다.\n\ndf = pd.DataFrame(np.random.rand(4, 2),\n                  index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],\n                  columns=['data1', 'data2'])\ndf\n\n\n  \n    \n      \n\n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\na\n1\n0.792886\n0.009770\n\n\n2\n0.714824\n0.091079\n\n\nb\n1\n0.376271\n0.078637\n\n\n2\n0.066049\n0.996906\n\n\n\n\n\n      \n        \n  \n    \n    \n  \n      \n      \n  \n\n      \n    \n  \n  \n\n\n\ndata = {('California', 2000): 33871648,\n        ('California', 2010): 37253956,\n        ('Texas', 2000): 20851820,\n        ('Texas', 2010): 25145561,\n        ('New York', 2000): 18976457,\n        ('New York', 2010): 19378102}\npd.Series(data)\n\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\n\n\nMultiIndex의 클래스 메서드 생성자를 사용해 더 유연하게 인덱스를 생성할 수 있다.\n\npd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], [1, 2, 1, 2]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\npd.MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b', 2)])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\n# Cartesian product\npd.MultiIndex.from_product([['a', 'b'], [1, 2]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\npd.MultiIndex(levels=[['a', 'b'], [1, 2]],\n              codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\n\n\nMultiIndex의 레벨에 이름을 지정할 수 있다.\n\npop.index.names = ['state', 'year']\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n열도 여러 레벨을 가질 수 있다.\n\n# mock some data\ndata = np.round(np.random.randn(4, 6), 1)\ndata[:, ::2] *= 10\ndata += 37\ndata\n\narray([[51. , 37. , 48. , 34.6, 59. , 35.7],\n       [32. , 36.5, 41. , 37.2, 43. , 38.2],\n       [30. , 36.9, 34. , 35.3, 21. , 37.2],\n       [37. , 37.3, 16. , 34.1, 29. , 40. ]])\n\n\n\n# hierarchical indices and columns\nindex = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],\n                                   names=['year', 'visit'])\ncolumns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],\n                                     names=['subject', 'type'])\n\n\nindex\n\nMultiIndex([(2013, 1),\n            (2013, 2),\n            (2014, 1),\n            (2014, 2)],\n           names=['year', 'visit'])\n\n\n\ncolumns\n\nMultiIndex([(  'Bob',   'HR'),\n            (  'Bob', 'Temp'),\n            ('Guido',   'HR'),\n            ('Guido', 'Temp'),\n            (  'Sue',   'HR'),\n            (  'Sue', 'Temp')],\n           names=['subject', 'type'])\n\n\n\n# create the DataFrame\nhealth_data = pd.DataFrame(data, index=index, columns=columns)\nhealth_data\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nTemp\nHR\nTemp\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n\n\n\n\n2013\n1\n51.0\n37.0\n48.0\n34.6\n59.0\n35.7\n\n\n2\n32.0\n36.5\n41.0\n37.2\n43.0\n38.2\n\n\n2014\n1\n30.0\n36.9\n34.0\n35.3\n21.0\n37.2\n\n\n2\n37.0\n37.3\n16.0\n34.1\n29.0\n40.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\n\nindex = [('California', 2000), ('California', 2010),\n         ('New York', 2000), ('New York', 2010),\n         ('Texas', 2000), ('Texas', 2010)]\npopulations = [33871648, 37253956,\n               18976457, 19378102,\n               20851820, 25145561]\npop = pd.Series(populations, index=index)\npop\n\n(California, 2000)    33871648\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\n(Texas, 2010)         25145561\ndtype: int64\n\n\n\npop[('California', 2010):('Texas', 2000)]\n\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\ndtype: int64\n\n\n다중 인덱스\n\ndata = {('California', 2000): 33871648,\n        ('California', 2010): 37253956,\n        ('Texas', 2000): 20851820,\n        ('Texas', 2010): 25145561,\n        ('New York', 2000): 18976457,\n        ('New York', 2010): 19378102}\npop = pd.Series(data)\npop.index.names = ['state', 'year']\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\npop['California', 2000]\n\n33871648\n\n\n\npop['California']\n\nyear\n2000    33871648\n2010    37253956\ndtype: int64\n\n\n\npop[:, 2000]\n\nstate\nCalifornia    33871648\nTexas         20851820\nNew York      18976457\ndtype: int64\n\n\n\npop[pop &gt; 22000000]\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2010    25145561\ndtype: int64\n\n\n\npop[['California', 'Texas']]\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n\n# hierarchical indices and columns\nindex = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],\n                                   names=['year', 'visit'])\ncolumns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],\n                                     names=['subject', 'type'])\n\n# mock some data\ndata = np.round(np.random.randn(4, 6), 1)\ndata[:, ::2] *= 10\ndata += 37\n\n# create the DataFrame\nhealth_data = pd.DataFrame(data, index=index, columns=columns)\nhealth_data\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nTemp\nHR\nTemp\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n\n\n\n\n2013\n1\n32.0\n37.0\n36.0\n37.2\n31.0\n38.3\n\n\n2\n30.0\n37.6\n34.0\n38.8\n34.0\n38.1\n\n\n2014\n1\n52.0\n38.6\n18.0\n37.1\n37.0\n38.6\n\n\n2\n46.0\n34.7\n30.0\n38.6\n40.0\n35.9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data['Guido']\n\n\n  \n    \n\n\n\n\n\n\ntype\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n2013\n1\n36.0\n37.2\n\n\n2\n34.0\n38.8\n\n\n2014\n1\n18.0\n37.1\n\n\n2\n30.0\n38.6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data['Guido', 'HR']\n\nyear  visit\n2013  1        36.0\n      2        34.0\n2014  1        18.0\n      2        30.0\nName: (Guido, HR), dtype: float64\n\n\n\nhealth_data.iloc[:2, :2]\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\n\n\n\ntype\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n2013\n1\n32.0\n37.0\n\n\n2\n30.0\n37.6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data.loc[:, ('Bob', 'HR')]\n\nyear  visit\n2013  1        32.0\n      2        30.0\n2014  1        52.0\n      2        46.0\nName: (Bob, HR), dtype: float64\n\n\n주의. 튜플 내에 슬라이스는 작동하지 않는다.\n\nhealth_data.loc[(:, 1), (:, 'HR')]\n\n\n  File \"&lt;ipython-input-70-fb34fa30ac09&gt;\", line 1\n    health_data.loc[(:, 1), (:, 'HR')]\n                     ^\nSyntaxError: invalid syntax\n\n\n\n\n주의. IndexSlice 객체를 이용하면 쉽게 해결할 수 있다.\n\nidx = pd.IndexSlice\nhealth_data.loc[idx[:, 1], idx[:, 'HR']]\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nHR\nHR\n\n\nyear\nvisit\n\n\n\n\n\n\n\n2013\n1\n32.0\n36.0\n31.0\n\n\n2014\n1\n52.0\n18.0\n37.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\n\n대부분의 MultiIndex 슬라이싱 연산은 인덱스가 정렬돼 있지 않으면 실패한다.\n\nindex = pd.MultiIndex.from_product([['a', 'c', 'b'], [1, 2]])\ndata = pd.Series(np.random.rand(6), index=index)\ndata.index.names = ['char', 'int']\ndata\n\nchar  int\na     1      0.856959\n      2      0.626968\nc     1      0.080189\n      2      0.855903\nb     1      0.033432\n      2      0.851495\ndtype: float64\n\n\n\ndata['a':'b']\n\n\n---------------------------------------------------------------------------\nUnsortedIndexError                        Traceback (most recent call last)\n&lt;ipython-input-74-0e6568674d17&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 data['a':'b']\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/series.py in __getitem__(self, key)\n   1005             return self._get_values(key)\n   1006 \n-&gt; 1007         return self._get_with(key)\n   1008 \n   1009     def _get_with(self, key):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/series.py in _get_with(self, key)\n   1012             # _convert_slice_indexer to determine if this slice is positional\n   1013             #  or label based, and if the latter, convert to positional\n-&gt; 1014             slobj = self.index._convert_slice_indexer(key, kind=\"getitem\")\n   1015             return self._slice(slobj)\n   1016         elif isinstance(key, ABCDataFrame):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in _convert_slice_indexer(self, key, kind)\n   4282             indexer = key\n   4283         else:\n-&gt; 4284             indexer = self.slice_indexer(start, stop, step)\n   4285 \n   4286         return indexer\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in slice_indexer(self, start, end, step, kind)\n   6557         self._deprecated_arg(kind, \"kind\", \"slice_indexer\")\n   6558 \n-&gt; 6559         start_slice, end_slice = self.slice_locs(start, end, step=step)\n   6560 \n   6561         # return a slice\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in slice_locs(self, start, end, step, kind)\n   2773         # This function adds nothing to its parent implementation (the magic\n   2774         # happens in get_slice_bound method), but it adds meaningful doc.\n-&gt; 2775         return super().slice_locs(start, end, step)\n   2776 \n   2777     def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in slice_locs(self, start, end, step, kind)\n   6765         start_slice = None\n   6766         if start is not None:\n-&gt; 6767             start_slice = self.get_slice_bound(start, \"left\")\n   6768         if start_slice is None:\n   6769             start_slice = 0\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in get_slice_bound(self, label, side, kind)\n   2712         if not isinstance(label, tuple):\n   2713             label = (label,)\n-&gt; 2714         return self._partial_tup_index(label, side=side)\n   2715 \n   2716     def slice_locs(\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in _partial_tup_index(self, tup, side)\n   2777     def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n   2778         if len(tup) &gt; self._lexsort_depth:\n-&gt; 2779             raise UnsortedIndexError(\n   2780                 f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n   2781                 f\"({self._lexsort_depth})\"\n\nUnsortedIndexError: 'Key length (1) was greater than MultiIndex lexsort depth (0)'\n\n\n\n\n#try:\n#    data['a':'b']\n#except KeyError as e:\n#    print(type(e))\n#    print(e)\n\n&lt;class 'pandas.errors.UnsortedIndexError'&gt;\n'Key length (1) was greater than MultiIndex lexsort depth (0)'\n\n\n\n\n\n\ndata = data.sort_index()\ndata\n\nchar  int\na     1      0.856959\n      2      0.626968\nb     1      0.033432\n      2      0.851495\nc     1      0.080189\n      2      0.855903\ndtype: float64\n\n\n\ndata['a':'b']\n\nchar  int\na     1      0.856959\n      2      0.626968\nb     1      0.033432\n      2      0.851495\ndtype: float64\n\n\n\n\n\n\n다중 인덱스에서 간단한 2차원 표현으로 변경할 수 있다.\n\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\npop.unstack(level=0)\n\n\n  \n    \n\n\n\n\n\nstate\nCalifornia\nNew York\nTexas\n\n\nyear\n\n\n\n\n\n\n\n2000\n33871648\n18976457\n20851820\n\n\n2010\n37253956\n19378102\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop.unstack(level=1)\n\n\n  \n    \n\n\n\n\n\nyear\n2000\n2010\n\n\nstate\n\n\n\n\n\n\nCalifornia\n33871648\n37253956\n\n\nNew York\n18976457\n19378102\n\n\nTexas\n20851820\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop.unstack().stack()\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n계층적 데이터를 재정렬하는 또 다른 방법은 인덱스 레이블을 열로 바꾸는 것이다.\n\npop_flat = pop.reset_index(name='population')\npop_flat\n\n\n  \n    \n\n\n\n\n\n\nstate\nyear\npopulation\n\n\n\n\n0\nCalifornia\n2000\n33871648\n\n\n1\nCalifornia\n2010\n37253956\n\n\n2\nTexas\n2000\n20851820\n\n\n3\nTexas\n2010\n25145561\n\n\n4\nNew York\n2000\n18976457\n\n\n5\nNew York\n2010\n19378102\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n열 값을 이용해서 MultiIndex를 만들 수 있다.\n\npop_flat.set_index(['state', 'year'])\n\n\n  \n    \n\n\n\n\n\n\n\npopulation\n\n\nstate\nyear\n\n\n\n\n\nCalifornia\n2000\n33871648\n\n\n2010\n37253956\n\n\nTexas\n2000\n20851820\n\n\n2010\n25145561\n\n\nNew York\n2000\n18976457\n\n\n2010\n19378102\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\nPandas에서는 서로 다른 데이터 소스를 결합하는 함수와 메소드를 제공한다.\n\ndef make_df(cols, ind):\n    \"\"\"Quickly make a DataFrame\"\"\"\n    data = {c: [str(c) + str(i) for i in ind]\n            for c in cols}\n    return pd.DataFrame(data, ind)\n\n# example DataFrame\nmake_df('ABC', range(3))\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\nA0\nB0\nC0\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n#class display(object):\n#    \"\"\"Display HTML representation of multiple objects\"\"\"\n#    template = \"\"\"&lt;div style=\"float: left; padding: 10px;\"&gt;\n#    &lt;p style='font-family:\"Courier New\", Courier, monospace'&gt;{0}&lt;/p&gt;{1}\n#    &lt;/div&gt;\"\"\"\n#    def __init__(self, *args):\n#        self.args = args\n\n#    def _repr_html_(self):\n#        return '\\n'.join(self.template.format(a, eval(a)._repr_html_())\n#                         for a in self.args)\n\n#    def __repr__(self):\n#        return '\\n\\n'.join(a + '\\n' + repr(eval(a))\n#                           for a in self.args)\n\n\n\n\n# Signature in Pandas v0.18\npd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,\n          keys=None, levels=None, names=None, verify_integrity=False,\n          copy=True)\n\nser1 = pd.Series(['A', 'B', 'C'], index=[1, 2, 3])\nser2 = pd.Series(['D', 'E', 'F'], index=[4, 5, 6])\npd.concat([ser1, ser2])\n\n1    A\n2    B\n3    C\n4    D\n5    E\n6    F\ndtype: object\n\n\n\ndf1 = make_df('AB', [1, 2])\ndf2 = make_df('AB', [3, 4])\ndisplay('df1', 'df2', \"pd.concat([df1, df2])\")\n\n\n    df1\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nA\nB\n\n\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n    pd.concat([df1, df2])\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n\n\ndf3 = make_df('AB', [0, 1])\ndf4 = make_df('CD', [0, 1])\ndisplay('df3', 'df4', \"pd.concat([df3, df4], axis=1,sort=True)\")\n\n\n    df3\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    df4\n\n\n\n\n\n\nC\nD\n\n\n\n\n0\nC0\nD0\n\n\n1\nC1\nD1\n\n\n\n\n\n    \n\n    pd.concat([df3, df4], axis=1,sort=True)\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\nA0\nB0\nC0\nD0\n\n\n1\nA1\nB1\nC1\nD1\n\n\n\n\n\n    \n\n\n\n\nPandas의 concat경우 복제된 인덱스를 가지더라도 인덱스를 유지한다.\n\nx = make_df('AB', [0, 1])\ny = make_df('AB', [2, 3])\ny.index = x.index  # make duplicate indices!\ndisplay('x', 'y', 'pd.concat([x, y])')\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y])\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\ndisplay('x', 'y', 'pd.concat([x, y], ignore_index=True)')\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y], ignore_index=True)\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\n\ndisplay('x', 'y', \"pd.concat([x, y], keys=['x', 'y'])\")\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y], keys=['x', 'y'])\n\n\n\n\n\n\n\nA\nB\n\n\n\n\nx\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\ny\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\n\n\ndf5 = make_df('ABC', [1, 2])\ndf6 = make_df('BCD', [3, 4])\ndisplay('df5', 'df6', 'pd.concat([df5, df6],sort=True)')\n\n\n    df5\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n    df6\n\n\n\n\n\n\nB\nC\nD\n\n\n\n\n3\nB3\nC3\nD3\n\n\n4\nB4\nC4\nD4\n\n\n\n\n\n    \n\n    pd.concat([df5, df6],sort=True)\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nA1\nB1\nC1\nNaN\n\n\n2\nA2\nB2\nC2\nNaN\n\n\n3\nNaN\nB3\nC3\nD3\n\n\n4\nNaN\nB4\nC4\nD4\n\n\n\n\n\n    \n\n\njoin = 'inner'를 이용하여 열의 교집합으로 변경할 수 있다.\n\ndisplay('df5', 'df6',\n        \"pd.concat([df5, df6], join='inner')\")\n\n\n    df5\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n    df6\n\n\n\n\n\n\nB\nC\nD\n\n\n\n\n3\nB3\nC3\nD3\n\n\n4\nB4\nC4\nD4\n\n\n\n\n\n    \n\n    pd.concat([df5, df6], join='inner')\n\n\n\n\n\n\nB\nC\n\n\n\n\n1\nB1\nC1\n\n\n2\nB2\nC2\n\n\n3\nB3\nC3\n\n\n4\nB4\nC4\n\n\n\n\n\n    \n\n\n\n\n\n배열을 직접 연결할 수 있는 메소드를 가지고 있다.\n\ndisplay('df1', 'df2', 'df1.append(df2)')\n\n&lt;string&gt;:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n&lt;string&gt;:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n\n\n\n    df1\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nA\nB\n\n\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n    df1.append(df2)\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n\n\n\n\nmerge에는 관계 데이터(relation data)를 조작하는 규칙의 정형 집합이자 대부분의 데이터베이스에서 사용할 수 있는 연산의 개념적 기반을 형성하는 관계 대수(relational algebra)의 하위 집합에 해당하는 행위가 구현돼 있다.\n\n\n\ndf1 = pd.DataFrame({'employee': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'group': ['Accounting', 'Engineering', 'Engineering', 'HR']})\ndf2 = pd.DataFrame({'employee': ['Lisa', 'Bob', 'Jake', 'Sue'],\n                    'hire_date': [2004, 2008, 2012, 2014]})\ndisplay('df1', 'df2')\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nemployee\nhire_date\n\n\n\n\n0\nLisa\n2004\n\n\n1\nBob\n2008\n\n\n2\nJake\n2012\n\n\n3\nSue\n2014\n\n\n\n\n\n    \n\n\n\ndf3 = pd.merge(df1, df2)\ndf3\n\n\n  \n    \n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\ndf4 = pd.DataFrame({'group': ['Accounting', 'Engineering', 'HR'],\n                    'supervisor': ['Carly', 'Guido', 'Steve']})\ndisplay('df3', 'df4', 'pd.merge(df3, df4)')\n\n\n    df3\n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n    df4\n\n\n\n\n\n\ngroup\nsupervisor\n\n\n\n\n0\nAccounting\nCarly\n\n\n1\nEngineering\nGuido\n\n\n2\nHR\nSteve\n\n\n\n\n\n    \n\n    pd.merge(df3, df4)\n\n\n\n\n\n\nemployee\ngroup\nhire_date\nsupervisor\n\n\n\n\n0\nBob\nAccounting\n2008\nCarly\n\n\n1\nJake\nEngineering\n2012\nGuido\n\n\n2\nLisa\nEngineering\n2004\nGuido\n\n\n3\nSue\nHR\n2014\nSteve\n\n\n\n\n\n    \n\n\n\n\n\n\ndf5 = pd.DataFrame({'group': ['Accounting', 'Accounting',\n                              'Engineering', 'Engineering', 'HR', 'HR'],\n                    'skills': ['math', 'spreadsheets', 'coding', 'linux',\n                               'spreadsheets', 'organization']})\ndisplay('df1', 'df5', \"pd.merge(df1, df5)\")\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df5\n\n\n\n\n\n\ngroup\nskills\n\n\n\n\n0\nAccounting\nmath\n\n\n1\nAccounting\nspreadsheets\n\n\n2\nEngineering\ncoding\n\n\n3\nEngineering\nlinux\n\n\n4\nHR\nspreadsheets\n\n\n5\nHR\norganization\n\n\n\n\n\n    \n\n    pd.merge(df1, df5)\n\n\n\n\n\n\nemployee\ngroup\nskills\n\n\n\n\n0\nBob\nAccounting\nmath\n\n\n1\nBob\nAccounting\nspreadsheets\n\n\n2\nJake\nEngineering\ncoding\n\n\n3\nJake\nEngineering\nlinux\n\n\n4\nLisa\nEngineering\ncoding\n\n\n5\nLisa\nEngineering\nlinux\n\n\n6\nSue\nHR\nspreadsheets\n\n\n7\nSue\nHR\norganization\n\n\n\n\n\n    \n\n\n\n\n\n\n열 이름을 지정하여 데이터를 결합할 수 있다.\n\n\n\ndisplay('df1', 'df2', \"pd.merge(df1, df2, on='employee')\")\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nemployee\nhire_date\n\n\n\n\n0\nLisa\n2004\n\n\n1\nBob\n2008\n\n\n2\nJake\n2012\n\n\n3\nSue\n2014\n\n\n\n\n\n    \n\n    pd.merge(df1, df2, on='employee')\n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\n\n\n\n\ndf3 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'salary': [70000, 80000, 120000, 90000]})\ndisplay('df1', 'df3', 'pd.merge(df1, df3, left_on=\"employee\", right_on=\"name\")')\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df3\n\n\n\n\n\n\nname\nsalary\n\n\n\n\n0\nBob\n70000\n\n\n1\nJake\n80000\n\n\n2\nLisa\n120000\n\n\n3\nSue\n90000\n\n\n\n\n\n    \n\n    pd.merge(df1, df3, left_on=\"employee\", right_on=\"name\")\n\n\n\n\n\n\nemployee\ngroup\nname\nsalary\n\n\n\n\n0\nBob\nAccounting\nBob\n70000\n\n\n1\nJake\nEngineering\nJake\n80000\n\n\n2\nLisa\nEngineering\nLisa\n120000\n\n\n3\nSue\nHR\nSue\n90000\n\n\n\n\n\n    \n\n\n\npd.merge(df1, df3, left_on=\"employee\", right_on=\"name\").drop('name', axis=1)\n\n\n  \n    \n\n\n\n\n\n\nemployee\ngroup\nsalary\n\n\n\n\n0\nBob\nAccounting\n70000\n\n\n1\nJake\nEngineering\n80000\n\n\n2\nLisa\nEngineering\n120000\n\n\n3\nSue\nHR\n90000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n인덱스를 통해 병합할 수 있다.\n\nprint(df1.head())\nprint(df2.head())\ndf1a = df1.set_index('employee')\n# 특정 열을 변수명으로 전환\ndf2a = df2.set_index('employee')\ndisplay('df1a', 'df2a')\n\n  employee        group\n0      Bob   Accounting\n1     Jake  Engineering\n2     Lisa  Engineering\n3      Sue           HR\n  employee  hire_date\n0     Lisa       2004\n1      Bob       2008\n2     Jake       2012\n3      Sue       2014\n\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n\n\ndisplay('df1a', 'df2a',\n        \"pd.merge(df1a, df2a, left_index=True, right_index=True)\")\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n    pd.merge(df1a, df2a, left_index=True, right_index=True)\n\n\n\n\n\n\ngroup\nhire_date\n\n\nemployee\n\n\n\n\n\n\nBob\nAccounting\n2008\n\n\nJake\nEngineering\n2012\n\n\nLisa\nEngineering\n2004\n\n\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\njoin() 메소드는 인덱스 기반으로 조인하는 병합을 수행한다.\n\ndisplay('df1a', 'df2a', 'df1a.join(df2a)')\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n    df1a.join(df2a)\n\n\n\n\n\n\ngroup\nhire_date\n\n\nemployee\n\n\n\n\n\n\nBob\nAccounting\n2008\n\n\nJake\nEngineering\n2012\n\n\nLisa\nEngineering\n2004\n\n\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\n인덱스와 열을 섞어서 결합할 수 있다.\n\ndisplay('df1a', 'df3', \"pd.merge(df1a, df3, left_index=True, right_on='name')\")\n# **_index: index name, **_on: variable name\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df3\n\n\n\n\n\n\nname\nsalary\n\n\n\n\n0\nBob\n70000\n\n\n1\nJake\n80000\n\n\n2\nLisa\n120000\n\n\n3\nSue\n90000\n\n\n\n\n\n    \n\n    pd.merge(df1a, df3, left_index=True, right_on='name')\n\n\n\n\n\n\ngroup\nname\nsalary\n\n\n\n\n0\nAccounting\nBob\n70000\n\n\n1\nEngineering\nJake\n80000\n\n\n2\nEngineering\nLisa\n120000\n\n\n3\nHR\nSue\n90000\n\n\n\n\n\n    \n\n\n\n\n\n\nhow 키워드를 사용하면 결합하는 방법을 명시적으로 지정할 수 있다.\n\ndf6 = pd.DataFrame({'name': ['Peter', 'Paul', 'Mary'],\n                    'food': ['fish', 'beans', 'bread']},\n                   columns=['name', 'food'])\ndf7 = pd.DataFrame({'name': ['Mary', 'Joseph'],\n                    'drink': ['wine', 'beer']},\n                   columns=['name', 'drink'])\ndisplay('df6', 'df7', 'pd.merge(df6, df7)')\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7)\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nMary\nbread\nwine\n\n\n\n\n\n    \n\n\n\npd.merge(df6, df7, how='inner')\n\n\n  \n    \n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nMary\nbread\nwine\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n\ndisplay('df6', 'df7', \"pd.merge(df6, df7, how='outer')\")\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7, how='outer')\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nPeter\nfish\nNaN\n\n\n1\nPaul\nbeans\nNaN\n\n\n2\nMary\nbread\nwine\n\n\n3\nJoseph\nNaN\nbeer\n\n\n\n\n\n    \n\n\n\ndisplay('df6', 'df7', \"pd.merge(df6, df7, how='left')\")\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7, how='left')\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nPeter\nfish\nNaN\n\n\n1\nPaul\nbeans\nNaN\n\n\n2\nMary\nbread\nwine\n\n\n\n\n\n    \n\n\n\n\n\n\ndf8 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'rank': [1, 2, 3, 4]})\ndf9 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'rank': [3, 1, 4, 2]})\ndisplay('df8', 'df9', 'pd.merge(df8, df9, on=\"name\")')\n\n\n    df8\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n1\n\n\n1\nJake\n2\n\n\n2\nLisa\n3\n\n\n3\nSue\n4\n\n\n\n\n\n    \n\n    df9\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n3\n\n\n1\nJake\n1\n\n\n2\nLisa\n4\n\n\n3\nSue\n2\n\n\n\n\n\n    \n\n    pd.merge(df8, df9, on=\"name\")\n\n\n\n\n\n\nname\nrank_x\nrank_y\n\n\n\n\n0\nBob\n1\n3\n\n\n1\nJake\n2\n1\n\n\n2\nLisa\n3\n4\n\n\n3\nSue\n4\n2\n\n\n\n\n\n    \n\n\nsuffixes옵션을 사용하면 겹치는 변수의 이름을 지정할 수 있다.\n\ndisplay('df8', 'df9', 'pd.merge(df8, df9, on=\"name\", suffixes=[\"_L\", \"_R\"])')\n\n\n    df8\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n1\n\n\n1\nJake\n2\n\n\n2\nLisa\n3\n\n\n3\nSue\n4\n\n\n\n\n\n    \n\n    df9\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n3\n\n\n1\nJake\n1\n\n\n2\nLisa\n4\n\n\n3\nSue\n2\n\n\n\n\n\n    \n\n    pd.merge(df8, df9, on=\"name\", suffixes=[\"_L\", \"_R\"])\n\n\n\n\n\n\nname\nrank_L\nrank_R\n\n\n\n\n0\nBob\n1\n3\n\n\n1\nJake\n2\n1\n\n\n2\nLisa\n3\n4\n\n\n3\nSue\n4\n2\n\n\n\n\n\n    \n\n\n\n\n\n\n자료 받기\n\n# Following are shell commands to download the data\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-population.csv\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-areas.csv\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-abbrevs.csv\n\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 57935  100 57935    0     0   175k      0 --:--:-- --:--:-- --:--:--  175k\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   835  100   835    0     0   4135      0 --:--:-- --:--:-- --:--:--  4154\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   872  100   872    0     0   4538      0 --:--:-- --:--:-- --:--:--  4518\n\n\nread_csv() 함수를 이용하여 자료읽기\n\npop = pd.read_csv('state-population.csv')\nareas = pd.read_csv('state-areas.csv')\nabbrevs = pd.read_csv('state-abbrevs.csv')\n\ndisplay('pop.head()', 'areas.head()', 'abbrevs.head()')\n\n\n    pop.head()\n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\n\n\n\n\n\n    \n\n    areas.head()\n\n\n\n\n\n\nstate\narea (sq. mi)\n\n\n\n\n0\nAlabama\n52423\n\n\n1\nAlaska\n656425\n\n\n2\nArizona\n114006\n\n\n3\nArkansas\n53182\n\n\n4\nCalifornia\n163707\n\n\n\n\n\n    \n\n    abbrevs.head()\n\n\n\n\n\n\nstate\nabbreviation\n\n\n\n\n0\nAlabama\nAL\n\n\n1\nAlaska\nAK\n\n\n2\nArizona\nAZ\n\n\n3\nArkansas\nAR\n\n\n4\nCalifornia\nCA\n\n\n\n\n\n    \n\n\n\n\n\n인구(population)와 주의 전체 이름을 제공하는 데이터 결합\n\n\nmerged = pd.merge(pop, abbrevs, how='outer',\n                  left_on='state/region', right_on='abbreviation')\nmerged = merged.drop('abbreviation', 1) # drop duplicate info\nmerged.head()\n\nFutureWarning: In a future version of pandas all arguments of DataFrame.drop except for the argument 'labels' will be keyword-only.\n  merged = merged.drop('abbreviation', 1) # drop duplicate info\n\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nNull값 찾기\n\n\nmerged.isnull().any()\n\nstate/region    False\nages            False\nyear            False\npopulation       True\nstate            True\ndtype: bool\n\n\n\nmerged[merged['population'].isnull()].head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\n\n\n\n\n2448\nPR\nunder18\n1990\nNaN\nPuerto Rico\n\n\n2449\nPR\ntotal\n1990\nNaN\nPuerto Rico\n\n\n2450\nPR\ntotal\n1991\nNaN\nPuerto Rico\n\n\n2451\nPR\nunder18\n1991\nNaN\nPuerto Rico\n\n\n2452\nPR\ntotal\n1993\nNaN\nPuerto Rico\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nmerged.loc[merged['state'].isnull(), 'state/region']\nmerged.loc[merged['state'].isnull(), 'state/region'].unique()\n\narray(['PR', 'USA'], dtype=object)\n\n\n\n널 값에 항목 채워 넣기\n\n\nmerged.loc[merged['state/region'] == 'PR', 'state'] = 'Puerto Rico'\nmerged.loc[merged['state/region'] == 'USA', 'state'] = 'United States'\nmerged.isnull().any()\n\nstate/region    False\nages            False\nyear            False\npopulation       True\nstate           False\ndtype: bool\n\n\n\n면적 데이터의 결합\n\n\nfinal = pd.merge(merged, areas, on='state', how='left')\nfinal.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n52423.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n52423.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n52423.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n52423.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nNull값 찾기\n\n\nfinal.isnull().any()\n\nstate/region     False\nages             False\nyear             False\npopulation        True\nstate            False\narea (sq. mi)     True\ndtype: bool\n\n\n\nfinal['state'][final['area (sq. mi)'].isnull()].unique()\n\narray(['United States'], dtype=object)\n\n\n\nNull값 삭제\n\n\nfinal.dropna(inplace=True) # NULL 삭제\nfinal.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n52423.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n52423.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n52423.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n52423.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nfinal['state'][final['area (sq. mi)'].isnull()].unique()\n\narray([], dtype=object)\n\n\n\n특정 데이터 선택: query() 사용\n\n\n#!pip3 install numexpr\n\nRequirement already satisfied: numexpr in /usr/local/lib/python3.10/dist-packages (2.8.7)\nRequirement already satisfied: numpy&gt;=1.13.3 in /usr/local/lib/python3.10/dist-packages (from numexpr) (1.23.5)\n\n\n\ndata2010 = final[(final.year == 2010) & (final.ages == 'total')]\ndata2010.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n91\nAK\ntotal\n2010\n713868.0\nAlaska\n656425.0\n\n\n101\nAZ\ntotal\n2010\n6408790.0\nArizona\n114006.0\n\n\n189\nAR\ntotal\n2010\n2922280.0\nArkansas\n53182.0\n\n\n197\nCA\ntotal\n2010\n37333601.0\nCalifornia\n163707.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndata2010 = final.query(\"year == 2010 & ages == 'total'\")\ndata2010.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n91\nAK\ntotal\n2010\n713868.0\nAlaska\n656425.0\n\n\n101\nAZ\ntotal\n2010\n6408790.0\nArizona\n114006.0\n\n\n189\nAR\ntotal\n2010\n2922280.0\nArkansas\n53182.0\n\n\n197\nCA\ntotal\n2010\n37333601.0\nCalifornia\n163707.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n인구 밀도 계산\n\n\ndata2010.set_index('state', inplace=True)\n# 변수를 첨자로 변환\ndensity = data2010['population'] / data2010['area (sq. mi)']\n# density.head()\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-141-b633852d4acf&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 data2010.set_index('state', inplace=True)\n      2 # 변수를 첨자로 변환\n      3 data2010.index\n      4 density = data2010['population'] / data2010['area (sq. mi)']\n      5 # density.head()\n\n/usr/local/lib/python3.10/dist-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)\n    329                     stacklevel=find_stack_level(),\n    330                 )\n--&gt; 331             return func(*args, **kwargs)\n    332 \n    333         # error: \"Callable[[VarArg(Any), KwArg(Any)], Any]\" has no\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/frame.py in set_index(self, keys, drop, append, inplace, verify_integrity)\n   6010 \n   6011         if missing:\n-&gt; 6012             raise KeyError(f\"None of {missing} are in the columns\")\n   6013 \n   6014         if inplace:\n\nKeyError: \"None of ['state'] are in the columns\"\n\n\n\n\ndensity.sort_values(ascending=False, inplace=True)\ndensity.head()\n\nstate\nDistrict of Columbia    8898.897059\nPuerto Rico             1058.665149\nNew Jersey              1009.253268\nRhode Island             681.339159\nConnecticut              645.600649\ndtype: float64\n\n\n\ndensity.tail()\n\nstate\nSouth Dakota    10.583512\nNorth Dakota     9.537565\nMontana          6.736171\nWyoming          5.768079\nAlaska           1.087509\ndtype: float64\n\n\n\n\n\n\n\n\n\nplanets = pd.read_csv('/content/planets.csv')\nplanets.shape\n\n(1035, 6)\n\n\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\n\nMounted at /content/drive\n\n\n\nplanets.head()\n\n\n  \n    \n\n\n\n\n\n\nmethod\nnumber\norbital_period\nmass\ndistance\nyear\n\n\n\n\n0\nRadial Velocity\n1\n269.300\n7.10\n77.40\n2006\n\n\n1\nRadial Velocity\n1\n874.774\n2.21\n56.95\n2008\n\n\n2\nRadial Velocity\n1\n763.000\n2.60\n19.84\n2011\n\n\n3\nRadial Velocity\n1\n326.030\n19.40\n110.62\n2007\n\n\n4\nRadial Velocity\n1\n516.220\n10.50\n119.47\n2009\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\nplanets.dropna().describe()\n#describe: 요약통계량\n\n\n  \n    \n\n\n\n\n\n\nnumber\norbital_period\nmass\ndistance\nyear\n\n\n\n\ncount\n498.00000\n498.000000\n498.000000\n498.000000\n498.000000\n\n\nmean\n1.73494\n835.778671\n2.509320\n52.068213\n2007.377510\n\n\nstd\n1.17572\n1469.128259\n3.636274\n46.596041\n4.167284\n\n\nmin\n1.00000\n1.328300\n0.003600\n1.350000\n1989.000000\n\n\n25%\n1.00000\n38.272250\n0.212500\n24.497500\n2005.000000\n\n\n50%\n1.00000\n357.000000\n1.245000\n39.940000\n2009.000000\n\n\n75%\n2.00000\n999.600000\n2.867500\n59.332500\n2011.000000\n\n\nmax\n6.00000\n17337.500000\n25.000000\n354.000000\n2014.000000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nPandas에서 제공하는 집계 연산:\n\n\n\nAggregation\nDescription\n\n\n\n\ncount()\nTotal number of items\n\n\nfirst(), last()\nFirst and last item\n\n\nmean(), median()\nMean and median\n\n\nmin(), max()\nMinimum and maximum\n\n\nstd(), var()\nStandard deviation and variance\n\n\nmad()\nMean absolute deviation\n\n\nprod()\nProduct of all items\n\n\nsum()\nSum of all items\n\n\n\n\n\n\n\n자료를 요약할 때 특정 기준을 이용할 수 있다.\n\ndf = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'data': range(6)}, columns=['key', 'data'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nkey\ndata\n\n\n\n\n0\nA\n0\n\n\n1\nB\n1\n\n\n2\nC\n2\n\n\n3\nA\n3\n\n\n4\nB\n4\n\n\n5\nC\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\ngroupby():\n\ndf.groupby('key').sum()\n\n\n  \n    \n\n\n\n\n\n\ndata\n\n\nkey\n\n\n\n\n\nA\n3\n\n\nB\n5\n\n\nC\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\nmethod별 orbital_period의 중앙값 계산\n\nplanets.groupby('method')['orbital_period'].median()\n\nmethod\nAstrometry                         631.180000\nEclipse Timing Variations         4343.500000\nImaging                          27500.000000\nMicrolensing                      3300.000000\nOrbital Brightness Modulation        0.342887\nPulsar Timing                       66.541900\nPulsation Timing Variations       1170.000000\nRadial Velocity                    360.200000\nTransit                              5.714932\nTransit Timing Variations           57.011000\nName: orbital_period, dtype: float64\n\n\n\n\n\n\nfor (method, group) in planets.groupby('method'):\n    print(\"{0:30s} shape={1}\".format(method, group.shape))\n\nAstrometry                     shape=(2, 6)\nEclipse Timing Variations      shape=(9, 6)\nImaging                        shape=(38, 6)\nMicrolensing                   shape=(23, 6)\nOrbital Brightness Modulation  shape=(3, 6)\nPulsar Timing                  shape=(5, 6)\nPulsation Timing Variations    shape=(1, 6)\nRadial Velocity                shape=(553, 6)\nTransit                        shape=(397, 6)\nTransit Timing Variations      shape=(4, 6)\n\n\n\n\n\nmethod별 year에 대한 요약 통계량 계산\n\nplanets.groupby('method')['year'].describe()\n\n\n  \n    \n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\nmethod\n\n\n\n\n\n\n\n\n\n\n\n\nAstrometry\n2.0\n2011.500000\n2.121320\n2010.0\n2010.75\n2011.5\n2012.25\n2013.0\n\n\nEclipse Timing Variations\n9.0\n2010.000000\n1.414214\n2008.0\n2009.00\n2010.0\n2011.00\n2012.0\n\n\nImaging\n38.0\n2009.131579\n2.781901\n2004.0\n2008.00\n2009.0\n2011.00\n2013.0\n\n\nMicrolensing\n23.0\n2009.782609\n2.859697\n2004.0\n2008.00\n2010.0\n2012.00\n2013.0\n\n\nOrbital Brightness Modulation\n3.0\n2011.666667\n1.154701\n2011.0\n2011.00\n2011.0\n2012.00\n2013.0\n\n\nPulsar Timing\n5.0\n1998.400000\n8.384510\n1992.0\n1992.00\n1994.0\n2003.00\n2011.0\n\n\nPulsation Timing Variations\n1.0\n2007.000000\nNaN\n2007.0\n2007.00\n2007.0\n2007.00\n2007.0\n\n\nRadial Velocity\n553.0\n2007.518987\n4.249052\n1989.0\n2005.00\n2009.0\n2011.00\n2014.0\n\n\nTransit\n397.0\n2011.236776\n2.077867\n2002.0\n2010.00\n2012.0\n2013.00\n2014.0\n\n\nTransit Timing Variations\n4.0\n2012.500000\n1.290994\n2011.0\n2011.75\n2012.5\n2013.25\n2014.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\nrng = np.random.RandomState(0)\ndf = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'data1': range(6),\n                   'data2': rng.randint(0, 10, 6)},\n                   columns = ['key', 'data1', 'data2'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\naggregate 메소드를 사용하면 더 유연하게 요약 통계량을 계산할 수 있다.\n\ndf.groupby('key').aggregate(['min', np.median, max])\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\n\nmin\nmedian\nmax\nmin\nmedian\nmax\n\n\nkey\n\n\n\n\n\n\n\n\n\n\nA\n0\n1.5\n3\n3\n4.0\n5\n\n\nB\n1\n2.5\n4\n0\n3.5\n7\n\n\nC\n2\n3.5\n5\n3\n6.0\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.groupby('key').aggregate({'data1': 'min',\n                             'data2': 'max'})\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n7\n\n\nC\n2\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n필터연산을 사용하면 그룹 속성을 기준으로 데이터를 추출할 수 있다.\n\ndef filter_func(x):\n    return x['data2'].std() &gt; 4\n\ndisplay('df', \"df.groupby('key').std()\", \"df.groupby('key').filter(filter_func)\")\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby('key').std()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n2.12132\n1.414214\n\n\nB\n2.12132\n4.949747\n\n\nC\n2.12132\n4.242641\n\n\n\n\n\n    \n\n    df.groupby('key').filter(filter_func)\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n\n\n\n\n전체 데이터의 변환된 버전을 반환할 수 있다.\n\ndf.groupby('key').transform(lambda x: x - x.mean())\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\n0\n-1.5\n1.0\n\n\n1\n-1.5\n-3.5\n\n\n2\n-1.5\n-3.0\n\n\n3\n1.5\n-1.0\n\n\n4\n1.5\n3.5\n\n\n5\n1.5\n3.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n임의의 함수를 그룹 결과에 적용할 때 사용된다.\n\ndef norm_by_data2(x):\n    # x is a DataFrame of group values\n    x['data1'] /= x['data2'].sum()\n    return x\n\ndisplay('df', \"df.groupby('key').apply(norm_by_data2)\")\n\n&lt;string&gt;:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n    &gt;&gt;&gt; .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n    &gt;&gt;&gt; .groupby(..., group_keys=True)\n&lt;string&gt;:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n    &gt;&gt;&gt; .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n    &gt;&gt;&gt; .groupby(..., group_keys=True)\n\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby('key').apply(norm_by_data2)\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0.000000\n5\n\n\n1\nB\n0.142857\n0\n\n\n2\nC\n0.166667\n3\n\n\n3\nA\n0.375000\n3\n\n\n4\nB\n0.571429\n7\n\n\n5\nC\n0.416667\n9\n\n\n\n\n\n    \n\n\n\n\n\n\n\nL = [0, 1, 0, 1, 2, 0]\ndisplay('df', 'df.groupby(L).sum()')\n\n&lt;string&gt;:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n&lt;string&gt;:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby(L).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\n0\n7\n17\n\n\n1\n4\n3\n\n\n2\n4\n7\n\n\n\n\n\n    \n\n\n\ndisplay('df', \"df.groupby(df['key']).sum()\")\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby(df['key']).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n3\n8\n\n\nB\n5\n7\n\n\nC\n7\n12\n\n\n\n\n\n    \n\n\n인덱스 값을 그룹 키에 매핑하는 딕셔너리를 제공할 수 있다.\n\ndf2 = df.set_index('key')\nmapping = {'A': 'vowel', 'B': 'consonant', 'C': 'consonant'}\ndisplay('df2', 'df2.groupby(mapping).sum()')\n\n\n    df2\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n0\n\n\nC\n2\n3\n\n\nA\n3\n3\n\n\nB\n4\n7\n\n\nC\n5\n9\n\n\n\n\n\n    \n\n    df2.groupby(mapping).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nconsonant\n12\n19\n\n\nvowel\n3\n8\n\n\n\n\n\n    \n\n\nPython함수를 사용할 수 있다.\n\n?str.lower\n\n\ndisplay('df2', 'df2.groupby(str.lower).mean()')\n\n\n    df2\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n0\n\n\nC\n2\n3\n\n\nA\n3\n3\n\n\nB\n4\n7\n\n\nC\n5\n9\n\n\n\n\n\n    \n\n    df2.groupby(str.lower).mean()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\na\n1.5\n4.0\n\n\nb\n2.5\n3.5\n\n\nc\n3.5\n6.0\n\n\n\n\n\n    \n\n\n지금까지 다룬 모든 키 선택 방식은 다중 인덱스에서 그룹에 결합하여 사용할 수 있다.\n\ndf2.groupby([str.lower, mapping]).mean()\n\n\n  \n    \n\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\nkey\n\n\n\n\n\n\na\nvowel\n1.5\n4.0\n\n\nb\nconsonant\n2.5\n3.5\n\n\nc\nconsonant\n3.5\n6.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\ndecade = 10 * (planets['year'] // 10)\ndecade = decade.astype(str) + 's'\ndecade.name = 'decade'\nprint(decade)\nplanets.groupby(['method', decade])['number'].sum().unstack().fillna(0)\n\n0       2000s\n1       2000s\n2       2010s\n3       2000s\n4       2000s\n        ...  \n1030    2000s\n1031    2000s\n1032    2000s\n1033    2000s\n1034    2000s\nName: decade, Length: 1035, dtype: object\n\n\n\n  \n    \n\n\n\n\n\ndecade\n1980s\n1990s\n2000s\n2010s\n\n\nmethod\n\n\n\n\n\n\n\n\nAstrometry\n0.0\n0.0\n0.0\n2.0\n\n\nEclipse Timing Variations\n0.0\n0.0\n5.0\n10.0\n\n\nImaging\n0.0\n0.0\n29.0\n21.0\n\n\nMicrolensing\n0.0\n0.0\n12.0\n15.0\n\n\nOrbital Brightness Modulation\n0.0\n0.0\n0.0\n5.0\n\n\nPulsar Timing\n0.0\n9.0\n1.0\n1.0\n\n\nPulsation Timing Variations\n0.0\n0.0\n1.0\n0.0\n\n\nRadial Velocity\n1.0\n52.0\n475.0\n424.0\n\n\nTransit\n0.0\n0.0\n64.0\n712.0\n\n\nTransit Timing Variations\n0.0\n0.0\n0.0\n9.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n피벗 테이블은 입력값으로 간단한 열 단위의 데이터를 취하고 그 데이터에 대한 다차원 요약을 제공하는 2차원 테이블로 항목을 그룹핑한다. 피벗 테이블은 근본적으로 GroupBy 요약 통계량의 다차원 버전이다.\nGroupBy 요약 통계량의 다차원 버전\n\ntitanic = pd.read_csv('/content/titanic.csv')\n\n\ntitanic.head()\n\n\n  \n    \n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ntitanic['Survived'].mean()\n\n0.3838383838383838\n\n\n\ntitanic.groupby(['Sex', 'Pclass'])['Survived'].aggregate('mean').unstack()\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n\n\nmale\n0.368852\n0.157407\n0.135447\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\ntitanic.pivot_table('Survived', index='Sex', columns='Pclass')\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n\n\nmale\n0.368852\n0.157407\n0.135447\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n피벗 테이블의 그룹핑은 다단계로 여러 가지 옵션을 통해 지정할 수 있다.\n\nage = pd.cut(titanic['Age'], [0, 18, 80])\ntitanic.pivot_table('Survived', ['Sex', age], 'Pclass')\n\n\n  \n    \n\n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\nAge\n\n\n\n\n\n\n\nfemale\n(0, 18]\n0.909091\n1.000000\n0.511628\n\n\n(18, 80]\n0.972973\n0.900000\n0.423729\n\n\nmale\n(0, 18]\n0.800000\n0.600000\n0.215686\n\n\n(18, 80]\n0.375000\n0.071429\n0.133663\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\npd.qcut 분위수 계산:\n\nfare = pd.qcut(titanic['Fare'], 2)\ntitanic.pivot_table('Survived', ['Sex', age], [fare, 'Pclass'])\n\n\n  \n    \n\n\n\n\n\n\nFare\n(-0.001, 14.454]\n(14.454, 512.329]\n\n\n\nPclass\n1\n2\n3\n1\n2\n3\n\n\nSex\nAge\n\n\n\n\n\n\n\n\n\n\nfemale\n(0, 18]\nNaN\n1.000000\n0.714286\n0.909091\n1.000000\n0.318182\n\n\n(18, 80]\nNaN\n0.880000\n0.444444\n0.972973\n0.914286\n0.391304\n\n\nmale\n(0, 18]\nNaN\n0.000000\n0.260870\n0.800000\n0.818182\n0.178571\n\n\n(18, 80]\n0.0\n0.098039\n0.125000\n0.391304\n0.030303\n0.192308\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n# call signature as of Pandas 0.18\nDataFrame.pivot_table(data, values=None, index=None, columns=None,\n                      aggfunc='mean', fill_value=None, margins=False,\n                      dropna=True, margins_name='All')\n\ntitanic.pivot_table(index='Sex', columns='Pclass',\n                    aggfunc={'Survived':sum, 'Fare':'mean'})\n\n\n  \n    \n\n\n\n\n\n\nFare\nSurvived\n\n\nPclass\n1\n2\n3\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\n\n\n\nfemale\n106.125798\n21.970121\n16.118810\n91\n70\n72\n\n\nmale\n67.226127\n19.741782\n12.661633\n45\n17\n47\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nmargins = True키워드를 통해 그룹별 총합을 계산할 수 있다.\n\ntitanic.pivot_table('Survived', index='Sex', columns='Pclass', margins=True)\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\nAll\n\n\nSex\n\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n0.742038\n\n\nmale\n0.368852\n0.157407\n0.135447\n0.188908\n\n\nAll\n0.629630\n0.472826\n0.242363\n0.383838"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas-설치-및-사용",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas-설치-및-사용",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "!pip3 install pandas\n\nRequirement already satisfied: pandas in /usr/local/lib/python3.10/dist-packages (2.2.2)\nRequirement already satisfied: numpy&gt;=1.22.4 in /usr/local/lib/python3.10/dist-packages (from pandas) (1.26.4)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /usr/local/lib/python3.10/dist-packages (from pandas) (2.8.2)\nRequirement already satisfied: pytz&gt;=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas) (2024.2)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas) (2024.2)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&gt;=2.8.2-&gt;pandas) (1.16.0)\n\n\n\nimport numpy as np\nimport pandas as pd\nnp.__version__\npd.__version__\n\n'2.2.2'"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas-객체-소개",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas-객체-소개",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "세 가지 기본 자료구조인 Series, DataFrame, 그리고 Index를 소개한다.\n\n\nSeries객체는 일차원 자료를 다룰 때 사용된다.\n\n\nPython에서 Series를 객체를 생성하는 기본적인 방법은 다음과 같다.\n&gt;&gt;&gt; pd.Series(data, index=index)\n참고. index는 옵션으로 사용자가 지정하지 않으면 정수가 기본이다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0])\nprint(data)\n\n0    0.25\n1    0.50\n2    0.75\n3    1.00\ndtype: float64\n\n\n\ndata.values\n\narray([0.25, 0.5 , 0.75, 1.  ])\n\n\n\ndata.index\n\nRangeIndex(start=0, stop=4, step=1)\n\n\n\ndata.dtype\n\ndtype('float64')\n\n\nindex를 통해 자료에 접근할 수 있다.\n\ndata[1]\n\n0.5\n\n\n\nprint(data[1:3])\n\n1    0.50\n2    0.75\ndtype: float64\n\n\nindex를 사용자가 지정할 수 있다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=['a', 'b', 'c', 'd'])\nprint(data)\n\na    0.25\nb    0.50\nc    0.75\nd    1.00\ndtype: float64\n\n\n\ndata['b']\n\n0.5\n\n\n\ndata[['b','c']]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n연속적이지 않은 index를 사용할 수 있다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=[2, 5, 3, 7])\nprint(data)\n\n2    0.25\n5    0.50\n3    0.75\n7    1.00\ndtype: float64\n\n\n\ndata[2]\n\n0.25\n\n\nPandas의 Series는 딕셔너리의 특수한 버전으로 생각할 수 있다.\n\npopulation_dict = {'California': 38332521,\n                   'Texas': 26448193,\n                   'New York': 19651127,\n                   'Florida': 19552860,\n                   'Illinois': 12882135}\npopulation = pd.Series(population_dict)\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\n\n\n\npopulation['California']\n\n38332521\n\n\n딕셔너리와 달리 Series는 슬라이싱 같이 배열 스타일의 연산도 가능\n\nprint(population['California':'Illinois'])\nprint(population['California':'Texas'])\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\nCalifornia    38332521\nTexas         26448193\ndtype: int64\n\n\ndata는 같은 값을 지정할 수 있다.\n\na = pd.Series(5, index=[100, 200, 300])\nprint(a)\n\n100    5\n200    5\n300    5\ndtype: int64\n\n\nindex를 명시적으로 설정할 수 있다.\n\na = pd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2])\nprint(a)\n\n3    c\n2    a\ndtype: object\n\n\n\n\n\n\nDataFrame객체는 이차원 배열을 다룰 때 사용된다. 데이터 분석에서의 가장 기본적으로 사용되는 자료형태이다.\n\n\nPython에서 DataFrame 객체를 생성하는 기본적인 방법은 다음과 같다.\n&gt;&gt;&gt; DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)\n\n\n\npopulation_dict = {'California': 38332521,\n                   'Texas': 26448193,\n                   'New York': 19651127,\n                   'Florida': 19552860,\n                   'Illinois': 12882135}\npopulation = pd.Series(population_dict)\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\ndtype: int64\n\n\n\npop = pd.DataFrame(population, columns=['population'])\nprint(pop)\n\n            population\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nFlorida       19552860\nIllinois      12882135\n\n\n\npop.index\n# row.names\n\nIndex(['California', 'Texas', 'New York', 'Florida', 'Illinois'], dtype='object')\n\n\n\npop.columns\n\nIndex(['population'], dtype='object')\n\n\n\n\n\n\narea_dict = {'California': 423967, 'Texas': 695662, 'New York': 141297,\n             'Florida': 170312, 'Illinois': 149995}\narea = pd.Series(area_dict)\nprint(area)\n\nCalifornia    423967\nTexas         695662\nNew York      141297\nFlorida       170312\nIllinois      149995\ndtype: int64\n\n\n\nstates = pd.DataFrame({'population': population,\n                       'area': area})\nprint(states)\n\n            population    area\nCalifornia    38332521  423967\nTexas         26448193  695662\nNew York      19651127  141297\nFlorida       19552860  170312\nIllinois      12882135  149995\n\n\n\nstates.index\n\nIndex(['California', 'Texas', 'New York', 'Florida', 'Illinois'], dtype='object')\n\n\n\nstates.columns\n\nIndex(['population', 'area'], dtype='object')\n\n\nSeries에서는 data[0]는 첫 번째 행을 반환하고, DataFrame에서 data['col0']는 첫 번째 열을 반환한다.\n\na = states['area']\nprint(a)\n\nCalifornia    423967\nTexas         695662\nNew York      141297\nFlorida       170312\nIllinois      149995\nName: area, dtype: int64\n\n\n\n\n\n\ndata = [{'a': i, 'b': 2 * i} for i in range(3)]\ndata\n\n[{'a': 0, 'b': 0}, {'a': 1, 'b': 2}, {'a': 2, 'b': 4}]\n\n\n\na = pd.DataFrame(data)\nprint(a)\n\n   a  b\n0  0  0\n1  1  2\n2  2  4\n\n\nPandas에서는 딕셔너리의 일부 키가 생략되면 NaN(Not a number)를 채운다.\n\na = pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])\nprint(a)\n\n     a  b    c\n0  1.0  2  NaN\n1  NaN  3  4.0\n\n\n\n\n\n\ndata = np.random.rand(3, 2)\ndata\n\narray([[0.53463944, 0.82086275],\n       [0.12256724, 0.92698303],\n       [0.34134035, 0.40564263]])\n\n\n\na = pd.DataFrame(data,\n             columns=['foo', 'bar'],\n             index=['a', 'b', 'c'])\nprint(a)\n\n        foo       bar\na  0.534639  0.820863\nb  0.122567  0.926983\nc  0.341340  0.405643\n\n\n\n\n\n\n\n표 형식의 데이터 객체에서 각 행과 열에 대한 이름을 저장하는 객체이다.\n\nind = pd.Index([2, 3, 5, 7, 11])\nind\n\nIndex([2, 3, 5, 7, 11], dtype='int64')\n\n\n\n\n일반적인 방법으로 값을 변경할 수 없다.\n\nind[1]\n\n3\n\n\n\nind[::2]\n\nIndex([2, 5, 11], dtype='int64')\n\n\n\nprint(ind.size, ind.shape, ind.ndim, ind.dtype)\n\n5 (5,) 1 int64\n\n\n\nind[1] = 0\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-26-906a9fa1424c&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 ind[1] = 0\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in __setitem__(self, key, value)\n   5369     @final\n   5370     def __setitem__(self, key, value) -&gt; None:\n-&gt; 5371         raise TypeError(\"Index does not support mutable operations\")\n   5372 \n   5373     def __getitem__(self, key):\n\nTypeError: Index does not support mutable operations\n\n\n\n\n\n\n대체로 set데이터 구조에서 사용하는 표기법을 따른다.\n\nindA = pd.Index([1, 3, 5, 7, 9])\nindB = pd.Index([2, 3, 5, 7, 11])\n\nprint(indB)\n\nIndex([2, 3, 5, 7, 11], dtype='int64')\n\n\n\nprint(indA.intersection(indB))  # intersection\n\nIndex([3, 5, 7], dtype='int64')\n\n\n\nindA.union(indB)  # union\n\nIndex([1, 2, 3, 5, 7, 9, 11], dtype='int64')\n\n\n\nindA.difference(indB)  # symmetric difference\n\nIndex([1, 9], dtype='int64')"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#데이터-인덱싱과-선택",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#데이터-인덱싱과-선택",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "키의 집합을 값의 집합에 매핑한다.\n\ndata = pd.Series([0.25, 0.5, 0.75, 1.0],\n                 index=['a', 'b', 'c', 'd'])\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\nd\n1.00\n\n\n\n\ndtype: float64\n\n\n\ndata['b']\n\n0.5\n\n\n\n'a' in data\n\nTrue\n\n\n\ndata.keys()\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\n\nlist(data.items())\n\n[('a', 0.25), ('b', 0.5), ('c', 0.75), ('d', 1.0)]\n\n\n\ndata['e'] = 1.25\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\nd\n1.00\n\n\ne\n1.25\n\n\n\n\ndtype: float64\n\n\n\n\n\nSeries는 슬라이스, 마스킹, 팬시 인덱싱 등 NumPy배열과 똑같은 기본 메커니즘으로 배열 형태의 아이템을 선택할 수 있다.\n\n# slicing by explicit index\ndata['a':'c']\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n\n# slicing by implicit integer index\ndata[0:2]\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\nb\n0.50\n\n\n\n\ndtype: float64\n\n\n\n# masking\ndata[(data &gt; 0.3) & (data &lt; 0.8)]\n\n\n\n\n\n\n\n\n0\n\n\n\n\nb\n0.50\n\n\nc\n0.75\n\n\n\n\ndtype: float64\n\n\n\n# fancy indexing\ndata[['a', 'e']]\n\n\n\n\n\n\n\n\n0\n\n\n\n\na\n0.25\n\n\ne\n1.25\n\n\n\n\ndtype: float64\n\n\n\n\n\n인덱서를 이용하면 명확하게 해당 요소를 지정할 수 있다.\n\nimport pandas as pd\ndata = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])\ndata\n\n\n\n\n\n\n\n\n0\n\n\n\n\n1\na\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\n\n# explicit index when indexing\ndata[1]\n\n'a'\n\n\n\n# implicit index when slicing\ndata[1:3]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\nloc 사용:\n\ndata.loc[1]\n\n'a'\n\n\n\ndata.loc[1:5]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n1\na\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\niloc 사용: 암묵적인 Python스타일\n\ndata.iloc[1]\n\n'b'\n\n\n\ndata.iloc[1:3]\n\n\n\n\n\n\n\n\n0\n\n\n\n\n3\nb\n\n\n5\nc\n\n\n\n\ndtype: object\n\n\n\n\n\n\n\n\n\narea = pd.Series({'California': 423967, 'Texas': 695662,\n                  'New York': 141297, 'Florida': 170312,\n                  'Illinois': 149995})\npop = pd.Series({'California': 38332521, 'Texas': 26448193,\n                 'New York': 19651127, 'Florida': 19552860,\n                 'Illinois': 12882135})\ndata = pd.DataFrame({'area':area, 'pop':pop})\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\nFlorida\n170312\n19552860\n\n\nIllinois\n149995\n12882135\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\ndata['area']\n\n\n\n\n\n\n\n\narea\n\n\n\n\nCalifornia\n423967\n\n\nTexas\n695662\n\n\nNew York\n141297\n\n\nFlorida\n170312\n\n\nIllinois\n149995\n\n\n\n\ndtype: int64\n\n\n다음은 약식표현 방법을 자료를 선택하는 방법이다.\n\ndata.area\n\n\n\n\n\n\n\n\narea\n\n\n\n\nCalifornia\n423967\n\n\nTexas\n695662\n\n\nNew York\n141297\n\n\nFlorida\n170312\n\n\nIllinois\n149995\n\n\n\n\ndtype: int64\n\n\n\ndata.area\ndata.area is data['area']\n\nTrue\n\n\n주의. 약식표현이 항상 가능하지는 않다. 즉, DataFrame는 pop()메서드를 가지고 있다.\n\nprint(data.pop)\ndata.pop is data['pop']\n\n&lt;bound method DataFrame.pop of               area       pop\nCalifornia  423967  38332521\nTexas       695662  26448193\nNew York    141297  19651127\nFlorida     170312  19552860\nIllinois    149995  12882135&gt;\n\n\nFalse\n\n\n새로운 변수명과 해당 변수에 대한 자료 입력을 통해 객체를 추가할 수 있다.\n\ndata['density'] = data['pop'] / data['area']\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nCalifornia\n423967\n38332521\n90.413926\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n\n\ndata.values\n\narray([[4.23967000e+05, 3.83325210e+07, 9.04139261e+01],\n       [6.95662000e+05, 2.64481930e+07, 3.80187404e+01],\n       [1.41297000e+05, 1.96511270e+07, 1.39076746e+02],\n       [1.70312000e+05, 1.95528600e+07, 1.14806121e+02],\n       [1.49995000e+05, 1.28821350e+07, 8.58837628e+01]])\n\n\n\ndata.T   # Transpose\n\n\n  \n    \n\n\n\n\n\n\nCalifornia\nTexas\nNew York\nFlorida\nIllinois\n\n\n\n\narea\n4.239670e+05\n6.956620e+05\n1.412970e+05\n1.703120e+05\n1.499950e+05\n\n\npop\n3.833252e+07\n2.644819e+07\n1.965113e+07\n1.955286e+07\n1.288214e+07\n\n\ndensity\n9.041393e+01\n3.801874e+01\n1.390767e+02\n1.148061e+02\n8.588376e+01\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\n\n\n\ndata.values[0]\n\narray([4.23967000e+05, 3.83325210e+07, 9.04139261e+01])\n\n\n\ndata.iloc[:3, :2]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.loc[:'Illinois', :'pop']\n\n\n  \n    \n\n\n\n\n\n\narea\npop\n\n\n\n\nCalifornia\n423967\n38332521\n\n\nTexas\n695662\n26448193\n\n\nNew York\n141297\n19651127\n\n\nFlorida\n170312\n19552860\n\n\nIllinois\n149995\n12882135\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.loc[data.density &gt; 100, ['pop', 'density']]\n\n\n  \n    \n\n\n\n\n\n\npop\ndensity\n\n\n\n\nNew York\n19651127\n139.076746\n\n\nFlorida\n19552860\n114.806121\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata.iloc[0, 2] = 90\ndata\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nCalifornia\n423967\n38332521\n90.000000\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n\n인덱싱은 열을 참조하고, 슬라이싱은 행을 참조한다.\n\ndata['Florida':'Illinois']\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nFlorida\n170312\n19552860\n114.806121\n\n\nIllinois\n149995\n12882135\n85.883763\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\ndata[1:3]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nTexas\n695662\n26448193\n38.018740\n\n\nNew York\n141297\n19651127\n139.076746\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n마스킹 연산은 행 단위로 해석된다.\n\ndata[data.density &gt; 100]\n\n\n  \n    \n\n\n\n\n\n\narea\npop\ndensity\n\n\n\n\nNew York\n141297\n19651127\n139.076746\n\n\nFlorida\n170312\n19552860\n114.806121"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas에서의-연산",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pandas에서의-연산",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "부정 함수와 삼각함수 같은 단항 연산의 경우에는 유니버설 함수가 결과물에 인덱스와 열 레이블을 보존하고, 덧셈과 곱셈 같은 이항 연산의 경우에는 유니버설 함수에 객체를 전달할 때 자동으로 인덱스를 정렬한다.\n\n\n단항 연산은 인덱스를 보존한다.\n\n\n\n\nimport numpy as np\nrng = np.random.RandomState(42)\nser = pd.Series(rng.randint(0, 10, 4))\nser\n\n0    6\n1    3\n2    7\n3    4\ndtype: int64\n\n\n\nnp.exp(ser)\n\n0     403.428793\n1      20.085537\n2    1096.633158\n3      54.598150\ndtype: float64\n\n\n\n\n\n\ndf = pd.DataFrame(rng.randint(0, 10, (3, 4)),\n                  columns=['A', 'B', 'C', 'D'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n6\n9\n2\n6\n\n\n1\n7\n4\n3\n7\n\n\n2\n7\n2\n5\n4\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nnp.sin(df * np.pi / 4)\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n-1.000000\n7.071068e-01\n1.000000\n-1.000000e+00\n\n\n1\n-0.707107\n1.224647e-16\n0.707107\n-7.071068e-01\n\n\n2\n-0.707107\n1.000000e+00\n-0.707107\n1.224647e-16\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n이항 연산을 적용하는 경우 인덱스를 정렬한다.\n\n\n\n\narea = pd.Series({'Alaska': 1723337, 'Texas': 695662,\n                  'California': 423967}, name='area')\npopulation = pd.Series({'California': 38332521, 'Texas': 26448193,\n                        'New York': 19651127}, name='population')\n\n\nprint(area)\n\nAlaska        1723337\nTexas          695662\nCalifornia     423967\nName: area, dtype: int64\n\n\n\nprint(population)\n\nCalifornia    38332521\nTexas         26448193\nNew York      19651127\nName: population, dtype: int64\n\n\n\npopulation / area\n\nAlaska              NaN\nCalifornia    90.413926\nNew York            NaN\nTexas         38.018740\ndtype: float64\n\n\n누락된 값을 다른 값으로 채워 계산할 수 있다.\n\npopulation.div(area, fill_value=1)\n# population / area (fill--)\n\nAlaska        5.802696e-07\nCalifornia    9.041393e+01\nNew York      1.965113e+07\nTexas         3.801874e+01\ndtype: float64\n\n\n\nA = pd.Series([2, 4, 6], index=[0, 1, 2])\nB = pd.Series([1, 3, 5], index=[1, 2, 3])\nA + B\n# Index에 주의해서 합쳐야 함\n\n0    NaN\n1    5.0\n2    9.0\n3    NaN\ndtype: float64\n\n\n\nA.add(B, fill_value=0)\n\n0    2.0\n1    5.0\n2    9.0\n3    5.0\ndtype: float64\n\n\n\n\n\n\nA = pd.DataFrame(rng.randint(0, 20, (2, 2)),\n                 columns=list('AB'))\nA\n\n\n  \n    \n\n\n\n\n\n\nA\nB\n\n\n\n\n0\n6\n11\n\n\n1\n7\n14\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nB = pd.DataFrame(rng.randint(0, 10, (3, 3)),\n                 columns=list('BAC'))\nB\n\n\n  \n    \n\n\n\n\n\n\nB\nA\nC\n\n\n\n\n0\n2\n0\n3\n\n\n1\n1\n7\n3\n\n\n2\n1\n5\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nA + B\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n6.0\n13.0\nNaN\n\n\n1\n14.0\n15.0\nNaN\n\n\n2\nNaN\nNaN\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nSeries와 같이 누락된 값을 채워넣을 수 있다.\n\nfill = A.stack().mean()\nfill\n\n9.5\n\n\n\nA.add(B, fill_value=fill)\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n6.0\n13.0\n12.5\n\n\n1\n14.0\n15.0\n12.5\n\n\n2\n14.5\n10.5\n14.5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n다음은 Python 연산자와 대응되는 Pandas 메소드이다.\n\n\n\nPython Operator\nPandas Method(s)\n\n\n\n\n+\nadd()\n\n\n-\nsub(), subtract()\n\n\n*\nmul(), multiply()\n\n\n/\ntruediv(), div(), divide()\n\n\n//\nfloordiv()\n\n\n%\nmod()\n\n\n**\npow()\n\n\n\n\n\n\nDataFrame과 Series 사이에서 연산할 때 인덱스와 열의 순서는 비슷하게 유지된다. DataFrame과 Series 사이의 연산은 2차원 NumPy배열과 1차원 NumPy배열 사이의 연산과 비슷하다.\n\n\n\nrng = np.random.RandomState(42)\n\nA = rng.randint(10, size=(3, 4))\nA\n\narray([[6, 3, 7, 4],\n       [6, 9, 2, 6],\n       [7, 4, 3, 7]])\n\n\n\nA[0]\n\narray([6, 3, 7, 4])\n\n\n\nA - A[0]\n\narray([[ 0,  0,  0,  0],\n       [ 0,  6, -5,  2],\n       [ 1,  1, -4,  3]])\n\n\n\n\n\nPandas에서도 연산 규칙이 기본적으로 행 방향으로 적용된다.\n\ndf = pd.DataFrame(A, columns=list('QRST'))\ndf\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n6\n3\n7\n4\n\n\n1\n6\n9\n2\n6\n\n\n2\n7\n4\n3\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.iloc[0]\n\nQ    6\nR    3\nS    7\nT    4\nName: 0, dtype: int64\n\n\n\ndf - df.iloc[0]\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n0\n0\n0\n0\n\n\n1\n0\n6\n-5\n2\n\n\n2\n1\n1\n-4\n3\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\naxis = 0을 지정하면 열 방향으로 연산이 가능한다.\n\nprint(df)\ndf.subtract(df['R'], axis=0)\n\n   Q  R  S  T\n0  6  3  7  4\n1  6  9  2  6\n2  7  4  3  7\n\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n3\n0\n4\n1\n\n\n1\n-3\n0\n-7\n-3\n\n\n2\n3\n0\n-1\n3\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nDataFrame/Series 연산\n\nhalfrow = df.iloc[0, ::2]\nhalfrow\n\nQ    6\nS    7\nName: 0, dtype: int64\n\n\n\ndf\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n6\n3\n7\n4\n\n\n1\n6\n9\n2\n6\n\n\n2\n7\n4\n3\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf - halfrow\n# 객체에 이름이 있다는 것에 주의\n\n\n  \n    \n\n\n\n\n\n\nQ\nR\nS\nT\n\n\n\n\n0\n0.0\nNaN\n0.0\nNaN\n\n\n1\n0.0\nNaN\n-5.0\nNaN\n\n\n2\n1.0\nNaN\n-4.0\nNaN"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#결측치-처리",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#결측치-처리",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "Pandas에서는 결측치를 NaN값과 Python의 None로 나타낸다.\n\n\nNone는 데이터 타입이 dtype=object(객체의 배열)에서만 사용가능하다.\n\nvals1 = np.array([1, None, 3, 4])\nvals1\n\narray([1, None, 3, 4], dtype=object)\n\n\n객체 배열의 연산은 기본 데이터 타입의 연산보다 많은 오버헤드가 발생한다.\n\nfor dtype in ['object', 'int']:\n    print(\"dtype =\", dtype)\n    %timeit np.arange(1E6, dtype=dtype).sum()\n    print()\n\ndtype = object\n44 ms ± 7.75 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\ndtype = int\n489 µs ± 9.86 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\n\n\nNone값을 가진 배열에서 sum과 같은 연산을 하면 일반적으로 오류가 발생한다.\n\nvals1.sum()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-86-30a3fc8c6726&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 vals1.sum()\n\n/usr/local/lib/python3.10/dist-packages/numpy/core/_methods.py in _sum(a, axis, dtype, out, keepdims, initial, where)\n     46 def _sum(a, axis=None, dtype=None, out=None, keepdims=False,\n     47          initial=_NoValue, where=True):\n---&gt; 48     return umr_sum(a, axis, dtype, out, keepdims, initial, where)\n     49 \n     50 def _prod(a, axis=None, dtype=None, out=None, keepdims=False,\n\nTypeError: unsupported operand type(s) for +: 'int' and 'NoneType'\n\n\n\n\n\n\nNaN(Not a Number)는 표준 IEEE부동 소수점 표기를 사용하는 모든 시스템이 인식하는 특수 부동 소수점 값이다.\n\nvals2 = np.array([1, np.nan, 3, 4])\nvals2.dtype\n\ndtype('float64')\n\n\n결측치가 있는 자료의 연산에 대한 결과는 NaN이다.\n\n1 + np.nan\n\nnan\n\n\n\n0 *  np.nan\n\nnan\n\n\n\nprint(vals2)\nvals2.sum(), vals2.min(), vals2.max()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n&lt;ipython-input-1-50f8d8a9f026&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 print(vals2)\n      2 vals2.sum(), vals2.min(), vals2.max()\n\nNameError: name 'vals2' is not defined\n\n\n\nNaN을 생략하고 연산할 수 있는 함수가 있다.\n\nnp.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)\n\n\n\n\nNaN과 None를 호환성 있게 처리하고 적절한 경우에는 서로 변환할 수 있다.\n\npd.Series([1, np.nan, 2, None])\n\n0    1.0\n1    NaN\n2    2.0\n3    NaN\ndtype: float64\n\n\n\nx = pd.Series(range(2), dtype=int)\nx\n\n0    0\n1    1\ndtype: int64\n\n\n\nx[0] = None\nx\n\n0    NaN\n1    1.0\ndtype: float64"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#null값에-대한-연산",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#null값에-대한-연산",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "data = pd.Series([1, np.nan, 'hello', None])\ndata\n\n0        1\n1      NaN\n2    hello\n3     None\ndtype: object\n\n\n\ndata.isnull()\n\n0    False\n1     True\n2    False\n3     True\ndtype: bool\n\n\n\ndata[data.notnull()]\n\n0        1\n2    hello\ndtype: object\n\n\n\n\n\n\n\n\ndata = pd.Series([1, np.nan, 'hello', None])\ndata\n\n0        1\n1      NaN\n2    hello\n3     None\ndtype: object\n\n\n\ndata.dropna()\n\n0        1\n2    hello\ndtype: object\n\n\n\n\n\n\ndf = pd.DataFrame([[1,      np.nan, 2],\n                   [2,      3,      5],\n                   [np.nan, 4,      6]])\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\nNaN\n2\n\n\n1\n2.0\n3.0\n5\n\n\n2\nNaN\n4.0\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n기본 메소드는 널 값을 가진 행을 삭제한다.\n\ndf.dropna()\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n1\n2.0\n3.0\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n축 지정을 통해 널 값이 있는 열을 삭제할 수 있다.\n\ndf.dropna(axis='columns')\n\n\n  \n    \n\n\n\n\n\n\n2\n\n\n\n\n0\n2\n\n\n1\n5\n\n\n2\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nhow = 'any'를 사용하여 널 값을 포함하는 열 혹은 행을 모두 삭제하거나, how = 'all'을 사용하여 모두 널 값인 행 혹은 열을 삭제할 수 있다.\n\ndf[3] = np.nan\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n1.0\nNaN\n2\nNaN\n\n\n1\n2.0\n3.0\n5\nNaN\n\n\n2\nNaN\n4.0\n6\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.dropna(axis='columns', how='any')\n\n\n  \n    \n\n\n\n\n\n\n2\n\n\n\n\n0\n2\n\n\n1\n5\n\n\n2\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nnon-null의 개수를 지정할 수 있다.\n\ndf.dropna(axis='rows', thresh=3)\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n1\n2.0\n3.0\n5\nNaN\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n\n\n\n\n널 값(결측치)를 다른 값으로 채울 수 있다.\n\n\n\ndata = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))\ndata\n\na    1.0\nb    NaN\nc    2.0\nd    NaN\ne    3.0\ndtype: float64\n\n\n0으로 채운다.\n\ndata.fillna(-1)\n\na    1.0\nb   -1.0\nc    2.0\nd   -1.0\ne    3.0\ndtype: float64\n\n\n앞 혹은 뒤의 값을 이용하여 널 값을 채울 수 있다.\n\n# forward-fill (전의 값))\ndata.fillna(method='ffill')\n\na    1.0\nb    1.0\nc    2.0\nd    2.0\ne    3.0\ndtype: float64\n\n\n\n# back-fill (후의 값))\ndata.fillna(method='bfill')\n\na    1.0\nb    2.0\nc    2.0\nd    3.0\ne    3.0\ndtype: float64\n\n\n\n\n\n\ndf = pd.DataFrame([[1,      np.nan, 2],\n                   [2,      3,      5],\n                   [np.nan, 4,      6]])\ndf\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\nNaN\n2\n\n\n1\n2.0\n3.0\n5\n\n\n2\nNaN\n4.0\n6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.fillna(method='ffill', axis=1)\n\n\n  \n    \n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n1.0\n1.0\n2.0\n\n\n1\n2.0\n3.0\n5.0\n\n\n2\nNaN\n4.0\n6.0"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#계층적-인덱싱",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#계층적-인덱싱",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "Pandas에서는 계층적 인덱싱을 통해 고차원의 데이터를 효율적으로 표현할 수 있다.\n\n\n튜플로부터 다중 인덱스를 생성할 수 있다.\n\nindex = [('California', 2000), ('California', 2010),\n         ('New York', 2000), ('New York', 2010),\n         ('Texas', 2000), ('Texas', 2010)]\npopulations = [33871648, 37253956,\n               18976457, 19378102,\n               20851820, 25145561]\npop = pd.Series(populations, index=index)\npop\n\n(California, 2000)    33871648\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\n(Texas, 2010)         25145561\ndtype: int64\n\n\n\nindex = pd.MultiIndex.from_tuples(index)\nindex\n\nMultiIndex([('California', 2000),\n            ('California', 2010),\n            (  'New York', 2000),\n            (  'New York', 2010),\n            (     'Texas', 2000),\n            (     'Texas', 2010)],\n           )\n\n\n\npop = pop.reindex(index)\npop\n\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\nunstack()와 stack()는 차원을 변경해 준다:\n\npop_df = pop.unstack()\npop_df\n\n\n  \n    \n\n\n\n\n\n\n2000\n2010\n\n\n\n\nCalifornia\n33871648\n37253956\n\n\nNew York\n18976457\n19378102\n\n\nTexas\n20851820\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop_df.stack()\n\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\nMultiIndex를 이용하면 쉽게 자료를 추가할 수 있다.\n\npop_df = pd.DataFrame({'total': pop,\n                       'under18': [9267089, 9284094,\n                                   4687374, 4318033,\n                                   5906301, 6879014]})\npop_df\n\n\n  \n    \n\n\n\n\n\n\n\ntotal\nunder18\n\n\n\n\nCalifornia\n2000\n33871648\n9267089\n\n\n2010\n37253956\n9284094\n\n\nNew York\n2000\n18976457\n4687374\n\n\n2010\n19378102\n4318033\n\n\nTexas\n2000\n20851820\n5906301\n\n\n2010\n25145561\n6879014\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n유니버설 함수도 MultiIndex와 잘 동작한다.\n\n항목 추가\n항목 추가\n\n\nf_u18 = pop_df['under18'] / pop_df['total']\nf_u18.unstack()\n\n\n  \n    \n\n\n\n\n\n\n2000\n2010\n\n\n\n\nCalifornia\n0.273594\n0.249211\n\n\nNew York\n0.247010\n0.222831\n\n\nTexas\n0.283251\n0.273568\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n다중 인덱스를 가진 Series나 DataFrame을 생성하는 가장 간단한 방식은 생성자에 2개 이상의 인덱스 배열 리스트를 전달하는 것이다.\n\ndf = pd.DataFrame(np.random.rand(4, 2),\n                  index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],\n                  columns=['data1', 'data2'])\ndf\n\n\n  \n    \n      \n\n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\na\n1\n0.792886\n0.009770\n\n\n2\n0.714824\n0.091079\n\n\nb\n1\n0.376271\n0.078637\n\n\n2\n0.066049\n0.996906\n\n\n\n\n\n      \n        \n  \n    \n    \n  \n      \n      \n  \n\n      \n    \n  \n  \n\n\n\ndata = {('California', 2000): 33871648,\n        ('California', 2010): 37253956,\n        ('Texas', 2000): 20851820,\n        ('Texas', 2010): 25145561,\n        ('New York', 2000): 18976457,\n        ('New York', 2010): 19378102}\npd.Series(data)\n\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\n\n\nMultiIndex의 클래스 메서드 생성자를 사용해 더 유연하게 인덱스를 생성할 수 있다.\n\npd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], [1, 2, 1, 2]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\npd.MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b', 2)])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\n# Cartesian product\npd.MultiIndex.from_product([['a', 'b'], [1, 2]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\npd.MultiIndex(levels=[['a', 'b'], [1, 2]],\n              codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n\nMultiIndex([('a', 1),\n            ('a', 2),\n            ('b', 1),\n            ('b', 2)],\n           )\n\n\n\n\n\nMultiIndex의 레벨에 이름을 지정할 수 있다.\n\npop.index.names = ['state', 'year']\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n열도 여러 레벨을 가질 수 있다.\n\n# mock some data\ndata = np.round(np.random.randn(4, 6), 1)\ndata[:, ::2] *= 10\ndata += 37\ndata\n\narray([[51. , 37. , 48. , 34.6, 59. , 35.7],\n       [32. , 36.5, 41. , 37.2, 43. , 38.2],\n       [30. , 36.9, 34. , 35.3, 21. , 37.2],\n       [37. , 37.3, 16. , 34.1, 29. , 40. ]])\n\n\n\n# hierarchical indices and columns\nindex = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],\n                                   names=['year', 'visit'])\ncolumns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],\n                                     names=['subject', 'type'])\n\n\nindex\n\nMultiIndex([(2013, 1),\n            (2013, 2),\n            (2014, 1),\n            (2014, 2)],\n           names=['year', 'visit'])\n\n\n\ncolumns\n\nMultiIndex([(  'Bob',   'HR'),\n            (  'Bob', 'Temp'),\n            ('Guido',   'HR'),\n            ('Guido', 'Temp'),\n            (  'Sue',   'HR'),\n            (  'Sue', 'Temp')],\n           names=['subject', 'type'])\n\n\n\n# create the DataFrame\nhealth_data = pd.DataFrame(data, index=index, columns=columns)\nhealth_data\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nTemp\nHR\nTemp\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n\n\n\n\n2013\n1\n51.0\n37.0\n48.0\n34.6\n59.0\n35.7\n\n\n2\n32.0\n36.5\n41.0\n37.2\n43.0\n38.2\n\n\n2014\n1\n30.0\n36.9\n34.0\n35.3\n21.0\n37.2\n\n\n2\n37.0\n37.3\n16.0\n34.1\n29.0\n40.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\n\nindex = [('California', 2000), ('California', 2010),\n         ('New York', 2000), ('New York', 2010),\n         ('Texas', 2000), ('Texas', 2010)]\npopulations = [33871648, 37253956,\n               18976457, 19378102,\n               20851820, 25145561]\npop = pd.Series(populations, index=index)\npop\n\n(California, 2000)    33871648\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\n(Texas, 2010)         25145561\ndtype: int64\n\n\n\npop[('California', 2010):('Texas', 2000)]\n\n(California, 2010)    37253956\n(New York, 2000)      18976457\n(New York, 2010)      19378102\n(Texas, 2000)         20851820\ndtype: int64\n\n\n다중 인덱스\n\ndata = {('California', 2000): 33871648,\n        ('California', 2010): 37253956,\n        ('Texas', 2000): 20851820,\n        ('Texas', 2010): 25145561,\n        ('New York', 2000): 18976457,\n        ('New York', 2010): 19378102}\npop = pd.Series(data)\npop.index.names = ['state', 'year']\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\npop['California', 2000]\n\n33871648\n\n\n\npop['California']\n\nyear\n2000    33871648\n2010    37253956\ndtype: int64\n\n\n\npop[:, 2000]\n\nstate\nCalifornia    33871648\nTexas         20851820\nNew York      18976457\ndtype: int64\n\n\n\npop[pop &gt; 22000000]\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2010    25145561\ndtype: int64\n\n\n\npop[['California', 'Texas']]\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n\n# hierarchical indices and columns\nindex = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],\n                                   names=['year', 'visit'])\ncolumns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],\n                                     names=['subject', 'type'])\n\n# mock some data\ndata = np.round(np.random.randn(4, 6), 1)\ndata[:, ::2] *= 10\ndata += 37\n\n# create the DataFrame\nhealth_data = pd.DataFrame(data, index=index, columns=columns)\nhealth_data\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nTemp\nHR\nTemp\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n\n\n\n\n2013\n1\n32.0\n37.0\n36.0\n37.2\n31.0\n38.3\n\n\n2\n30.0\n37.6\n34.0\n38.8\n34.0\n38.1\n\n\n2014\n1\n52.0\n38.6\n18.0\n37.1\n37.0\n38.6\n\n\n2\n46.0\n34.7\n30.0\n38.6\n40.0\n35.9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data['Guido']\n\n\n  \n    \n\n\n\n\n\n\ntype\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n2013\n1\n36.0\n37.2\n\n\n2\n34.0\n38.8\n\n\n2014\n1\n18.0\n37.1\n\n\n2\n30.0\n38.6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data['Guido', 'HR']\n\nyear  visit\n2013  1        36.0\n      2        34.0\n2014  1        18.0\n      2        30.0\nName: (Guido, HR), dtype: float64\n\n\n\nhealth_data.iloc[:2, :2]\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\n\n\n\ntype\nHR\nTemp\n\n\nyear\nvisit\n\n\n\n\n\n\n2013\n1\n32.0\n37.0\n\n\n2\n30.0\n37.6\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nhealth_data.loc[:, ('Bob', 'HR')]\n\nyear  visit\n2013  1        32.0\n      2        30.0\n2014  1        52.0\n      2        46.0\nName: (Bob, HR), dtype: float64\n\n\n주의. 튜플 내에 슬라이스는 작동하지 않는다.\n\nhealth_data.loc[(:, 1), (:, 'HR')]\n\n\n  File \"&lt;ipython-input-70-fb34fa30ac09&gt;\", line 1\n    health_data.loc[(:, 1), (:, 'HR')]\n                     ^\nSyntaxError: invalid syntax\n\n\n\n\n주의. IndexSlice 객체를 이용하면 쉽게 해결할 수 있다.\n\nidx = pd.IndexSlice\nhealth_data.loc[idx[:, 1], idx[:, 'HR']]\n\n\n  \n    \n\n\n\n\n\n\nsubject\nBob\nGuido\nSue\n\n\n\ntype\nHR\nHR\nHR\n\n\nyear\nvisit\n\n\n\n\n\n\n\n2013\n1\n32.0\n36.0\n31.0\n\n\n2014\n1\n52.0\n18.0\n37.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\n\n대부분의 MultiIndex 슬라이싱 연산은 인덱스가 정렬돼 있지 않으면 실패한다.\n\nindex = pd.MultiIndex.from_product([['a', 'c', 'b'], [1, 2]])\ndata = pd.Series(np.random.rand(6), index=index)\ndata.index.names = ['char', 'int']\ndata\n\nchar  int\na     1      0.856959\n      2      0.626968\nc     1      0.080189\n      2      0.855903\nb     1      0.033432\n      2      0.851495\ndtype: float64\n\n\n\ndata['a':'b']\n\n\n---------------------------------------------------------------------------\nUnsortedIndexError                        Traceback (most recent call last)\n&lt;ipython-input-74-0e6568674d17&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 data['a':'b']\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/series.py in __getitem__(self, key)\n   1005             return self._get_values(key)\n   1006 \n-&gt; 1007         return self._get_with(key)\n   1008 \n   1009     def _get_with(self, key):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/series.py in _get_with(self, key)\n   1012             # _convert_slice_indexer to determine if this slice is positional\n   1013             #  or label based, and if the latter, convert to positional\n-&gt; 1014             slobj = self.index._convert_slice_indexer(key, kind=\"getitem\")\n   1015             return self._slice(slobj)\n   1016         elif isinstance(key, ABCDataFrame):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in _convert_slice_indexer(self, key, kind)\n   4282             indexer = key\n   4283         else:\n-&gt; 4284             indexer = self.slice_indexer(start, stop, step)\n   4285 \n   4286         return indexer\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in slice_indexer(self, start, end, step, kind)\n   6557         self._deprecated_arg(kind, \"kind\", \"slice_indexer\")\n   6558 \n-&gt; 6559         start_slice, end_slice = self.slice_locs(start, end, step=step)\n   6560 \n   6561         # return a slice\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in slice_locs(self, start, end, step, kind)\n   2773         # This function adds nothing to its parent implementation (the magic\n   2774         # happens in get_slice_bound method), but it adds meaningful doc.\n-&gt; 2775         return super().slice_locs(start, end, step)\n   2776 \n   2777     def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/base.py in slice_locs(self, start, end, step, kind)\n   6765         start_slice = None\n   6766         if start is not None:\n-&gt; 6767             start_slice = self.get_slice_bound(start, \"left\")\n   6768         if start_slice is None:\n   6769             start_slice = 0\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in get_slice_bound(self, label, side, kind)\n   2712         if not isinstance(label, tuple):\n   2713             label = (label,)\n-&gt; 2714         return self._partial_tup_index(label, side=side)\n   2715 \n   2716     def slice_locs(\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/indexes/multi.py in _partial_tup_index(self, tup, side)\n   2777     def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n   2778         if len(tup) &gt; self._lexsort_depth:\n-&gt; 2779             raise UnsortedIndexError(\n   2780                 f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n   2781                 f\"({self._lexsort_depth})\"\n\nUnsortedIndexError: 'Key length (1) was greater than MultiIndex lexsort depth (0)'\n\n\n\n\n#try:\n#    data['a':'b']\n#except KeyError as e:\n#    print(type(e))\n#    print(e)\n\n&lt;class 'pandas.errors.UnsortedIndexError'&gt;\n'Key length (1) was greater than MultiIndex lexsort depth (0)'\n\n\n\n\n\n\ndata = data.sort_index()\ndata\n\nchar  int\na     1      0.856959\n      2      0.626968\nb     1      0.033432\n      2      0.851495\nc     1      0.080189\n      2      0.855903\ndtype: float64\n\n\n\ndata['a':'b']\n\nchar  int\na     1      0.856959\n      2      0.626968\nb     1      0.033432\n      2      0.851495\ndtype: float64\n\n\n\n\n\n\n다중 인덱스에서 간단한 2차원 표현으로 변경할 수 있다.\n\npop\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nTexas       2000    20851820\n            2010    25145561\nNew York    2000    18976457\n            2010    19378102\ndtype: int64\n\n\n\npop.unstack(level=0)\n\n\n  \n    \n\n\n\n\n\nstate\nCalifornia\nNew York\nTexas\n\n\nyear\n\n\n\n\n\n\n\n2000\n33871648\n18976457\n20851820\n\n\n2010\n37253956\n19378102\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop.unstack(level=1)\n\n\n  \n    \n\n\n\n\n\nyear\n2000\n2010\n\n\nstate\n\n\n\n\n\n\nCalifornia\n33871648\n37253956\n\n\nNew York\n18976457\n19378102\n\n\nTexas\n20851820\n25145561\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\npop.unstack().stack()\n\nstate       year\nCalifornia  2000    33871648\n            2010    37253956\nNew York    2000    18976457\n            2010    19378102\nTexas       2000    20851820\n            2010    25145561\ndtype: int64\n\n\n\n\n\n계층적 데이터를 재정렬하는 또 다른 방법은 인덱스 레이블을 열로 바꾸는 것이다.\n\npop_flat = pop.reset_index(name='population')\npop_flat\n\n\n  \n    \n\n\n\n\n\n\nstate\nyear\npopulation\n\n\n\n\n0\nCalifornia\n2000\n33871648\n\n\n1\nCalifornia\n2010\n37253956\n\n\n2\nTexas\n2000\n20851820\n\n\n3\nTexas\n2010\n25145561\n\n\n4\nNew York\n2000\n18976457\n\n\n5\nNew York\n2010\n19378102\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n열 값을 이용해서 MultiIndex를 만들 수 있다.\n\npop_flat.set_index(['state', 'year'])\n\n\n  \n    \n\n\n\n\n\n\n\npopulation\n\n\nstate\nyear\n\n\n\n\n\nCalifornia\n2000\n33871648\n\n\n2010\n37253956\n\n\nTexas\n2000\n20851820\n\n\n2010\n25145561\n\n\nNew York\n2000\n18976457\n\n\n2010\n19378102"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#데이터세트-결합",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#데이터세트-결합",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "Pandas에서는 서로 다른 데이터 소스를 결합하는 함수와 메소드를 제공한다.\n\ndef make_df(cols, ind):\n    \"\"\"Quickly make a DataFrame\"\"\"\n    data = {c: [str(c) + str(i) for i in ind]\n            for c in cols}\n    return pd.DataFrame(data, ind)\n\n# example DataFrame\nmake_df('ABC', range(3))\n\n\n  \n    \n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\nA0\nB0\nC0\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n#class display(object):\n#    \"\"\"Display HTML representation of multiple objects\"\"\"\n#    template = \"\"\"&lt;div style=\"float: left; padding: 10px;\"&gt;\n#    &lt;p style='font-family:\"Courier New\", Courier, monospace'&gt;{0}&lt;/p&gt;{1}\n#    &lt;/div&gt;\"\"\"\n#    def __init__(self, *args):\n#        self.args = args\n\n#    def _repr_html_(self):\n#        return '\\n'.join(self.template.format(a, eval(a)._repr_html_())\n#                         for a in self.args)\n\n#    def __repr__(self):\n#        return '\\n\\n'.join(a + '\\n' + repr(eval(a))\n#                           for a in self.args)"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pd.concat",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#pd.concat",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "# Signature in Pandas v0.18\npd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,\n          keys=None, levels=None, names=None, verify_integrity=False,\n          copy=True)\n\nser1 = pd.Series(['A', 'B', 'C'], index=[1, 2, 3])\nser2 = pd.Series(['D', 'E', 'F'], index=[4, 5, 6])\npd.concat([ser1, ser2])\n\n1    A\n2    B\n3    C\n4    D\n5    E\n6    F\ndtype: object\n\n\n\ndf1 = make_df('AB', [1, 2])\ndf2 = make_df('AB', [3, 4])\ndisplay('df1', 'df2', \"pd.concat([df1, df2])\")\n\n\n    df1\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nA\nB\n\n\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n    pd.concat([df1, df2])\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n\n\ndf3 = make_df('AB', [0, 1])\ndf4 = make_df('CD', [0, 1])\ndisplay('df3', 'df4', \"pd.concat([df3, df4], axis=1,sort=True)\")\n\n\n    df3\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    df4\n\n\n\n\n\n\nC\nD\n\n\n\n\n0\nC0\nD0\n\n\n1\nC1\nD1\n\n\n\n\n\n    \n\n    pd.concat([df3, df4], axis=1,sort=True)\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\nA0\nB0\nC0\nD0\n\n\n1\nA1\nB1\nC1\nD1\n\n\n\n\n\n    \n\n\n\n\nPandas의 concat경우 복제된 인덱스를 가지더라도 인덱스를 유지한다.\n\nx = make_df('AB', [0, 1])\ny = make_df('AB', [2, 3])\ny.index = x.index  # make duplicate indices!\ndisplay('x', 'y', 'pd.concat([x, y])')\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y])\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\ndisplay('x', 'y', 'pd.concat([x, y], ignore_index=True)')\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y], ignore_index=True)\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\n\ndisplay('x', 'y', \"pd.concat([x, y], keys=['x', 'y'])\")\n\n\n    x\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\n\n\n\n    \n\n    y\n\n\n\n\n\n\nA\nB\n\n\n\n\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n    pd.concat([x, y], keys=['x', 'y'])\n\n\n\n\n\n\n\nA\nB\n\n\n\n\nx\n0\nA0\nB0\n\n\n1\nA1\nB1\n\n\ny\n0\nA2\nB2\n\n\n1\nA3\nB3\n\n\n\n\n\n    \n\n\n\n\n\n\n\ndf5 = make_df('ABC', [1, 2])\ndf6 = make_df('BCD', [3, 4])\ndisplay('df5', 'df6', 'pd.concat([df5, df6],sort=True)')\n\n\n    df5\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n    df6\n\n\n\n\n\n\nB\nC\nD\n\n\n\n\n3\nB3\nC3\nD3\n\n\n4\nB4\nC4\nD4\n\n\n\n\n\n    \n\n    pd.concat([df5, df6],sort=True)\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\nA1\nB1\nC1\nNaN\n\n\n2\nA2\nB2\nC2\nNaN\n\n\n3\nNaN\nB3\nC3\nD3\n\n\n4\nNaN\nB4\nC4\nD4\n\n\n\n\n\n    \n\n\njoin = 'inner'를 이용하여 열의 교집합으로 변경할 수 있다.\n\ndisplay('df5', 'df6',\n        \"pd.concat([df5, df6], join='inner')\")\n\n\n    df5\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\nA1\nB1\nC1\n\n\n2\nA2\nB2\nC2\n\n\n\n\n\n    \n\n    df6\n\n\n\n\n\n\nB\nC\nD\n\n\n\n\n3\nB3\nC3\nD3\n\n\n4\nB4\nC4\nD4\n\n\n\n\n\n    \n\n    pd.concat([df5, df6], join='inner')\n\n\n\n\n\n\nB\nC\n\n\n\n\n1\nB1\nC1\n\n\n2\nB2\nC2\n\n\n3\nB3\nC3\n\n\n4\nB4\nC4\n\n\n\n\n\n    \n\n\n\n\n\n배열을 직접 연결할 수 있는 메소드를 가지고 있다.\n\ndisplay('df1', 'df2', 'df1.append(df2)')\n\n&lt;string&gt;:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n&lt;string&gt;:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n\n\n\n    df1\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nA\nB\n\n\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n    df1.append(df2)\n\n\n\n\n\n\nA\nB\n\n\n\n\n1\nA1\nB1\n\n\n2\nA2\nB2\n\n\n3\nA3\nB3\n\n\n4\nA4\nB4\n\n\n\n\n\n    \n\n\n\n\n\nmerge에는 관계 데이터(relation data)를 조작하는 규칙의 정형 집합이자 대부분의 데이터베이스에서 사용할 수 있는 연산의 개념적 기반을 형성하는 관계 대수(relational algebra)의 하위 집합에 해당하는 행위가 구현돼 있다.\n\n\n\ndf1 = pd.DataFrame({'employee': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'group': ['Accounting', 'Engineering', 'Engineering', 'HR']})\ndf2 = pd.DataFrame({'employee': ['Lisa', 'Bob', 'Jake', 'Sue'],\n                    'hire_date': [2004, 2008, 2012, 2014]})\ndisplay('df1', 'df2')\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nemployee\nhire_date\n\n\n\n\n0\nLisa\n2004\n\n\n1\nBob\n2008\n\n\n2\nJake\n2012\n\n\n3\nSue\n2014\n\n\n\n\n\n    \n\n\n\ndf3 = pd.merge(df1, df2)\ndf3\n\n\n  \n    \n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\ndf4 = pd.DataFrame({'group': ['Accounting', 'Engineering', 'HR'],\n                    'supervisor': ['Carly', 'Guido', 'Steve']})\ndisplay('df3', 'df4', 'pd.merge(df3, df4)')\n\n\n    df3\n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n    df4\n\n\n\n\n\n\ngroup\nsupervisor\n\n\n\n\n0\nAccounting\nCarly\n\n\n1\nEngineering\nGuido\n\n\n2\nHR\nSteve\n\n\n\n\n\n    \n\n    pd.merge(df3, df4)\n\n\n\n\n\n\nemployee\ngroup\nhire_date\nsupervisor\n\n\n\n\n0\nBob\nAccounting\n2008\nCarly\n\n\n1\nJake\nEngineering\n2012\nGuido\n\n\n2\nLisa\nEngineering\n2004\nGuido\n\n\n3\nSue\nHR\n2014\nSteve\n\n\n\n\n\n    \n\n\n\n\n\n\ndf5 = pd.DataFrame({'group': ['Accounting', 'Accounting',\n                              'Engineering', 'Engineering', 'HR', 'HR'],\n                    'skills': ['math', 'spreadsheets', 'coding', 'linux',\n                               'spreadsheets', 'organization']})\ndisplay('df1', 'df5', \"pd.merge(df1, df5)\")\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df5\n\n\n\n\n\n\ngroup\nskills\n\n\n\n\n0\nAccounting\nmath\n\n\n1\nAccounting\nspreadsheets\n\n\n2\nEngineering\ncoding\n\n\n3\nEngineering\nlinux\n\n\n4\nHR\nspreadsheets\n\n\n5\nHR\norganization\n\n\n\n\n\n    \n\n    pd.merge(df1, df5)\n\n\n\n\n\n\nemployee\ngroup\nskills\n\n\n\n\n0\nBob\nAccounting\nmath\n\n\n1\nBob\nAccounting\nspreadsheets\n\n\n2\nJake\nEngineering\ncoding\n\n\n3\nJake\nEngineering\nlinux\n\n\n4\nLisa\nEngineering\ncoding\n\n\n5\nLisa\nEngineering\nlinux\n\n\n6\nSue\nHR\nspreadsheets\n\n\n7\nSue\nHR\norganization\n\n\n\n\n\n    \n\n\n\n\n\n\n열 이름을 지정하여 데이터를 결합할 수 있다.\n\n\n\ndisplay('df1', 'df2', \"pd.merge(df1, df2, on='employee')\")\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df2\n\n\n\n\n\n\nemployee\nhire_date\n\n\n\n\n0\nLisa\n2004\n\n\n1\nBob\n2008\n\n\n2\nJake\n2012\n\n\n3\nSue\n2014\n\n\n\n\n\n    \n\n    pd.merge(df1, df2, on='employee')\n\n\n\n\n\n\nemployee\ngroup\nhire_date\n\n\n\n\n0\nBob\nAccounting\n2008\n\n\n1\nJake\nEngineering\n2012\n\n\n2\nLisa\nEngineering\n2004\n\n\n3\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\n\n\n\n\ndf3 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'salary': [70000, 80000, 120000, 90000]})\ndisplay('df1', 'df3', 'pd.merge(df1, df3, left_on=\"employee\", right_on=\"name\")')\n\n\n    df1\n\n\n\n\n\n\nemployee\ngroup\n\n\n\n\n0\nBob\nAccounting\n\n\n1\nJake\nEngineering\n\n\n2\nLisa\nEngineering\n\n\n3\nSue\nHR\n\n\n\n\n\n    \n\n    df3\n\n\n\n\n\n\nname\nsalary\n\n\n\n\n0\nBob\n70000\n\n\n1\nJake\n80000\n\n\n2\nLisa\n120000\n\n\n3\nSue\n90000\n\n\n\n\n\n    \n\n    pd.merge(df1, df3, left_on=\"employee\", right_on=\"name\")\n\n\n\n\n\n\nemployee\ngroup\nname\nsalary\n\n\n\n\n0\nBob\nAccounting\nBob\n70000\n\n\n1\nJake\nEngineering\nJake\n80000\n\n\n2\nLisa\nEngineering\nLisa\n120000\n\n\n3\nSue\nHR\nSue\n90000\n\n\n\n\n\n    \n\n\n\npd.merge(df1, df3, left_on=\"employee\", right_on=\"name\").drop('name', axis=1)\n\n\n  \n    \n\n\n\n\n\n\nemployee\ngroup\nsalary\n\n\n\n\n0\nBob\nAccounting\n70000\n\n\n1\nJake\nEngineering\n80000\n\n\n2\nLisa\nEngineering\n120000\n\n\n3\nSue\nHR\n90000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n인덱스를 통해 병합할 수 있다.\n\nprint(df1.head())\nprint(df2.head())\ndf1a = df1.set_index('employee')\n# 특정 열을 변수명으로 전환\ndf2a = df2.set_index('employee')\ndisplay('df1a', 'df2a')\n\n  employee        group\n0      Bob   Accounting\n1     Jake  Engineering\n2     Lisa  Engineering\n3      Sue           HR\n  employee  hire_date\n0     Lisa       2004\n1      Bob       2008\n2     Jake       2012\n3      Sue       2014\n\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n\n\ndisplay('df1a', 'df2a',\n        \"pd.merge(df1a, df2a, left_index=True, right_index=True)\")\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n    pd.merge(df1a, df2a, left_index=True, right_index=True)\n\n\n\n\n\n\ngroup\nhire_date\n\n\nemployee\n\n\n\n\n\n\nBob\nAccounting\n2008\n\n\nJake\nEngineering\n2012\n\n\nLisa\nEngineering\n2004\n\n\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\njoin() 메소드는 인덱스 기반으로 조인하는 병합을 수행한다.\n\ndisplay('df1a', 'df2a', 'df1a.join(df2a)')\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df2a\n\n\n\n\n\n\nhire_date\n\n\nemployee\n\n\n\n\n\nLisa\n2004\n\n\nBob\n2008\n\n\nJake\n2012\n\n\nSue\n2014\n\n\n\n\n\n    \n\n    df1a.join(df2a)\n\n\n\n\n\n\ngroup\nhire_date\n\n\nemployee\n\n\n\n\n\n\nBob\nAccounting\n2008\n\n\nJake\nEngineering\n2012\n\n\nLisa\nEngineering\n2004\n\n\nSue\nHR\n2014\n\n\n\n\n\n    \n\n\n인덱스와 열을 섞어서 결합할 수 있다.\n\ndisplay('df1a', 'df3', \"pd.merge(df1a, df3, left_index=True, right_on='name')\")\n# **_index: index name, **_on: variable name\n\n\n    df1a\n\n\n\n\n\n\ngroup\n\n\nemployee\n\n\n\n\n\nBob\nAccounting\n\n\nJake\nEngineering\n\n\nLisa\nEngineering\n\n\nSue\nHR\n\n\n\n\n\n    \n\n    df3\n\n\n\n\n\n\nname\nsalary\n\n\n\n\n0\nBob\n70000\n\n\n1\nJake\n80000\n\n\n2\nLisa\n120000\n\n\n3\nSue\n90000\n\n\n\n\n\n    \n\n    pd.merge(df1a, df3, left_index=True, right_on='name')\n\n\n\n\n\n\ngroup\nname\nsalary\n\n\n\n\n0\nAccounting\nBob\n70000\n\n\n1\nEngineering\nJake\n80000\n\n\n2\nEngineering\nLisa\n120000\n\n\n3\nHR\nSue\n90000\n\n\n\n\n\n    \n\n\n\n\n\n\nhow 키워드를 사용하면 결합하는 방법을 명시적으로 지정할 수 있다.\n\ndf6 = pd.DataFrame({'name': ['Peter', 'Paul', 'Mary'],\n                    'food': ['fish', 'beans', 'bread']},\n                   columns=['name', 'food'])\ndf7 = pd.DataFrame({'name': ['Mary', 'Joseph'],\n                    'drink': ['wine', 'beer']},\n                   columns=['name', 'drink'])\ndisplay('df6', 'df7', 'pd.merge(df6, df7)')\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7)\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nMary\nbread\nwine\n\n\n\n\n\n    \n\n\n\npd.merge(df6, df7, how='inner')\n\n\n  \n    \n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nMary\nbread\nwine\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n    \n  \n\n\n\ndisplay('df6', 'df7', \"pd.merge(df6, df7, how='outer')\")\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7, how='outer')\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nPeter\nfish\nNaN\n\n\n1\nPaul\nbeans\nNaN\n\n\n2\nMary\nbread\nwine\n\n\n3\nJoseph\nNaN\nbeer\n\n\n\n\n\n    \n\n\n\ndisplay('df6', 'df7', \"pd.merge(df6, df7, how='left')\")\n\n\n    df6\n\n\n\n\n\n\nname\nfood\n\n\n\n\n0\nPeter\nfish\n\n\n1\nPaul\nbeans\n\n\n2\nMary\nbread\n\n\n\n\n\n    \n\n    df7\n\n\n\n\n\n\nname\ndrink\n\n\n\n\n0\nMary\nwine\n\n\n1\nJoseph\nbeer\n\n\n\n\n\n    \n\n    pd.merge(df6, df7, how='left')\n\n\n\n\n\n\nname\nfood\ndrink\n\n\n\n\n0\nPeter\nfish\nNaN\n\n\n1\nPaul\nbeans\nNaN\n\n\n2\nMary\nbread\nwine\n\n\n\n\n\n    \n\n\n\n\n\n\ndf8 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'rank': [1, 2, 3, 4]})\ndf9 = pd.DataFrame({'name': ['Bob', 'Jake', 'Lisa', 'Sue'],\n                    'rank': [3, 1, 4, 2]})\ndisplay('df8', 'df9', 'pd.merge(df8, df9, on=\"name\")')\n\n\n    df8\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n1\n\n\n1\nJake\n2\n\n\n2\nLisa\n3\n\n\n3\nSue\n4\n\n\n\n\n\n    \n\n    df9\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n3\n\n\n1\nJake\n1\n\n\n2\nLisa\n4\n\n\n3\nSue\n2\n\n\n\n\n\n    \n\n    pd.merge(df8, df9, on=\"name\")\n\n\n\n\n\n\nname\nrank_x\nrank_y\n\n\n\n\n0\nBob\n1\n3\n\n\n1\nJake\n2\n1\n\n\n2\nLisa\n3\n4\n\n\n3\nSue\n4\n2\n\n\n\n\n\n    \n\n\nsuffixes옵션을 사용하면 겹치는 변수의 이름을 지정할 수 있다.\n\ndisplay('df8', 'df9', 'pd.merge(df8, df9, on=\"name\", suffixes=[\"_L\", \"_R\"])')\n\n\n    df8\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n1\n\n\n1\nJake\n2\n\n\n2\nLisa\n3\n\n\n3\nSue\n4\n\n\n\n\n\n    \n\n    df9\n\n\n\n\n\n\nname\nrank\n\n\n\n\n0\nBob\n3\n\n\n1\nJake\n1\n\n\n2\nLisa\n4\n\n\n3\nSue\n2\n\n\n\n\n\n    \n\n    pd.merge(df8, df9, on=\"name\", suffixes=[\"_L\", \"_R\"])\n\n\n\n\n\n\nname\nrank_L\nrank_R\n\n\n\n\n0\nBob\n1\n3\n\n\n1\nJake\n2\n1\n\n\n2\nLisa\n3\n4\n\n\n3\nSue\n4\n2"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#예제-us-states-자료",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#예제-us-states-자료",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "자료 받기\n\n# Following are shell commands to download the data\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-population.csv\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-areas.csv\n!curl -O https://raw.githubusercontent.com/jakevdp/data-USstates/master/state-abbrevs.csv\n\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 57935  100 57935    0     0   175k      0 --:--:-- --:--:-- --:--:--  175k\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   835  100   835    0     0   4135      0 --:--:-- --:--:-- --:--:--  4154\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   872  100   872    0     0   4538      0 --:--:-- --:--:-- --:--:--  4518\n\n\nread_csv() 함수를 이용하여 자료읽기\n\npop = pd.read_csv('state-population.csv')\nareas = pd.read_csv('state-areas.csv')\nabbrevs = pd.read_csv('state-abbrevs.csv')\n\ndisplay('pop.head()', 'areas.head()', 'abbrevs.head()')\n\n\n    pop.head()\n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\n\n\n\n\n\n    \n\n    areas.head()\n\n\n\n\n\n\nstate\narea (sq. mi)\n\n\n\n\n0\nAlabama\n52423\n\n\n1\nAlaska\n656425\n\n\n2\nArizona\n114006\n\n\n3\nArkansas\n53182\n\n\n4\nCalifornia\n163707\n\n\n\n\n\n    \n\n    abbrevs.head()\n\n\n\n\n\n\nstate\nabbreviation\n\n\n\n\n0\nAlabama\nAL\n\n\n1\nAlaska\nAK\n\n\n2\nArizona\nAZ\n\n\n3\nArkansas\nAR\n\n\n4\nCalifornia\nCA\n\n\n\n\n\n    \n\n\n\n\n\n인구(population)와 주의 전체 이름을 제공하는 데이터 결합\n\n\nmerged = pd.merge(pop, abbrevs, how='outer',\n                  left_on='state/region', right_on='abbreviation')\nmerged = merged.drop('abbreviation', 1) # drop duplicate info\nmerged.head()\n\nFutureWarning: In a future version of pandas all arguments of DataFrame.drop except for the argument 'labels' will be keyword-only.\n  merged = merged.drop('abbreviation', 1) # drop duplicate info\n\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nNull값 찾기\n\n\nmerged.isnull().any()\n\nstate/region    False\nages            False\nyear            False\npopulation       True\nstate            True\ndtype: bool\n\n\n\nmerged[merged['population'].isnull()].head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\n\n\n\n\n2448\nPR\nunder18\n1990\nNaN\nPuerto Rico\n\n\n2449\nPR\ntotal\n1990\nNaN\nPuerto Rico\n\n\n2450\nPR\ntotal\n1991\nNaN\nPuerto Rico\n\n\n2451\nPR\nunder18\n1991\nNaN\nPuerto Rico\n\n\n2452\nPR\ntotal\n1993\nNaN\nPuerto Rico\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nmerged.loc[merged['state'].isnull(), 'state/region']\nmerged.loc[merged['state'].isnull(), 'state/region'].unique()\n\narray(['PR', 'USA'], dtype=object)\n\n\n\n널 값에 항목 채워 넣기\n\n\nmerged.loc[merged['state/region'] == 'PR', 'state'] = 'Puerto Rico'\nmerged.loc[merged['state/region'] == 'USA', 'state'] = 'United States'\nmerged.isnull().any()\n\nstate/region    False\nages            False\nyear            False\npopulation       True\nstate           False\ndtype: bool\n\n\n\n면적 데이터의 결합\n\n\nfinal = pd.merge(merged, areas, on='state', how='left')\nfinal.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n52423.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n52423.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n52423.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n52423.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nNull값 찾기\n\n\nfinal.isnull().any()\n\nstate/region     False\nages             False\nyear             False\npopulation        True\nstate            False\narea (sq. mi)     True\ndtype: bool\n\n\n\nfinal['state'][final['area (sq. mi)'].isnull()].unique()\n\narray(['United States'], dtype=object)\n\n\n\nNull값 삭제\n\n\nfinal.dropna(inplace=True) # NULL 삭제\nfinal.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n0\nAL\nunder18\n2012\n1117489.0\nAlabama\n52423.0\n\n\n1\nAL\ntotal\n2012\n4817528.0\nAlabama\n52423.0\n\n\n2\nAL\nunder18\n2010\n1130966.0\nAlabama\n52423.0\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n4\nAL\nunder18\n2011\n1125763.0\nAlabama\n52423.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\nfinal['state'][final['area (sq. mi)'].isnull()].unique()\n\narray([], dtype=object)\n\n\n\n특정 데이터 선택: query() 사용\n\n\n#!pip3 install numexpr\n\nRequirement already satisfied: numexpr in /usr/local/lib/python3.10/dist-packages (2.8.7)\nRequirement already satisfied: numpy&gt;=1.13.3 in /usr/local/lib/python3.10/dist-packages (from numexpr) (1.23.5)\n\n\n\ndata2010 = final[(final.year == 2010) & (final.ages == 'total')]\ndata2010.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n91\nAK\ntotal\n2010\n713868.0\nAlaska\n656425.0\n\n\n101\nAZ\ntotal\n2010\n6408790.0\nArizona\n114006.0\n\n\n189\nAR\ntotal\n2010\n2922280.0\nArkansas\n53182.0\n\n\n197\nCA\ntotal\n2010\n37333601.0\nCalifornia\n163707.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndata2010 = final.query(\"year == 2010 & ages == 'total'\")\ndata2010.head()\n\n\n  \n    \n\n\n\n\n\n\nstate/region\nages\nyear\npopulation\nstate\narea (sq. mi)\n\n\n\n\n3\nAL\ntotal\n2010\n4785570.0\nAlabama\n52423.0\n\n\n91\nAK\ntotal\n2010\n713868.0\nAlaska\n656425.0\n\n\n101\nAZ\ntotal\n2010\n6408790.0\nArizona\n114006.0\n\n\n189\nAR\ntotal\n2010\n2922280.0\nArkansas\n53182.0\n\n\n197\nCA\ntotal\n2010\n37333601.0\nCalifornia\n163707.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n인구 밀도 계산\n\n\ndata2010.set_index('state', inplace=True)\n# 변수를 첨자로 변환\ndensity = data2010['population'] / data2010['area (sq. mi)']\n# density.head()\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-141-b633852d4acf&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 data2010.set_index('state', inplace=True)\n      2 # 변수를 첨자로 변환\n      3 data2010.index\n      4 density = data2010['population'] / data2010['area (sq. mi)']\n      5 # density.head()\n\n/usr/local/lib/python3.10/dist-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)\n    329                     stacklevel=find_stack_level(),\n    330                 )\n--&gt; 331             return func(*args, **kwargs)\n    332 \n    333         # error: \"Callable[[VarArg(Any), KwArg(Any)], Any]\" has no\n\n/usr/local/lib/python3.10/dist-packages/pandas/core/frame.py in set_index(self, keys, drop, append, inplace, verify_integrity)\n   6010 \n   6011         if missing:\n-&gt; 6012             raise KeyError(f\"None of {missing} are in the columns\")\n   6013 \n   6014         if inplace:\n\nKeyError: \"None of ['state'] are in the columns\"\n\n\n\n\ndensity.sort_values(ascending=False, inplace=True)\ndensity.head()\n\nstate\nDistrict of Columbia    8898.897059\nPuerto Rico             1058.665149\nNew Jersey              1009.253268\nRhode Island             681.339159\nConnecticut              645.600649\ndtype: float64\n\n\n\ndensity.tail()\n\nstate\nSouth Dakota    10.583512\nNorth Dakota     9.537565\nMontana          6.736171\nWyoming          5.768079\nAlaska           1.087509\ndtype: float64"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#집계와-군집화",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#집계와-군집화",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "planets = pd.read_csv('/content/planets.csv')\nplanets.shape\n\n(1035, 6)\n\n\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\n\nMounted at /content/drive\n\n\n\nplanets.head()\n\n\n  \n    \n\n\n\n\n\n\nmethod\nnumber\norbital_period\nmass\ndistance\nyear\n\n\n\n\n0\nRadial Velocity\n1\n269.300\n7.10\n77.40\n2006\n\n\n1\nRadial Velocity\n1\n874.774\n2.21\n56.95\n2008\n\n\n2\nRadial Velocity\n1\n763.000\n2.60\n19.84\n2011\n\n\n3\nRadial Velocity\n1\n326.030\n19.40\n110.62\n2007\n\n\n4\nRadial Velocity\n1\n516.220\n10.50\n119.47\n2009\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\nplanets.dropna().describe()\n#describe: 요약통계량\n\n\n  \n    \n\n\n\n\n\n\nnumber\norbital_period\nmass\ndistance\nyear\n\n\n\n\ncount\n498.00000\n498.000000\n498.000000\n498.000000\n498.000000\n\n\nmean\n1.73494\n835.778671\n2.509320\n52.068213\n2007.377510\n\n\nstd\n1.17572\n1469.128259\n3.636274\n46.596041\n4.167284\n\n\nmin\n1.00000\n1.328300\n0.003600\n1.350000\n1989.000000\n\n\n25%\n1.00000\n38.272250\n0.212500\n24.497500\n2005.000000\n\n\n50%\n1.00000\n357.000000\n1.245000\n39.940000\n2009.000000\n\n\n75%\n2.00000\n999.600000\n2.867500\n59.332500\n2011.000000\n\n\nmax\n6.00000\n17337.500000\n25.000000\n354.000000\n2014.000000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nPandas에서 제공하는 집계 연산:\n\n\n\nAggregation\nDescription\n\n\n\n\ncount()\nTotal number of items\n\n\nfirst(), last()\nFirst and last item\n\n\nmean(), median()\nMean and median\n\n\nmin(), max()\nMinimum and maximum\n\n\nstd(), var()\nStandard deviation and variance\n\n\nmad()\nMean absolute deviation\n\n\nprod()\nProduct of all items\n\n\nsum()\nSum of all items"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#groupby-분할-적용-결합",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#groupby-분할-적용-결합",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "자료를 요약할 때 특정 기준을 이용할 수 있다.\n\ndf = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'data': range(6)}, columns=['key', 'data'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nkey\ndata\n\n\n\n\n0\nA\n0\n\n\n1\nB\n1\n\n\n2\nC\n2\n\n\n3\nA\n3\n\n\n4\nB\n4\n\n\n5\nC\n5\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\ngroupby():\n\ndf.groupby('key').sum()\n\n\n  \n    \n\n\n\n\n\n\ndata\n\n\nkey\n\n\n\n\n\nA\n3\n\n\nB\n5\n\n\nC\n7\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\nmethod별 orbital_period의 중앙값 계산\n\nplanets.groupby('method')['orbital_period'].median()\n\nmethod\nAstrometry                         631.180000\nEclipse Timing Variations         4343.500000\nImaging                          27500.000000\nMicrolensing                      3300.000000\nOrbital Brightness Modulation        0.342887\nPulsar Timing                       66.541900\nPulsation Timing Variations       1170.000000\nRadial Velocity                    360.200000\nTransit                              5.714932\nTransit Timing Variations           57.011000\nName: orbital_period, dtype: float64\n\n\n\n\n\n\nfor (method, group) in planets.groupby('method'):\n    print(\"{0:30s} shape={1}\".format(method, group.shape))\n\nAstrometry                     shape=(2, 6)\nEclipse Timing Variations      shape=(9, 6)\nImaging                        shape=(38, 6)\nMicrolensing                   shape=(23, 6)\nOrbital Brightness Modulation  shape=(3, 6)\nPulsar Timing                  shape=(5, 6)\nPulsation Timing Variations    shape=(1, 6)\nRadial Velocity                shape=(553, 6)\nTransit                        shape=(397, 6)\nTransit Timing Variations      shape=(4, 6)\n\n\n\n\n\nmethod별 year에 대한 요약 통계량 계산\n\nplanets.groupby('method')['year'].describe()\n\n\n  \n    \n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\nmethod\n\n\n\n\n\n\n\n\n\n\n\n\nAstrometry\n2.0\n2011.500000\n2.121320\n2010.0\n2010.75\n2011.5\n2012.25\n2013.0\n\n\nEclipse Timing Variations\n9.0\n2010.000000\n1.414214\n2008.0\n2009.00\n2010.0\n2011.00\n2012.0\n\n\nImaging\n38.0\n2009.131579\n2.781901\n2004.0\n2008.00\n2009.0\n2011.00\n2013.0\n\n\nMicrolensing\n23.0\n2009.782609\n2.859697\n2004.0\n2008.00\n2010.0\n2012.00\n2013.0\n\n\nOrbital Brightness Modulation\n3.0\n2011.666667\n1.154701\n2011.0\n2011.00\n2011.0\n2012.00\n2013.0\n\n\nPulsar Timing\n5.0\n1998.400000\n8.384510\n1992.0\n1992.00\n1994.0\n2003.00\n2011.0\n\n\nPulsation Timing Variations\n1.0\n2007.000000\nNaN\n2007.0\n2007.00\n2007.0\n2007.00\n2007.0\n\n\nRadial Velocity\n553.0\n2007.518987\n4.249052\n1989.0\n2005.00\n2009.0\n2011.00\n2014.0\n\n\nTransit\n397.0\n2011.236776\n2.077867\n2002.0\n2010.00\n2012.0\n2013.00\n2014.0\n\n\nTransit Timing Variations\n4.0\n2012.500000\n1.290994\n2011.0\n2011.75\n2012.5\n2013.25\n2014.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\n\nrng = np.random.RandomState(0)\ndf = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'data1': range(6),\n                   'data2': rng.randint(0, 10, 6)},\n                   columns = ['key', 'data1', 'data2'])\ndf\n\n\n  \n    \n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\naggregate 메소드를 사용하면 더 유연하게 요약 통계량을 계산할 수 있다.\n\ndf.groupby('key').aggregate(['min', np.median, max])\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\n\nmin\nmedian\nmax\nmin\nmedian\nmax\n\n\nkey\n\n\n\n\n\n\n\n\n\n\nA\n0\n1.5\n3\n3\n4.0\n5\n\n\nB\n1\n2.5\n4\n0\n3.5\n7\n\n\nC\n2\n3.5\n5\n3\n6.0\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ndf.groupby('key').aggregate({'data1': 'min',\n                             'data2': 'max'})\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n7\n\n\nC\n2\n9\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n필터연산을 사용하면 그룹 속성을 기준으로 데이터를 추출할 수 있다.\n\ndef filter_func(x):\n    return x['data2'].std() &gt; 4\n\ndisplay('df', \"df.groupby('key').std()\", \"df.groupby('key').filter(filter_func)\")\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby('key').std()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n2.12132\n1.414214\n\n\nB\n2.12132\n4.949747\n\n\nC\n2.12132\n4.242641\n\n\n\n\n\n    \n\n    df.groupby('key').filter(filter_func)\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n\n\n\n\n전체 데이터의 변환된 버전을 반환할 수 있다.\n\ndf.groupby('key').transform(lambda x: x - x.mean())\n\n\n  \n    \n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\n0\n-1.5\n1.0\n\n\n1\n-1.5\n-3.5\n\n\n2\n-1.5\n-3.0\n\n\n3\n1.5\n-1.0\n\n\n4\n1.5\n3.5\n\n\n5\n1.5\n3.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n임의의 함수를 그룹 결과에 적용할 때 사용된다.\n\ndef norm_by_data2(x):\n    # x is a DataFrame of group values\n    x['data1'] /= x['data2'].sum()\n    return x\n\ndisplay('df', \"df.groupby('key').apply(norm_by_data2)\")\n\n&lt;string&gt;:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n    &gt;&gt;&gt; .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n    &gt;&gt;&gt; .groupby(..., group_keys=True)\n&lt;string&gt;:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n    &gt;&gt;&gt; .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n    &gt;&gt;&gt; .groupby(..., group_keys=True)\n\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby('key').apply(norm_by_data2)\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0.000000\n5\n\n\n1\nB\n0.142857\n0\n\n\n2\nC\n0.166667\n3\n\n\n3\nA\n0.375000\n3\n\n\n4\nB\n0.571429\n7\n\n\n5\nC\n0.416667\n9\n\n\n\n\n\n    \n\n\n\n\n\n\n\nL = [0, 1, 0, 1, 2, 0]\ndisplay('df', 'df.groupby(L).sum()')\n\n&lt;string&gt;:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n&lt;string&gt;:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby(L).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\n\n\n0\n7\n17\n\n\n1\n4\n3\n\n\n2\n4\n7\n\n\n\n\n\n    \n\n\n\ndisplay('df', \"df.groupby(df['key']).sum()\")\n\n\n    df\n\n\n\n\n\n\nkey\ndata1\ndata2\n\n\n\n\n0\nA\n0\n5\n\n\n1\nB\n1\n0\n\n\n2\nC\n2\n3\n\n\n3\nA\n3\n3\n\n\n4\nB\n4\n7\n\n\n5\nC\n5\n9\n\n\n\n\n\n    \n\n    df.groupby(df['key']).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n3\n8\n\n\nB\n5\n7\n\n\nC\n7\n12\n\n\n\n\n\n    \n\n\n인덱스 값을 그룹 키에 매핑하는 딕셔너리를 제공할 수 있다.\n\ndf2 = df.set_index('key')\nmapping = {'A': 'vowel', 'B': 'consonant', 'C': 'consonant'}\ndisplay('df2', 'df2.groupby(mapping).sum()')\n\n\n    df2\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n0\n\n\nC\n2\n3\n\n\nA\n3\n3\n\n\nB\n4\n7\n\n\nC\n5\n9\n\n\n\n\n\n    \n\n    df2.groupby(mapping).sum()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nconsonant\n12\n19\n\n\nvowel\n3\n8\n\n\n\n\n\n    \n\n\nPython함수를 사용할 수 있다.\n\n?str.lower\n\n\ndisplay('df2', 'df2.groupby(str.lower).mean()')\n\n\n    df2\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\nA\n0\n5\n\n\nB\n1\n0\n\n\nC\n2\n3\n\n\nA\n3\n3\n\n\nB\n4\n7\n\n\nC\n5\n9\n\n\n\n\n\n    \n\n    df2.groupby(str.lower).mean()\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\n\n\n\n\n\n\na\n1.5\n4.0\n\n\nb\n2.5\n3.5\n\n\nc\n3.5\n6.0\n\n\n\n\n\n    \n\n\n지금까지 다룬 모든 키 선택 방식은 다중 인덱스에서 그룹에 결합하여 사용할 수 있다.\n\ndf2.groupby([str.lower, mapping]).mean()\n\n\n  \n    \n\n\n\n\n\n\n\ndata1\ndata2\n\n\nkey\nkey\n\n\n\n\n\n\na\nvowel\n1.5\n4.0\n\n\nb\nconsonant\n2.5\n3.5\n\n\nc\nconsonant\n3.5\n6.0\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n\ndecade = 10 * (planets['year'] // 10)\ndecade = decade.astype(str) + 's'\ndecade.name = 'decade'\nprint(decade)\nplanets.groupby(['method', decade])['number'].sum().unstack().fillna(0)\n\n0       2000s\n1       2000s\n2       2010s\n3       2000s\n4       2000s\n        ...  \n1030    2000s\n1031    2000s\n1032    2000s\n1033    2000s\n1034    2000s\nName: decade, Length: 1035, dtype: object\n\n\n\n  \n    \n\n\n\n\n\ndecade\n1980s\n1990s\n2000s\n2010s\n\n\nmethod\n\n\n\n\n\n\n\n\nAstrometry\n0.0\n0.0\n0.0\n2.0\n\n\nEclipse Timing Variations\n0.0\n0.0\n5.0\n10.0\n\n\nImaging\n0.0\n0.0\n29.0\n21.0\n\n\nMicrolensing\n0.0\n0.0\n12.0\n15.0\n\n\nOrbital Brightness Modulation\n0.0\n0.0\n0.0\n5.0\n\n\nPulsar Timing\n0.0\n9.0\n1.0\n1.0\n\n\nPulsation Timing Variations\n0.0\n0.0\n1.0\n0.0\n\n\nRadial Velocity\n1.0\n52.0\n475.0\n424.0\n\n\nTransit\n0.0\n0.0\n64.0\n712.0\n\n\nTransit Timing Variations\n0.0\n0.0\n0.0\n9.0"
  },
  {
    "objectID": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#피벗-테이블",
    "href": "posts/P04_Pandas_Supp_(3)/P04_Pandas_Supp_(3).html#피벗-테이블",
    "title": "P04_Pandas_Supp_(3)",
    "section": "",
    "text": "피벗 테이블은 입력값으로 간단한 열 단위의 데이터를 취하고 그 데이터에 대한 다차원 요약을 제공하는 2차원 테이블로 항목을 그룹핑한다. 피벗 테이블은 근본적으로 GroupBy 요약 통계량의 다차원 버전이다.\nGroupBy 요약 통계량의 다차원 버전\n\ntitanic = pd.read_csv('/content/titanic.csv')\n\n\ntitanic.head()\n\n\n  \n    \n\n\n\n\n\n\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\n\n0\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\nNaN\nS\n\n\n1\n2\n1\n1\nCumings, Mrs. John Bradley (Florence Briggs Th...\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n2\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\nNaN\nS\n\n\n3\n4\n1\n1\nFutrelle, Mrs. Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n4\n5\n0\n3\nAllen, Mr. William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\nNaN\nS\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\ntitanic['Survived'].mean()\n\n0.3838383838383838\n\n\n\ntitanic.groupby(['Sex', 'Pclass'])['Survived'].aggregate('mean').unstack()\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n\n\nmale\n0.368852\n0.157407\n0.135447\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\ntitanic.pivot_table('Survived', index='Sex', columns='Pclass')\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n\n\nmale\n0.368852\n0.157407\n0.135447\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n피벗 테이블의 그룹핑은 다단계로 여러 가지 옵션을 통해 지정할 수 있다.\n\nage = pd.cut(titanic['Age'], [0, 18, 80])\ntitanic.pivot_table('Survived', ['Sex', age], 'Pclass')\n\n\n  \n    \n\n\n\n\n\n\nPclass\n1\n2\n3\n\n\nSex\nAge\n\n\n\n\n\n\n\nfemale\n(0, 18]\n0.909091\n1.000000\n0.511628\n\n\n(18, 80]\n0.972973\n0.900000\n0.423729\n\n\nmale\n(0, 18]\n0.800000\n0.600000\n0.215686\n\n\n(18, 80]\n0.375000\n0.071429\n0.133663\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\npd.qcut 분위수 계산:\n\nfare = pd.qcut(titanic['Fare'], 2)\ntitanic.pivot_table('Survived', ['Sex', age], [fare, 'Pclass'])\n\n\n  \n    \n\n\n\n\n\n\nFare\n(-0.001, 14.454]\n(14.454, 512.329]\n\n\n\nPclass\n1\n2\n3\n1\n2\n3\n\n\nSex\nAge\n\n\n\n\n\n\n\n\n\n\nfemale\n(0, 18]\nNaN\n1.000000\n0.714286\n0.909091\n1.000000\n0.318182\n\n\n(18, 80]\nNaN\n0.880000\n0.444444\n0.972973\n0.914286\n0.391304\n\n\nmale\n(0, 18]\nNaN\n0.000000\n0.260870\n0.800000\n0.818182\n0.178571\n\n\n(18, 80]\n0.0\n0.098039\n0.125000\n0.391304\n0.030303\n0.192308\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n\n\n# call signature as of Pandas 0.18\nDataFrame.pivot_table(data, values=None, index=None, columns=None,\n                      aggfunc='mean', fill_value=None, margins=False,\n                      dropna=True, margins_name='All')\n\ntitanic.pivot_table(index='Sex', columns='Pclass',\n                    aggfunc={'Survived':sum, 'Fare':'mean'})\n\n\n  \n    \n\n\n\n\n\n\nFare\nSurvived\n\n\nPclass\n1\n2\n3\n1\n2\n3\n\n\nSex\n\n\n\n\n\n\n\n\n\n\nfemale\n106.125798\n21.970121\n16.118810\n91\n70\n72\n\n\nmale\n67.226127\n19.741782\n12.661633\n45\n17\n47\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\nmargins = True키워드를 통해 그룹별 총합을 계산할 수 있다.\n\ntitanic.pivot_table('Survived', index='Sex', columns='Pclass', margins=True)\n\n\n  \n    \n\n\n\n\n\nPclass\n1\n2\n3\nAll\n\n\nSex\n\n\n\n\n\n\n\n\nfemale\n0.968085\n0.921053\n0.500000\n0.742038\n\n\nmale\n0.368852\n0.157407\n0.135447\n0.188908\n\n\nAll\n0.629630\n0.472826\n0.242363\n0.383838"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "이번 강의에서는 if, while, for등의 조건문, 반복문과 사용자 정의 함수에 대해 학습한다.\n\n\n논리 연산(logical operation) 혹은 불 연산(boolean operation)은 참, 거짓 두 가지 원소(진리값으로 불림)만 존재하는 집합에서의 연산으로, 제어문(조건문, 반복문)에 필수적이다.\n\n\n\n\n\n부호\n정의\n\n\n\n\n&gt;\nx &gt; y : x가 y보다 크다\n\n\n&gt;=\nx가 y보다 크거나 같다\n\n\n&lt;\nx가 y보다 작다\n\n\n&lt;=\nx가 y보다 작거나 같다\n\n\n==\nx와 y가 같다\n\n\n!=\nx와 y가 같지 않다\n\n\n\n\nx = 1\nx == 1\n\nTrue\n\n\n\nx &gt;= 2\n\nFalse\n\n\n\n\n\n\n\n\n키워드\n비트\n설명\n\n\n\n\nand\n&\n논리식이 모두 참이면 참\n\n\nor\n|\n논리식 중에서 하나라도 참이면 참\n\n\nnot\n~\n논리식의 결과가 참이면 거짓을, 거짓이면 참\n\n\n\n^\n논리식중 하나가 참이고 다른하나가 거짓이면 참 (XOR)\n\n\n\n\nx == 1 & x == 2\n\nFalse\n\n\n\nx == 1 and x == 2\nprint((x == 1)^(x == 2))\n\nTrue\n\n\n\n\n\n\n\n\nin\nnot in\n\n\n\n\nx in 리스트\nx not in 리스트\n\n\nx in 튜플\nx not in 튜플\n\n\nx in 문자열\nx not in 문자열\n\n\n\n\n1 in [1, 2, 3]\n\nTrue\n\n\n\n1 not in [1, 2, 3]\n\nFalse\n\n\n\n\n\n\nPython프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰인다. if문의 사용법은 다음과 같다.\nif 조건문:  \n\n    수행할 문장 1  \n    수행할 문장 2  \n    ...    \n    \nelif 조건문2:  \n\n    수행할 문장 2-1  \n    수행할 문장 2-2  \n    ...  \n\nelif 조건문N:  \n\n    수행할 문장 N-1  \n    수행할 문장 N-2  \n    ...  \n    \nelse:  \n\n    수행할 문장 A  \n    수행할 문장 B  \n    ...  \n주의. Python에서는 들여쓰기로 코드의 블럭을 나눈다.\n\nx = 5\nif x &lt; 5:\n   x += 1\nelse:\n   x -= 1\n\nprint(x)\n\n4\n\n\n\nx = 5\nif x &lt; 5:\n    x = x + 1\nelif x &gt; 5:\n    x = x - 1\nelse:\n    x = x * 2\n\nprint(x)\n\n10\n\n\n\n\n\n반복문은 반복해서 문장을 수행해야 할 경우 사용된다. Python에서 사용되는 반복문은 for문과 while문이 있다.\n\n\nfor문의 기본구조는 다음과 같다.\nfor 변수 in 리스트(또는 튜플, 문자열, range):  \n\n    수행할 문장1\n    수행할 문장2\n    ...\n0부터 99까지 더하는 예제\n0에서 시작하는 루프임에 유의\n\ncount = 0\nfor i in range(100):\n    count += i\n    if i % 10 == 0:\n      print(count)\n\nprint(count)\n\n0\n55\n210\n465\n820\n1275\n1830\n2485\n3240\n4095\n4950\n\n\n\ncount = 0\nx = list(range(31))\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n\n\n\nfor i in x:\n    count += i\n\nprint(count)\n\n465\n\n\n0부터 9까지 더하는 것을 10번 반복\n\ncount = 0\nfor i in range(10):\n    for j in range(10):\n        count += j\n\nprint(count)\n\n450\n\n\n순서와 값을 이용하는 예제\n\nx = range(0,100,11)\nprint(list(x))\nfor i, y in enumerate(x): # 순서와 값을 반환\n    print('i (order) is : ', i, ', y (index) is : ', y)\n\n[0, 11, 22, 33, 44, 55, 66, 77, 88, 99]\ni (order) is :  0 , y (index) is :  0\ni (order) is :  1 , y (index) is :  11\ni (order) is :  2 , y (index) is :  22\ni (order) is :  3 , y (index) is :  33\ni (order) is :  4 , y (index) is :  44\ni (order) is :  5 , y (index) is :  55\ni (order) is :  6 , y (index) is :  66\ni (order) is :  7 , y (index) is :  77\ni (order) is :  8 , y (index) is :  88\ni (order) is :  9 , y (index) is :  99\n\n\n튜플을 이용한 예제\n\nx = [(1,2), (3,4), (5,6)]\nfor (f,l) in x:\n    print(f+l)\n\n3\n7\n11\n\n\n\n\nbreak문은 반복문을 강제 종료할 때 사용된다.\n\nx = range(0,100,11)\nfor i in x:\n    print(i)\n    if i &gt; 50:\n        break\n\n0\n11\n22\n33\n44\n55\n\n\n\n\n\ncontinue문은 반복문에서 특정 반복을 건너뛸 때 사용된다.\n\nx = range(0, 10)\nfor i in x:\n    print(i)\n    if i &lt;= 4:\n        continue\n    # 여기에서 조건이 맞으면 위로 돌아감\n    print(10*i)\n    # 여기에서 조건이 안맞으면 계속 실행\n\n0\n1\n2\n3\n4\n5\n50\n6\n60\n7\n70\n8\n80\n9\n90\n\n\n\n\n\n리스트 안에 for문을 포함하는 리스트 내포를 이용하면 편리하고 직관적인 프로그램을 만들 수 있다.\n\nx = [1, 2, 3, 4]\nr = []\n\nfor i in x:\n    r.append(i*3)\n\nprint(r)\n\n[3, 6, 9, 12]\n\n\n\nr = [i*10 for i in x]\nprint(r)\n\n[10, 20, 30, 40]\n\n\n\nr = [i*3 for i in x if i == 2]\nprint(r)\n\n[6]\n\n\n루프를 돌아가면서도 조건을 확인해서 조건이 맞을 떄만 작동\n\nr = [x*y for x in range(2,10) for y in range(1,10)]\nprint(r)\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n\n\n내포문에서 이중 루프도 가능함\n\n\n\n\nx = range(-5, 5)\nprint(list(x))\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n\n\n\nz_tuple = tuple(i**3 for i in x)\nprint(z_tuple)\n# 튜프 내포\n\n(-125, -64, -27, -8, -1, 0, 1, 8, 27, 64)\n\n\n\nprint(list(x))\nz_set = {x[i]**2.0 for i in x}\nprint(z_set)\n# 집합 내포\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n{0.0, 1.0, 4.0, 9.0, 16.0, 25.0}\n\n\n\nz_dict = {str(i):i*2 for i in x}\nprint(z_dict)\n# dictionary: 이름-값\n\n{'-5': -10, '-4': -8, '-3': -6, '-2': -4, '-1': -2, '0': 0, '1': 2, '2': 4, '3': 6, '4': 8}\n\n\n\n\n\n\n정수값을 받아서 짝수를 화면에 출력하는 코드를 작성하시오.\nA학급에 총 10명의 학생에 대한 중간점수가 있다. 평균을 구하시오.\n\n[70, 60, 55, 75, 95, 90, 80, 80, 85, 100]\n\ncount = 0\ni = 1\nwhile i &lt; 10:\n    count += i\n    i += 1\n\nprint(i)\nprint(count)\n\n10\n45\n\n\n\ncount = 0\nfor i in range(0,10):\n    count += i\n\nprint(i)\n\n9\n\n\n\nimport numpy as np\ncondition = True\ni = 0\nx = range(-10,10)\nprint(np.array(x))\n\nwhile condition:\n    if x[i] &gt; 0:\n        break    # condition = False\n    print(x[i])\n    i += 1\n# 양수가 되는 순간 루프를 나오고 아래 구문을 작동시키지 않음\n\n[-10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7\n   8   9]\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n\n\n\n\n\n\n1부터 50까지의 수 중 짝수를 화면에 출력하는 코드를 작성하시오.\nwhile문을 이용하여 아래와 같이 *를 표시하시오.\n*\n**\n***\n****\n*****\n\n참고. 문자열에 상수를 곱하면 해당 문자가 반복된다.\n\n\"*\" * 10\n\n'**********'\n\n\n\n\n\n\n\n사용자 정의 함수는 사용자가 직접 새로운 함수를 정의하는 방법으로 똑같은 내용이 반복되는 부분을 주로 함수로 정의하여 사용한다.\nPython에서 사용자 정의 함수를 정의하는 구조는 아래와 같다.\ndef 함수명(입력 인수):\n\n    수행할 문장1\n    수행할 문장2\n    ...\n    return 결과값\n제곱\n\ndef square(x):\n    return x**2\n\n\nx = 2\ny = square(x)\nprint(x,y)\n\n2 4\n\n\n거리\n\ndef l2dist(x,y):\n    return (x-y)**2\n\n\nx = 3\ny = 10\nz = l2dist(x,y)\nprint(x,y,z)\n\n3 10 49\n\n\n\nz = l2dist(y=10,x=3)\nprint(z)\n\n49\n\n\nPython에서 사용자 정의 함수는 입력 인수에 초기값을 설정할 수 있다. 단, 초기값을 가지는 인수는 맨 뒤에 위치해야 한다.\n\ndef lp_norm(x,y,p=2):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    return sum(d)**(1/p)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\nprint(x)\nprint(y)\nl2 = lp_norm(x,y)\nl1 = lp_norm(x,y,1)\nprint(l1,l2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n41.0 15.7797338380595\n\n\n입력 인수의 갯수를 변하도록 정의할 수 있다.\n\ndef lp_norm(x,y,p=2,*args):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n    out = [sum(d)**(1/p)]\n\n    print('Number of *args:', len(args))\n    for p in args:\n        d = []\n        for i in range(n):\n            d.append(abs(x[i] - y[i])**p)\n        print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n        out.append(sum(d)**(1/p))\n\n    return tuple(out)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\n\n\nlp = lp_norm(x,y)\nprint(lp)\n\nThe L2 distance is : 15.7797338380595\nNumber of *args: 0\n(15.7797338380595,)\n\n\n\nlp = lp_norm(x,y,1)\nprint(lp)\n\nThe L1 distance is : 41.0\nNumber of *args: 0\n(41.0,)\n\n\n\nlp = lp_norm(x,y,1,2,3,4,1.5,2.5,0.5)\nprint(lp)\n# number 역시 0부터 시작함\n\nThe L1 distance is : 41.0\nNumber of *args: 6\nThe L2 distance is : 15.7797338380595\nThe L3 distance is : 11.983774366920516\nThe L4 distance is : 10.631810414384907\nThe L1.5 distance is : 21.370708630062115\nThe L2.5 distance is : 13.317802359045247\nThe L0.5 distance is : 332.2505125167682\n(41.0, 15.7797338380595, 11.983774366920516, 10.631810414384907, 21.370708630062115, 13.317802359045247, 332.2505125167682)\n\n\n1 이후가 새로운 인수가 됨\n정의된 함수의 설명을 추가 할 수 있다.\n\ndef lp_norm(x,y,p = 2):\n    r\"\"\" Compute the distance between vectors.\n\n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n\n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n\n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n\n    Notes\n    -----\n\n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n\n    L2 norm is the default\n\n    &gt;&gt;&gt; lp_norm(x,y)\n\n    Lp can be computed using the optional third input\n\n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n    \"\"\"\n\n    if p&lt;0: p=0\n\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n\n    if p == 0:\n        count = 0\n        for i in range(n):\n            if d[i] != 0:\n                count += 1\n        return count\n    elif p &lt; 1:\n        return sum(d)\n    else:\n        return sum(d)**(1/p)\n\n\nhelp(lp_norm)\n\nHelp on function lp_norm in module __main__:\n\nlp_norm(x, y, p=2)\n    Compute the distance between vectors.\n    \n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n    \n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n    \n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n    \n    Notes\n    -----\n    \n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n    \n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n    \n    L2 norm is the default\n    \n    &gt;&gt;&gt; lp_norm(x,y)\n    \n    Lp can be computed using the optional third input\n    \n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n\n\n변수의 적용 범위 - 로컬과 글로벌이 존재 - 로컬은 함수 안에서 글로벌은 전체에 작용함\n\ndef scope_local():\n    a = -1\n    print('Inside scope_local, a is ',a)\n\ndef scope_global():\n    global a\n    a = -10\n    print('Inside scope_global, a is ',a)\n\n\na=1\nprint('a is ',a)\nprint('')\nscope_local()\nprint('a is now ',a)\nprint('')\nscope_global()\nprint('a is now ',a)\n\na is  1\n\nInside scope_local, a is  -1\na is now  1\n\nInside scope_global, a is  -10\na is now  -10\n\n\nlambda명령어를 사용하여 익명 함수를 정의할 수 있다.\n\nnested = [('John','Doe','Oxford'),\\\n          ('Jane','Dearing','Cambridge'),\\\n          ('Jerry','Dawn','Harvard')]\n\n\nnested.sort()\nprint(nested)\n\n[('Jane', 'Dearing', 'Cambridge'), ('Jerry', 'Dawn', 'Harvard'), ('John', 'Doe', 'Oxford')]\n\n\n\nprint( (lambda x:x**2)(5) )\n# 함수 정의\nnested.sort(key=lambda x:x[1])\nprint(nested)\n# 1번 첨자로 소팅\n\n25\n[('Jerry', 'Dawn', 'Harvard'), ('Jane', 'Dearing', 'Cambridge'), ('John', 'Doe', 'Oxford')]\n\n\n\n\n\n입력을 정수 n으로 받았을 때, n이하까지의 피보나치 수열을 출력하는 함수를 작성하시오.\n0, 1, 1, 2, 3, 5, 8, 13, ...\n다음의 값을 오름차순으로 정력하는 함수를 작성하시오.\n3, 2, 8, 4, 9, 13, 5\n\n\n\n\n\n모듈(module)이란 함수나 변수 또는 클래스(class) 들을 모아 놓은 파일로, 다른 Python프로그램에서 import명령어를 통해 불러와 사용할 수 있다.\n모듈 사용 방법: 1. import 모듈이름 as 별명 2. from 모듈이름 import 모듈함수\n\nimport numpy as np\n\nx = np.random.rand(10)\nprint(x)\n\n[0.5037167  0.33736336 0.45905245 0.07396127 0.14505654 0.8153129\n 0.60459636 0.26636206 0.90918077 0.11907817]\n\n\n사용자 정의 모듈\n\n%%writefile -a core.py\nr\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nWriting core.py\n\n\n\n!pwd\n#현재 작동되는 위치를 표시\n\n/content\n\n\n\nimport core\n\ny = -3\nprint(core.square(y))\nprint(core.cube(y))\n\n9\n-27\n\n\n__main__의 역할\n모듈 자체에 실행이 가능한 프로그램을 포함할 수 있도록 도와준다. 단, 다른 프로그램에서 불러와 사용될 때는 모듈안에 있는 실행 가능한 코드는 실행되지 않는다 (모듈이 연결되어 있는 경우, 독립성을 최대한 유지)\n\n%%writefile -a core1.py\n\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nif __name__ == \"__main__\":\n    print('Program called directly.')\nelse:\n    print('Program called indirectly using name: ', __name__)\n\nWriting core1.py\n\n\n\n!python3 core1.py\n\nProgram called directly.\n\n\n\n\n\n!pip3 install numpy\n\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.26.4)"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#논리-연산-logical-operator",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#논리-연산-logical-operator",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "논리 연산(logical operation) 혹은 불 연산(boolean operation)은 참, 거짓 두 가지 원소(진리값으로 불림)만 존재하는 집합에서의 연산으로, 제어문(조건문, 반복문)에 필수적이다.\n\n\n\n\n\n부호\n정의\n\n\n\n\n&gt;\nx &gt; y : x가 y보다 크다\n\n\n&gt;=\nx가 y보다 크거나 같다\n\n\n&lt;\nx가 y보다 작다\n\n\n&lt;=\nx가 y보다 작거나 같다\n\n\n==\nx와 y가 같다\n\n\n!=\nx와 y가 같지 않다\n\n\n\n\nx = 1\nx == 1\n\nTrue\n\n\n\nx &gt;= 2\n\nFalse\n\n\n\n\n\n\n\n\n키워드\n비트\n설명\n\n\n\n\nand\n&\n논리식이 모두 참이면 참\n\n\nor\n|\n논리식 중에서 하나라도 참이면 참\n\n\nnot\n~\n논리식의 결과가 참이면 거짓을, 거짓이면 참\n\n\n\n^\n논리식중 하나가 참이고 다른하나가 거짓이면 참 (XOR)\n\n\n\n\nx == 1 & x == 2\n\nFalse\n\n\n\nx == 1 and x == 2\nprint((x == 1)^(x == 2))\n\nTrue\n\n\n\n\n\n\n\n\nin\nnot in\n\n\n\n\nx in 리스트\nx not in 리스트\n\n\nx in 튜플\nx not in 튜플\n\n\nx in 문자열\nx not in 문자열\n\n\n\n\n1 in [1, 2, 3]\n\nTrue\n\n\n\n1 not in [1, 2, 3]\n\nFalse"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#조건문-if문",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#조건문-if문",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "Python프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰인다. if문의 사용법은 다음과 같다.\nif 조건문:  \n\n    수행할 문장 1  \n    수행할 문장 2  \n    ...    \n    \nelif 조건문2:  \n\n    수행할 문장 2-1  \n    수행할 문장 2-2  \n    ...  \n\nelif 조건문N:  \n\n    수행할 문장 N-1  \n    수행할 문장 N-2  \n    ...  \n    \nelse:  \n\n    수행할 문장 A  \n    수행할 문장 B  \n    ...  \n주의. Python에서는 들여쓰기로 코드의 블럭을 나눈다.\n\nx = 5\nif x &lt; 5:\n   x += 1\nelse:\n   x -= 1\n\nprint(x)\n\n4\n\n\n\nx = 5\nif x &lt; 5:\n    x = x + 1\nelif x &gt; 5:\n    x = x - 1\nelse:\n    x = x * 2\n\nprint(x)\n\n10"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#반복문-for문-while문",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#반복문-for문-while문",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "반복문은 반복해서 문장을 수행해야 할 경우 사용된다. Python에서 사용되는 반복문은 for문과 while문이 있다.\n\n\nfor문의 기본구조는 다음과 같다.\nfor 변수 in 리스트(또는 튜플, 문자열, range):  \n\n    수행할 문장1\n    수행할 문장2\n    ...\n0부터 99까지 더하는 예제\n0에서 시작하는 루프임에 유의\n\ncount = 0\nfor i in range(100):\n    count += i\n    if i % 10 == 0:\n      print(count)\n\nprint(count)\n\n0\n55\n210\n465\n820\n1275\n1830\n2485\n3240\n4095\n4950\n\n\n\ncount = 0\nx = list(range(31))\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n\n\n\nfor i in x:\n    count += i\n\nprint(count)\n\n465\n\n\n0부터 9까지 더하는 것을 10번 반복\n\ncount = 0\nfor i in range(10):\n    for j in range(10):\n        count += j\n\nprint(count)\n\n450\n\n\n순서와 값을 이용하는 예제\n\nx = range(0,100,11)\nprint(list(x))\nfor i, y in enumerate(x): # 순서와 값을 반환\n    print('i (order) is : ', i, ', y (index) is : ', y)\n\n[0, 11, 22, 33, 44, 55, 66, 77, 88, 99]\ni (order) is :  0 , y (index) is :  0\ni (order) is :  1 , y (index) is :  11\ni (order) is :  2 , y (index) is :  22\ni (order) is :  3 , y (index) is :  33\ni (order) is :  4 , y (index) is :  44\ni (order) is :  5 , y (index) is :  55\ni (order) is :  6 , y (index) is :  66\ni (order) is :  7 , y (index) is :  77\ni (order) is :  8 , y (index) is :  88\ni (order) is :  9 , y (index) is :  99\n\n\n튜플을 이용한 예제\n\nx = [(1,2), (3,4), (5,6)]\nfor (f,l) in x:\n    print(f+l)\n\n3\n7\n11\n\n\n\n\nbreak문은 반복문을 강제 종료할 때 사용된다.\n\nx = range(0,100,11)\nfor i in x:\n    print(i)\n    if i &gt; 50:\n        break\n\n0\n11\n22\n33\n44\n55\n\n\n\n\n\ncontinue문은 반복문에서 특정 반복을 건너뛸 때 사용된다.\n\nx = range(0, 10)\nfor i in x:\n    print(i)\n    if i &lt;= 4:\n        continue\n    # 여기에서 조건이 맞으면 위로 돌아감\n    print(10*i)\n    # 여기에서 조건이 안맞으면 계속 실행\n\n0\n1\n2\n3\n4\n5\n50\n6\n60\n7\n70\n8\n80\n9\n90\n\n\n\n\n\n리스트 안에 for문을 포함하는 리스트 내포를 이용하면 편리하고 직관적인 프로그램을 만들 수 있다.\n\nx = [1, 2, 3, 4]\nr = []\n\nfor i in x:\n    r.append(i*3)\n\nprint(r)\n\n[3, 6, 9, 12]\n\n\n\nr = [i*10 for i in x]\nprint(r)\n\n[10, 20, 30, 40]\n\n\n\nr = [i*3 for i in x if i == 2]\nprint(r)\n\n[6]\n\n\n루프를 돌아가면서도 조건을 확인해서 조건이 맞을 떄만 작동\n\nr = [x*y for x in range(2,10) for y in range(1,10)]\nprint(r)\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n\n\n내포문에서 이중 루프도 가능함\n\n\n\n\nx = range(-5, 5)\nprint(list(x))\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n\n\n\nz_tuple = tuple(i**3 for i in x)\nprint(z_tuple)\n# 튜프 내포\n\n(-125, -64, -27, -8, -1, 0, 1, 8, 27, 64)\n\n\n\nprint(list(x))\nz_set = {x[i]**2.0 for i in x}\nprint(z_set)\n# 집합 내포\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n{0.0, 1.0, 4.0, 9.0, 16.0, 25.0}\n\n\n\nz_dict = {str(i):i*2 for i in x}\nprint(z_dict)\n# dictionary: 이름-값\n\n{'-5': -10, '-4': -8, '-3': -6, '-2': -4, '-1': -2, '0': 0, '1': 2, '2': 4, '3': 6, '4': 8}\n\n\n\n\n\n\n정수값을 받아서 짝수를 화면에 출력하는 코드를 작성하시오.\nA학급에 총 10명의 학생에 대한 중간점수가 있다. 평균을 구하시오.\n\n[70, 60, 55, 75, 95, 90, 80, 80, 85, 100]\n\ncount = 0\ni = 1\nwhile i &lt; 10:\n    count += i\n    i += 1\n\nprint(i)\nprint(count)\n\n10\n45\n\n\n\ncount = 0\nfor i in range(0,10):\n    count += i\n\nprint(i)\n\n9\n\n\n\nimport numpy as np\ncondition = True\ni = 0\nx = range(-10,10)\nprint(np.array(x))\n\nwhile condition:\n    if x[i] &gt; 0:\n        break    # condition = False\n    print(x[i])\n    i += 1\n# 양수가 되는 순간 루프를 나오고 아래 구문을 작동시키지 않음\n\n[-10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7\n   8   9]\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n\n\n\n\n\n\n1부터 50까지의 수 중 짝수를 화면에 출력하는 코드를 작성하시오.\nwhile문을 이용하여 아래와 같이 *를 표시하시오.\n*\n**\n***\n****\n*****\n\n참고. 문자열에 상수를 곱하면 해당 문자가 반복된다.\n\n\"*\" * 10\n\n'**********'"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#사용자-정의-함수",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#사용자-정의-함수",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "사용자 정의 함수는 사용자가 직접 새로운 함수를 정의하는 방법으로 똑같은 내용이 반복되는 부분을 주로 함수로 정의하여 사용한다.\nPython에서 사용자 정의 함수를 정의하는 구조는 아래와 같다.\ndef 함수명(입력 인수):\n\n    수행할 문장1\n    수행할 문장2\n    ...\n    return 결과값\n제곱\n\ndef square(x):\n    return x**2\n\n\nx = 2\ny = square(x)\nprint(x,y)\n\n2 4\n\n\n거리\n\ndef l2dist(x,y):\n    return (x-y)**2\n\n\nx = 3\ny = 10\nz = l2dist(x,y)\nprint(x,y,z)\n\n3 10 49\n\n\n\nz = l2dist(y=10,x=3)\nprint(z)\n\n49\n\n\nPython에서 사용자 정의 함수는 입력 인수에 초기값을 설정할 수 있다. 단, 초기값을 가지는 인수는 맨 뒤에 위치해야 한다.\n\ndef lp_norm(x,y,p=2):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    return sum(d)**(1/p)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\nprint(x)\nprint(y)\nl2 = lp_norm(x,y)\nl1 = lp_norm(x,y,1)\nprint(l1,l2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n41.0 15.7797338380595\n\n\n입력 인수의 갯수를 변하도록 정의할 수 있다.\n\ndef lp_norm(x,y,p=2,*args):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n    out = [sum(d)**(1/p)]\n\n    print('Number of *args:', len(args))\n    for p in args:\n        d = []\n        for i in range(n):\n            d.append(abs(x[i] - y[i])**p)\n        print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n        out.append(sum(d)**(1/p))\n\n    return tuple(out)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\n\n\nlp = lp_norm(x,y)\nprint(lp)\n\nThe L2 distance is : 15.7797338380595\nNumber of *args: 0\n(15.7797338380595,)\n\n\n\nlp = lp_norm(x,y,1)\nprint(lp)\n\nThe L1 distance is : 41.0\nNumber of *args: 0\n(41.0,)\n\n\n\nlp = lp_norm(x,y,1,2,3,4,1.5,2.5,0.5)\nprint(lp)\n# number 역시 0부터 시작함\n\nThe L1 distance is : 41.0\nNumber of *args: 6\nThe L2 distance is : 15.7797338380595\nThe L3 distance is : 11.983774366920516\nThe L4 distance is : 10.631810414384907\nThe L1.5 distance is : 21.370708630062115\nThe L2.5 distance is : 13.317802359045247\nThe L0.5 distance is : 332.2505125167682\n(41.0, 15.7797338380595, 11.983774366920516, 10.631810414384907, 21.370708630062115, 13.317802359045247, 332.2505125167682)\n\n\n1 이후가 새로운 인수가 됨\n정의된 함수의 설명을 추가 할 수 있다.\n\ndef lp_norm(x,y,p = 2):\n    r\"\"\" Compute the distance between vectors.\n\n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n\n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n\n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n\n    Notes\n    -----\n\n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n\n    L2 norm is the default\n\n    &gt;&gt;&gt; lp_norm(x,y)\n\n    Lp can be computed using the optional third input\n\n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n    \"\"\"\n\n    if p&lt;0: p=0\n\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n\n    if p == 0:\n        count = 0\n        for i in range(n):\n            if d[i] != 0:\n                count += 1\n        return count\n    elif p &lt; 1:\n        return sum(d)\n    else:\n        return sum(d)**(1/p)\n\n\nhelp(lp_norm)\n\nHelp on function lp_norm in module __main__:\n\nlp_norm(x, y, p=2)\n    Compute the distance between vectors.\n    \n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n    \n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n    \n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n    \n    Notes\n    -----\n    \n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n    \n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n    \n    L2 norm is the default\n    \n    &gt;&gt;&gt; lp_norm(x,y)\n    \n    Lp can be computed using the optional third input\n    \n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n\n\n변수의 적용 범위 - 로컬과 글로벌이 존재 - 로컬은 함수 안에서 글로벌은 전체에 작용함\n\ndef scope_local():\n    a = -1\n    print('Inside scope_local, a is ',a)\n\ndef scope_global():\n    global a\n    a = -10\n    print('Inside scope_global, a is ',a)\n\n\na=1\nprint('a is ',a)\nprint('')\nscope_local()\nprint('a is now ',a)\nprint('')\nscope_global()\nprint('a is now ',a)\n\na is  1\n\nInside scope_local, a is  -1\na is now  1\n\nInside scope_global, a is  -10\na is now  -10\n\n\nlambda명령어를 사용하여 익명 함수를 정의할 수 있다.\n\nnested = [('John','Doe','Oxford'),\\\n          ('Jane','Dearing','Cambridge'),\\\n          ('Jerry','Dawn','Harvard')]\n\n\nnested.sort()\nprint(nested)\n\n[('Jane', 'Dearing', 'Cambridge'), ('Jerry', 'Dawn', 'Harvard'), ('John', 'Doe', 'Oxford')]\n\n\n\nprint( (lambda x:x**2)(5) )\n# 함수 정의\nnested.sort(key=lambda x:x[1])\nprint(nested)\n# 1번 첨자로 소팅\n\n25\n[('Jerry', 'Dawn', 'Harvard'), ('Jane', 'Dearing', 'Cambridge'), ('John', 'Doe', 'Oxford')]\n\n\n\n\n\n입력을 정수 n으로 받았을 때, n이하까지의 피보나치 수열을 출력하는 함수를 작성하시오.\n0, 1, 1, 2, 3, 5, 8, 13, ...\n다음의 값을 오름차순으로 정력하는 함수를 작성하시오.\n3, 2, 8, 4, 9, 13, 5"
  },
  {
    "objectID": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#모듈modules",
    "href": "posts/P03_LoopFunction(2)/P03_LoopFunction(2).html#모듈modules",
    "title": "P03_LoopFunction(2)",
    "section": "",
    "text": "모듈(module)이란 함수나 변수 또는 클래스(class) 들을 모아 놓은 파일로, 다른 Python프로그램에서 import명령어를 통해 불러와 사용할 수 있다.\n모듈 사용 방법: 1. import 모듈이름 as 별명 2. from 모듈이름 import 모듈함수\n\nimport numpy as np\n\nx = np.random.rand(10)\nprint(x)\n\n[0.5037167  0.33736336 0.45905245 0.07396127 0.14505654 0.8153129\n 0.60459636 0.26636206 0.90918077 0.11907817]\n\n\n사용자 정의 모듈\n\n%%writefile -a core.py\nr\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nWriting core.py\n\n\n\n!pwd\n#현재 작동되는 위치를 표시\n\n/content\n\n\n\nimport core\n\ny = -3\nprint(core.square(y))\nprint(core.cube(y))\n\n9\n-27\n\n\n__main__의 역할\n모듈 자체에 실행이 가능한 프로그램을 포함할 수 있도록 도와준다. 단, 다른 프로그램에서 불러와 사용될 때는 모듈안에 있는 실행 가능한 코드는 실행되지 않는다 (모듈이 연결되어 있는 경우, 독립성을 최대한 유지)\n\n%%writefile -a core1.py\n\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nif __name__ == \"__main__\":\n    print('Program called directly.')\nelse:\n    print('Program called indirectly using name: ', __name__)\n\nWriting core1.py\n\n\n\n!python3 core1.py\n\nProgram called directly.\n\n\n\n\n\n!pip3 install numpy\n\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.26.4)"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html",
    "title": "P02_Numpy",
    "section": "",
    "text": "NumPy는 Numerical Python의 약자로 내장타입의 list와 비슷하다. 그러나, 데이터 배열을 사용하여 최적화된 연산을 위한 쉽고 유연한 인터페이스를 제공하여 배열의 규모가 커질수록 데이터 저장 및 처리에 훨씬 효과적이다. 자세한 사항은 https://numpy.org 에 나타나 있다.\nNumPy를 사용하기 위해서는 import를 이용하여 불러와야 한다. 다음은 별칭(alias) np를 사용하여 NumPy불러오는 코드이다.\n\n!pip install numpy\n\nimport numpy as np\nnp.__version__\n\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.26.4)\n\n\n'1.26.4'\n\n\n\n\n가장 기본적으로 NumPy배열을 생성하는 방법은 리스트를 이용하는 것이다.\n\nnp.array([1, 4, 2, 5, 3])\n\narray([1, 4, 2, 5, 3])\n\n\n주의. list와 달리 NumPy는 배열의 모든 요소가 같은 타입이어야 한다.\n\nnp.array([3.14, 4, 2, 3])\n\narray([3.14, 4.  , 2.  , 3.  ])\n\n\n참고. dtype키워드를 사용하면 데이터 타입을 설정할 수 있다.\n\nnp.array([1, 2, 3, 4], dtype='float32')\n\narray([1., 2., 3., 4.], dtype=float32)\n\n\n참고. 리스트와 달리 NumPy 배열은 명시적으로 다차원이 가능하다. 내부 리스트는 결과로 얻은 이차원 배열의 행으로 취급된다.\n\nnp.array([range(i, i + 3) for i in [2, 4, 6]])\n\narray([[2, 3, 4],\n       [4, 5, 6],\n       [6, 7, 8]])\n\n\nrange(2,5), range(4,7), range(6,9)를 각각 행 구조로 입력함\n\n\n\n다음의 예제들은 내장된 메소드를 이용하여 NumPy배열을 만드는 방법을 나타낸다.\n\nnp.zeros(10, dtype=int)\n\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nnp.ones, np.zeros 는 모든 원소의 값을 0이나 1로 하고 차원과 값의 유형을 지정한다.\n\nnp.ones((3, 5), dtype=float)\n\narray([[1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1.]])\n\n\n\nnp.full((3, 5), 3.14)\n\narray([[3.14, 3.14, 3.14, 3.14, 3.14],\n       [3.14, 3.14, 3.14, 3.14, 3.14],\n       [3.14, 3.14, 3.14, 3.14, 3.14]])\n\n\n0이나 1이 아닌 특정값을 채우고 싶다면 이 구문을 이용\n\nnp.arange(0, 20, 2)\n\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\n\n\n\nnp.linspace(0, 1, 5)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n\n그리드를 잡고 싶을 때 이용, 1부터 1까지 5개의 값으로 분할\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nIdentity 행렬을 만듬\n\nnp.empty(1)\n\narray([1.])\n\n\n참고. np.empty는 해당 메모리 위치에 이미 존재하고 있는 값으로 채운다. 메모리 번호를 알고 있어야 함\n\n\n\nNumPy는 C로 구현되어 있기 때문에 NumPy의 데이터 타입은 C와 Fortran언어 혹은 관련된 다른언어와 비슷하다.\n\n\n\n\n\n\n\nData type\nDescription\n\n\n\n\nbool_\nBoolean (True or False) stored as a byte\n\n\nint_\nDefault integer type (same as C long; normally either int64 or int32)\n\n\nintc\nIdentical to C int (normally int32 or int64)\n\n\nintp\nInteger used for indexing (same as C ssize_t; normally either int32 or int64)\n\n\nint8\nByte (-128 to 127)\n\n\nint16\nInteger (-32768 to 32767)\n\n\nint32\nInteger (-2147483648 to 2147483647)\n\n\nint64\nInteger (-9223372036854775808 to 9223372036854775807)\n\n\nuint8\nUnsigned integer (0 to 255)\n\n\nuint16\nUnsigned integer (0 to 65535)\n\n\nuint32\nUnsigned integer (0 to 4294967295)\n\n\nuint64\nUnsigned integer (0 to 18446744073709551615)\n\n\nfloat_\nShorthand for float64.\n\n\nfloat16\nHalf precision float: sign bit, 5 bits exponent, 10 bits mantissa\n\n\nfloat32\nSingle precision float: sign bit, 8 bits exponent, 23 bits mantissa\n\n\nfloat64\nDouble precision float: sign bit, 11 bits exponent, 52 bits mantissa\n\n\ncomplex_\nShorthand for complex128.\n\n\ncomplex64\nComplex number, represented by two 32-bit floats\n\n\ncomplex128\nComplex number, represented by two 64-bit floats\n\n\n\n\n\n\n배열의 속성을 지정해서 배열의 크기 혹은 데이터 타입을 정할 수 있다.\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx3 = np.random.randint(10, size=(3, 4, 5))\nprint(x3)\n\n[[[5 0 3 3 7]\n  [9 3 5 2 4]\n  [7 6 8 8 1]\n  [6 7 7 8 1]]\n\n [[5 9 8 9 4]\n  [3 0 3 5 0]\n  [2 3 8 1 3]\n  [3 3 7 0 1]]\n\n [[9 9 0 4 7]\n  [3 2 7 2 0]\n  [0 4 5 5 6]\n  [8 4 1 4 9]]]\n\n\nrandom.randint는 지정된 개수의 정수를 (0부터 시작) 랜덤하게 추출함\n\nprint(\"x3 ndim: \", x3.ndim)\nprint(\"x3 shape:\", x3.shape)\nprint(\"x3 size: \", x3.size)\n\nx3 ndim:  3\nx3 shape: (3, 4, 5)\nx3 size:  60\n\n\ndim: 배열의 차원, shape: 배열의 구조, size: 총 원소의 개수\n\nprint(\"dtype:\", x3.dtype)\nxx3 = np.array(x3, dtype='int32')\nprint(xx3.dtype)\nxx3 = np.array([ [[3,4],[4,5]],[[3,4],[2,1]] ] )\nprint(xx3[1,1,range(2)])\n\ndtype: int64\nint32\n[2 1]\n\n\ndtype 문을 이용하여 값의 유형을 지정\n\n\n\n일차원 배열\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx1 = np.random.randint(10, size=6)\nprint(x1)\n\n[5 0 3 3 7 9]\n\n\n\nx1[0]\n\n5\n\n\n\nx1[4]\n\n7\n\n\n\nx1[-1]\n\n9\n\n\n\nx1[-2]\n\n7\n\n\n인덱싱의 규칙은 리스트와 동일\n다차원 배열\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\nx2 = np.random.randint(10, size=(3, 4))\nprint(x2)\n\n[[5 0 3 3]\n [7 9 3 5]\n [2 4 7 6]]\n\n\n\nx2[0,0]\n\n5\n\n\n리스트와 다르게 2차원 인덱싱이 가능함\n\nx2[2,0]\n\n2\n\n\n\nprint(x2[range(2),0])\nprint(x2[0,range(2)])\nprint(x1[range(2),range(2)])\n\n[5 7]\n[5 0]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-25-3503418328f1&gt; in &lt;cell line: 3&gt;()\n      1 print(x2[range(2),0])\n      2 print(x2[0,range(2)])\n----&gt; 3 print(x1[range(2),range(2)])\n\nIndexError: too many indices for array: array is 1-dimensional, but 2 were indexed\n\n\n\n범위를 지정하는 경우 반드시 한 차원에서만 해야 함 (전체만 예외)\n\nprint(x2[range(2),range(2)])\nprint(x2[range(2),range(2)].shape)\n# 총 4개의 원소를 불러오려고 하나 두 개만 가져옴\n\nprint(x2[range(2),:][:,range(2)])\nprint(x2[range(2),:][:,range(2)].shape)\n# 영역을 설정할때는 반드시 쪼개서 해야 함\n\n[5 9]\n(2,)\n[[5 0]\n [7 9]]\n(2, 2)\n\n\n\nx2 = np.random.randint(10, size=(3, 4))\nx2[2,3] = 12\nx2[0:2,:][:,0:3] = np.array([[0,0,0],[2,2,2]])\nx2\n\narray([[ 0,  0,  0,  1],\n       [ 2,  2,  2,  4],\n       [ 7,  3,  2, 12]])\n\n\n값을 배열 단위로 입력하는 것도 가능하나 전체를 제외한 범위 지정의 경우 한 차원에서만 가능함\n주의. list와 달리 NumPy 배열은 고정 타입을 가진다. - 값의 유형이 같아야 한다는 의미\n\nimport numpy as np\nx1 = np.array([2,3,4])\nprint(x1)\n\nx2 = x1\nx2[0] = 4\nprint(x2)\n\n[2 3 4]\n[4 3 4]\n\n\n\n\n\n기본 접근 방법은 아래와 같다.\nx[start:stop:step] start:시작, stop-start:길이, step:잘라낼 배수\n\n### 1차원 하위 배열\n\n::: {#cell-59 .cell executionInfo='{\"elapsed\":383,\"status\":\"ok\",\"timestamp\":1725240822777,\"user\":{\"displayName\":\"김광수\",\"userId\":\"04260902725982947063\"},\"user_tz\":-540}' outputId='fae0094f-b468-4916-cb20-1d8d337986f2'}\n``` {.python .cell-code}\nx = np.arange(10)\nx\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n:::\n\nx[:5]\n\narray([0, 1, 2, 3, 4])\n\n\n\nx[5:]\n\narray([5, 6, 7, 8, 9])\n\n\n\nx[4:7]\n\narray([4, 5, 6])\n\n\n\nx[::2] # 2칸씩 뛰어서 반환\n\narray([0, 2, 4, 6, 8])\n\n\n\nx[1::2] #시작점을 첨자 1로 해서 2칸씩 뛰어서 반환\n\narray([1, 3, 5, 7, 9])\n\n\nstep이 음수일 때는 start와 stop이 기본값이 서로 바뀐다.\n시작점에서 뒤로 가는 것으로 이해해도 됨.\n\nx[::-1]\n\narray([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])\n\n\n\nx[5::-2] #첨자 5에서 시작해서 뒤로 감 (-2배수로 자름)\n\narray([5, 3, 1])\n\n\n\n\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx2 = np.random.randint(10, size=(3, 4))\nprint(x2)\n\n[[5 0 3 3]\n [7 9 3 5]\n [2 4 7 6]]\n\n\n\nx2[:2, :3]\n\narray([[5, 0, 3],\n       [7, 9, 3]])\n\n\n슬라이싱이 범위로 되는 것은 :을 사용했기 때문임\n\nx2[:3, ::2]\n\narray([[5, 3],\n       [7, 3],\n       [2, 7]])\n\n\n첫번째 첨자는 0에서 시작해 2까지, 두번째 처음부터 끝까지 가되 2배씩 자름\n\nx2[::-1, ::-1]\n#1차원, 2차원 모드 끝에서 앞으로 정렬\n\narray([[6, 7, 4, 2],\n       [5, 3, 9, 7],\n       [3, 3, 0, 5]])\n\n\n\n\n\nprint(x2[:, 0].shape)\n\n(3,)\n\n\n\nprint(x2[0, :])\n\n[5 0 3 3]\n\n\n\nprint(x2[0].shape)  # == x2[0, :]\n\n(4,)\n\n\n\n\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n\nx2_sub = x2[:2, :2]\nprint(x2_sub)\n\n[[99  0]\n [ 7  9]]\n\n\n\nx2_sub[0, 0] = 99\nprint(x2_sub)\n\n[[99  0]\n [ 7  9]]\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n여기에서 사본의 값이 바뀌는 것이 원래 배열에도 영향을 줌\n\n\n\n\nx2_sub_copy = x2[:2, :2].copy()\nprint(x2_sub_copy)\n\n[[99  0]\n [ 7  9]]\n\n\n\nx2_sub_copy[0, 0] = 42\nprint(x2_sub_copy)\n\n[[42  0]\n [ 7  9]]\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n이제 더이상 사본 배열이 원 배열에 영향을 안 줌\n\n\n\n\nreshape 메소드와 newaxis 메소드를 이용하여 배열의 구조를 바꿀 수 있다.\n\ngrid = np.arange(1, 10).reshape((3, 3))\nprint(grid)\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n\n\n기본 방식은 꺽쇠의 위치를 바꾸는 방식임에 유의\n\nx = np.array([1, 2, 3])\nprint(x)\nx.shape\n\n[1 2 3]\n\n\n(3,)\n\n\n\n# 행 벡터\nx.reshape((1, 3))\n\narray([[1, 2, 3]])\n\n\n\n# newaxis을 이용한 행 벡터\nprint(x[np.newaxis, :].shape)\n\n(1, 3)\n\n\n\n# 열 벡터\nx.reshape((3, 1))\n\narray([[1],\n       [2],\n       [3]])\n\n\n\n# newaxis을 이용한 열 벡터\nx[:, np.newaxis]\n\narray([[1],\n       [2],\n       [3]])\n\n\n\n\n\n여러 배열을 하나로 결합(배열 연결)하거나 그 반대로 하나의 배열을 여러 개의 배열로 분할(배열 분할)할 수 있다.\n\n\n배열 연결은 concatenate, vstack(vertical stack), hstack(horizontal stack)메소드를 이용하여 할 수 있다.\n\nimport numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 2, 1])\nnp.concatenate([x, y])\n\narray([1, 2, 3, 3, 2, 1])\n\n\n배열을 합칠때 최소 차원의 일치성이 필요함\n\nz = [99, 99, 99]\nprint(np.concatenate([x, y, z]))\n\n[ 1  2  3  3  2  1 99 99 99]\n\n\n\ngrid = np.array([[1, 2, 3],\n                 [4, 5, 6]])\nprint(grid)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 첫 번째 축: 두개의 배열을 합칠때 0(첫번째) 첨자를 늘림\nnp.concatenate([grid, grid], axis=0)\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [1, 2, 3],\n       [4, 5, 6]])\n\n\n\n# 두 번째 축: 두개의 배열을 합칠때 1(두번째) 첨자를 늘림\nnp.concatenate([grid, grid], axis=1)\n\narray([[1, 2, 3, 1, 2, 3],\n       [4, 5, 6, 4, 5, 6]])\n\n\n혼합된 차원 배열\n\nx = np.array([1, 2, 3])\ngrid = np.array([[9, 8, 7],\n                 [6, 5, 4]])\n\nnp.vstack([x, grid])\n\narray([[1, 2, 3],\n       [9, 8, 7],\n       [6, 5, 4]])\n\n\n수직축으로 통합, 0번 축을 늘림\n\ny = np.array([[99],\n              [99]])\nnp.hstack([grid, y])\n\narray([[ 9,  8,  7, 99],\n       [ 6,  5,  4, 99]])\n\n\n수평축으로 통합, 1번축을 늘림\n\n\n\n배열 분할은 split, vsplit, hsplit메소드를 이용한다.\n\nx = [1, 2, 3, 99, 99, 3, 2, 1]\nx1, x2, x3 = np.split(x, [2, 5])\nprint(x1, x2, x3)\n\n[1 2] [ 3 99 99] [3 2 1]\n\n\n2번째 위치, 5번째 위치가 분할점이 됨\n\ngrid = np.arange(16).reshape((4, 4))\ngrid\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\n\nupper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)\n\n[[0 1 2 3]\n [4 5 6 7]]\n[[ 8  9 10 11]\n [12 13 14 15]]\n\n\n수직축으로 2개로 쪼갬\n\nleft, right = np.hsplit(grid, [2])\nprint(left)\nprint(right)\n\n[[ 0  1]\n [ 4  5]\n [ 8  9]\n [12 13]]\n[[ 2  3]\n [ 6  7]\n [10 11]\n [14 15]]\n\n\n수평축으로 두개로 쪼갬\n\n\n\n\n인터프리터 언어에서 루프(반복문)를 이용한 연산은 매우 느리게 수행될 수 있다. 따라서 연산을 빠르게 하기 위해서는 벡터화(vectorized)연산을 사용해야 한다. 일반적으로 Python의 NumPy는 유니버설 함수(universal function, ufuncs)을 통해 구현된다.\n\n\n\nimport numpy as np\n\ndef compute_reciprocals(values):\n    output = np.empty(len(values)) #메모리 값을 불러옴#\n    for i in range(len(values)):\n        output[i] = 1.0 / values[i] #받은 배열 값의 역수를 계산\n    return output\n\n\nnp.random.seed(0)\n\nvalues = np.random.randint(1, 10, size=5)\nprint(values)\n\n[6 1 4 4 8]\n\n\n\nprint(compute_reciprocals(values))\nprint(1.0 / values) # 역수를 확인\n\n[0.16666667 1.         0.25       0.25       0.125     ]\n[0.16666667 1.         0.25       0.25       0.125     ]\n\n\n\nnp.arange(5) / np.arange(1, 6)\n# 각 원소별로 연산이 이루어짐\n\narray([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])\n\n\n\nx = np.arange(9).reshape((3, 3))\nprint(x)\n2 ** x\n\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\n\narray([[  1,   2,   4],\n       [  8,  16,  32],\n       [ 64, 128, 256]])\n\n\n\n\n\n\n\nNumPy의 ufuncs는 Python의 기본 산술 연산자를 사용한다.\n\nx = np.arange(4)\nprint(\"x     =\", x)\nprint(\"x + 5 =\", x + 5)\nprint(\"x - 5 =\", x - 5)\nprint(\"x * 2 =\", x * 2)\nprint(\"x / 2 =\", x / 2)\nprint(\"x // 2 =\", x // 2)  # floor division (나누고 나서 값을 버림, 3.45 -&gt; 3)\n\nx     = [0 1 2 3]\nx + 5 = [5 6 7 8]\nx - 5 = [-5 -4 -3 -2]\nx * 2 = [0 2 4 6]\nx / 2 = [0.  0.5 1.  1.5]\nx // 2 = [0 0 1 1]\n\n\n\nprint(\"-x     = \", -x)\nprint(\"x ** 2 = \", x ** 2)\nprint(\"x % 2  = \", x % 2)   # remainder (나누고 나서 남은 값을 반환, 5/4 -&gt;1)\n\n-x     =  [ 0 -1 -2 -3]\nx ** 2 =  [0 1 4 9]\nx % 2  =  [0 1 0 1]\n\n\n\n-(0.5*x + 1) ** 2\n\narray([-1.  , -2.25, -4.  , -6.25])\n\n\n다음은 NumPy에 구현된 산술 연산자이다.\n\n\n\n\n\n\n\n\nOperator\nEquivalent ufunc\nDescription\n\n\n\n\n+\nnp.add\nAddition (e.g., 1 + 1 = 2)\n\n\n-\nnp.subtract\nSubtraction (e.g., 3 - 2 = 1)\n\n\n-\nnp.negative\nUnary negation (e.g., -2)\n\n\n*\nnp.multiply\nMultiplication (e.g., 2 * 3 = 6)\n\n\n/\nnp.divide\nDivision (e.g., 3 / 2 = 1.5)\n\n\n//\nnp.floor_divide\nFloor division (e.g., 3 // 2 = 1)\n\n\n**\nnp.power\nExponentiation (e.g., 2 ** 3 = 8)\n\n\n%\nnp.mod\nModulus/remainder (e.g., 9 % 4 = 1)\n\n\n\n\n\n\nPython에 내장된 절대값 함수 abs도 사용할 수 있다.\n\nx = np.array([-2, -1, 0, 1, 2])\nabs(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\nnp.absolute(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\nnp.abs(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\n\n\n\ntheta = np.linspace(0, np.pi, 3)\n\n\nprint(\"theta      = \", theta)\nprint(\"sin(theta) = \", np.sin(theta))\nprint(\"cos(theta) = \", np.cos(theta))\nprint(\"tan(theta) = \", np.tan(theta))\n\ntheta      =  [0.         1.57079633 3.14159265]\nsin(theta) =  [0.0000000e+00 1.0000000e+00 1.2246468e-16]\ncos(theta) =  [ 1.000000e+00  6.123234e-17 -1.000000e+00]\ntan(theta) =  [ 0.00000000e+00  1.63312394e+16 -1.22464680e-16]\n\n\n\nx = [-1, 0, 1]\nprint(\"x         = \", x)\nprint(\"arcsin(x) = \", np.arcsin(x))\nprint(\"arccos(x) = \", np.arccos(x))\nprint(\"arctan(x) = \", np.arctan(x))\n\nx         =  [-1, 0, 1]\narcsin(x) =  [-1.57079633  0.          1.57079633]\narccos(x) =  [3.14159265 1.57079633 0.        ]\narctan(x) =  [-0.78539816  0.          0.78539816]\n\n\n\n\n\n\nx = [1, 2, 3]\nprint(\"x     =\", x)\nprint(\"e^x   =\", np.exp(x))\nprint(\"2^x   =\", np.power(2, x))\nprint(\"3^x   =\", np.power(3, x))\n\nx     = [1, 2, 3]\ne^x   = [ 2.71828183  7.3890561  20.08553692]\n2^x   = [2 4 8]\n3^x   = [ 3  9 27]\n\n\n\nx = [1, 2, 4, 10]\nprint(\"x        =\", x)\nprint(\"ln(x)    =\", np.log(x))\nprint(\"log2(x)  =\", np.log2(x))\nprint(\"log10(x) =\", np.log10(x))\n\nx        = [1, 2, 4, 10]\nln(x)    = [0.         0.69314718 1.38629436 2.30258509]\nlog2(x)  = [0.         1.         2.         3.32192809]\nlog10(x) = [0.         0.30103    0.60205999 1.        ]\n\n\n\n\n\n통계학에서 자주 사용되는 전문적인 함수는 scipy패키지의 special모듈을 사용해서 계산할 수 있다.\n\nfrom scipy import special\n\n\nx = [1, 5, 10]\nprint(\"gamma(x)     =\", special.gamma(x))\nprint(\"ln|gamma(x)| =\", special.gammaln(x))\nprint(\"beta(x, 2)   =\", special.beta(x, 2))\n\ngamma(x)     = [1.0000e+00 2.4000e+01 3.6288e+05]\nln|gamma(x)| = [ 0.          3.17805383 12.80182748]\nbeta(x, 2)   = [0.5        0.03333333 0.00909091]\n\n\n\n\n\n\n\n자료의 특성을 파악하는 첫 번째 단계는 요약 통계를 계산하는 것이다. NumPy에서는 다양한 내장 집계 함수를 제공한다.\n\n\n배열의 합은 내장함수 sum을 이용해서도 구할 수 있다.\n\nnp.random.seed(1)\n\nL = np.random.random(100)\nprint(L)\nsum(L)\n\n[4.17022005e-01 7.20324493e-01 1.14374817e-04 3.02332573e-01\n 1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01\n 3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01\n 2.04452250e-01 8.78117436e-01 2.73875932e-02 6.70467510e-01\n 4.17304802e-01 5.58689828e-01 1.40386939e-01 1.98101489e-01\n 8.00744569e-01 9.68261576e-01 3.13424178e-01 6.92322616e-01\n 8.76389152e-01 8.94606664e-01 8.50442114e-02 3.90547832e-02\n 1.69830420e-01 8.78142503e-01 9.83468338e-02 4.21107625e-01\n 9.57889530e-01 5.33165285e-01 6.91877114e-01 3.15515631e-01\n 6.86500928e-01 8.34625672e-01 1.82882773e-02 7.50144315e-01\n 9.88861089e-01 7.48165654e-01 2.80443992e-01 7.89279328e-01\n 1.03226007e-01 4.47893526e-01 9.08595503e-01 2.93614148e-01\n 2.87775339e-01 1.30028572e-01 1.93669579e-02 6.78835533e-01\n 2.11628116e-01 2.65546659e-01 4.91573159e-01 5.33625451e-02\n 5.74117605e-01 1.46728575e-01 5.89305537e-01 6.99758360e-01\n 1.02334429e-01 4.14055988e-01 6.94400158e-01 4.14179270e-01\n 4.99534589e-02 5.35896406e-01 6.63794645e-01 5.14889112e-01\n 9.44594756e-01 5.86555041e-01 9.03401915e-01 1.37474704e-01\n 1.39276347e-01 8.07391289e-01 3.97676837e-01 1.65354197e-01\n 9.27508580e-01 3.47765860e-01 7.50812103e-01 7.25997985e-01\n 8.83306091e-01 6.23672207e-01 7.50942434e-01 3.48898342e-01\n 2.69927892e-01 8.95886218e-01 4.28091190e-01 9.64840047e-01\n 6.63441498e-01 6.21695720e-01 1.14745973e-01 9.49489259e-01\n 4.49912133e-01 5.78389614e-01 4.08136803e-01 2.37026980e-01\n 9.03379521e-01 5.73679487e-01 2.87032703e-03 6.17144914e-01]\n\n\n48.58779276001459\n\n\n\nnp.sum(L)\n\n48.587792760014565\n\n\n합, 합연산은 배열의 차원과 관계없이 전체 원소의 합을 반환\nNumPy의 경우 연산이 컴파일된 코드에서 계산되기 때문에 계산시간을 단축할 수 있다.\n\nnp.random.seed(2)\n\nbig_array = np.random.rand(100)\n%timeit sum(big_array)\n%timeit np.sum(big_array)\n\n11.3 µs ± 636 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n4.74 µs ± 1.45 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\n시간이 훨씬 적게 걸림을 확인할 수 있음\n\nmin(big_array), max(big_array)\n\n(0.01301733669455063, 0.9938520114212729)\n\n\n\n%timeit min(big_array)\n%timeit np.min(big_array)\n\n9.38 µs ± 2.94 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n4.24 µs ± 495 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\nNumPy 배열의 객체는 자체 메서드를 가지고 있다.\n\nprint(big_array.min(), big_array.max(), big_array.sum())\n\n0.01301733669455063 0.9938520114212729 46.002824535219375\n\n\n일반적으로 .ftn 형태를 가지게 됨\n\n\n\n\nnp.random.seed(1)\nM = np.random.random((3, 4)) # 3*4 차원 #\nprint(M)\n\n[[4.17022005e-01 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n\n\n\nM.sum()\n\n4.250707092634627\n\n\n축의 지정을 통해 열별 계산을 할 수 있다. 열에 대한 축 지정은 axis=0를 이용한다.\n\nM.min(axis=0)\n\narray([1.46755891e-01, 9.23385948e-02, 1.14374817e-04, 3.02332573e-01])\n\n\naxis 지정은 연산이 이루어지는 축임, 이는 R과 규칙이 다름\n행별 계산은 axis=1을 이용한다.\n\nM.max(axis=1)\n\narray([0.72032449, 0.34556073, 0.6852195 ])\n\n\n\n\n\n다음은 NumPy에서 사용할 수 있는 함수의 목록을 나타낸다.\n\n\n\n\n\n\n\n\nFunction Name\nNaN-safe Version\nDescription\n\n\n\n\nnp.sum\nnp.nansum\nCompute sum of elements\n\n\nnp.prod\nnp.nanprod\nCompute product of elements\n\n\nnp.mean\nnp.nanmean\nCompute mean of elements\n\n\nnp.std\nnp.nanstd\nCompute standard deviation\n\n\nnp.var\nnp.nanvar\nCompute variance\n\n\nnp.min\nnp.nanmin\nFind minimum value\n\n\nnp.max\nnp.nanmax\nFind maximum value\n\n\nnp.argmin\nnp.nanargmin\nFind index of minimum value\n\n\nnp.argmax\nnp.nanargmax\nFind index of maximum value\n\n\nnp.median\nnp.nanmedian\nCompute median of elements\n\n\nnp.percentile\nnp.nanpercentile\nCompute rank-based statistics of elements\n\n\nnp.any\nN/A\nEvaluate whether any elements are true\n\n\nnp.all\nN/A\nEvaluate whether all elements are true\n\n\n\n\nprint(M)\nM[0,0] = np.log(0)\nprint(M)\nnp.max(M,axis=0)\n# -Inf 로 오류가 발생하지는 않으나 오류 발생시 np.nanmax 이용\n\n[[          -inf 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n[[          -inf 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n\n\nRuntimeWarning: divide by zero encountered in log\n  M[0,0] = np.log(0)\n\n\narray([0.39676747, 0.72032449, 0.41919451, 0.6852195 ])\n\n\n\n\n\n\nBroadcasting은 다른 크기의 배열에 이항 ufuncs함수(덧셈, 뺄셈, 곱셈등)를 적용하기 위한 규칙의 집합이다.\n\n\n일차원 배열\n\na = np.array([0, 1, 2])\nb = np.array([5, 5, 5])\nprint(a)\nprint(b)\nprint(a + b)\n\n[0 1 2]\n[5 5 5]\n[5 6 7]\n\n\n\na + 5 #배열과 상수의 연산은 각 원소와 상수의 연산으로 됨\n\narray([5, 6, 7])\n\n\n이차원 배열\n\nM = np.ones((3, 3))\nM\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nprint(M.shape)\nprint(a[0:2].shape)\nprint(M+a)\nprint(M+a[0:2])\n\n(3, 3)\n(2,)\n[[1. 2. 3.]\n [1. 2. 3.]\n [1. 2. 3.]]\n\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-125-2d77659103c9&gt; in &lt;cell line: 4&gt;()\n      2 print(a[0:2].shape)\n      3 print(M+a)\n----&gt; 4 print(M+a[0:2])\n\nValueError: operands could not be broadcast together with shapes (3,3) (2,) \n\n\n\n\na = np.arange(3)\nb = np.arange(3)[:,np.newaxis]\nprint(a)\nprint(b)\n\n[0 1 2]\n[[0]\n [1]\n [2]]\n\n\n1차원으로 (d,)와 2차원으로 (d,1)은 엄격히 구분됨\n\na + b\n# 이 경우 외적의 형태로 연산\n# a의 모든 원소와 b의 모든 원소들 간의 연산이 이루어짐\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n\na = np.arange(3)\naa = a[:,np.newaxis]\nprint(aa)\nprint(np.min(aa,axis=0))\n\n[[0]\n [1]\n [2]]\n[0]\n\n\n\n\n\n\n규칙 1: 두 배열의 차원 수가 다르면 더 작은 수의 차원을 가진 배열 형상의 차원 수를 늘린다 (이 때 1차원의 수를 1로 한다).\n규칙 2: 두 배열의 형상이 어떤 차원에서도 일치하지 않는다면 해당 차원의 형상이 1인 배열이 다른 형상과 일치하도록 늘린다.\n규칙 3: 임의의 차원에서 크기가 일치하지 않고 1도 아니라면 오류가 발생한다.\n\n\n\n1차원 배열에 2차원 배열 더하기\n\nM = np.ones((2, 3))\na = np.arange(3)\n\nprint(M)\nprint(a)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n[0 1 2]\n\n\n배열의 형상:\n\nM.shape = (2, 3)\na.shape = (3,)\n\n규칙 1을 따라 배열 a가 더 작은 차원을 가지므로 왼쪽을 1로 채운다:\n\nM.shape -&gt; (2, 3)\na.shape -&gt; (1, 3)\n\n규칙 2에 따라 첫 번째 차원이 일치하지 않으므로 차원을 일치하도록 늘린다:\n\nM.shape -&gt; (2, 3)\na.shape -&gt; (2, 3)\n\n\nprint(M)\nprint(a)\nprint(M+a)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n[0 1 2]\n[[1. 2. 3.]\n [1. 2. 3.]]\n\n\n[0,1,2]가 반복될 때, 열 단위로 반복됨에 주의\n\n\n\n두 배열 모두 broadcasting이 필요한 예제\n\na = np.arange(3).reshape((3, 1))\nb = np.arange(3)\n\nprint(a)\nprint(b)\n\n[[0]\n [1]\n [2]]\n[0 1 2]\n\n\n배열의 형상: - a.shape = (3, 1) - b.shape = (3,)\n규칙 1을 따라 b의 형상에 1을 덧붙여야 한다:\n\na.shape -&gt; (3, 1)\nb.shape -&gt; (1, 3)\n\n규칙 2을 따라 각 차원을 그에 대응하는 다른 배열의 크기에 일치하도록 늘린다:\n\na.shape -&gt; (3, 3)\nb.shape -&gt; (3, 3)\n\n\na + b\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n확장은 열 단위로 이루어짐\n\n\n\n두 개의 배열이 호환되지 않는 경우\n\nM = np.ones((3, 2))\na = np.arange(3)\n\nprint(M)\nprint(a)\n\n[[1. 1.]\n [1. 1.]\n [1. 1.]]\n[0 1 2]\n\n\n배열 형상:\n\nM.shape = (3, 2)\na.shape = (3,)\n\n규칙 1:\n\nM.shape -&gt; (3, 2)\na.shape -&gt; (1, 3)\n\n규칙 2:\n\nM.shape -&gt; (3, 2)\na.shape -&gt; (3, 3)\n\n규칙 3:\n\nM + a\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-138-8cac1d547906&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 M + a\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n\n\n\nnp.newaxis 를 이용한 형상 변경:\n\nprint(a[:, np.newaxis].shape)\nM.shape\n\n(3, 1)\n\n\n(3, 2)\n\n\na: (3, ) -&gt; (3,1) -&gt; (3,2) b: (3, 2)\n\nprint(M)\nprint(a[:, np.newaxis])\nM + a[:, np.newaxis]\n\n[[1. 1.]\n [1. 1.]\n [1. 1.]]\n[[0]\n [1]\n [2]]\n\n\narray([[1., 1.],\n       [2., 2.],\n       [3., 3.]])\n\n\n\na[:, np.newaxis]\n\narray([[0],\n       [1],\n       [2]])\n\n\n참고. broadcasting 규칙은 모든 이항 ufunc에 적용이 된다.\n\n\n\n\n다음의 예는 통계학에서 자주 사용되는 배열을 표준화(Standardization)하는 것이다. \\[ Z = \\frac{X - \\bar{X}}{S},\\] 식에서 \\(\\bar{X}\\)는 평균, \\(S\\)는 표준편차를 나타낸다.\n\nimport numpy as np\nnp.random.seed(1)\n\nX = np.random.random((10, 3))\nprint(X)\n\n[[4.17022005e-01 7.20324493e-01 1.14374817e-04]\n [3.02332573e-01 1.46755891e-01 9.23385948e-02]\n [1.86260211e-01 3.45560727e-01 3.96767474e-01]\n [5.38816734e-01 4.19194514e-01 6.85219500e-01]\n [2.04452250e-01 8.78117436e-01 2.73875932e-02]\n [6.70467510e-01 4.17304802e-01 5.58689828e-01]\n [1.40386939e-01 1.98101489e-01 8.00744569e-01]\n [9.68261576e-01 3.13424178e-01 6.92322616e-01]\n [8.76389152e-01 8.94606664e-01 8.50442114e-02]\n [3.90547832e-02 1.69830420e-01 8.78142503e-01]]\n\n\n\nXmean = X.mean(0)\nXmean\n\narray([0.43434437, 0.45032206, 0.42167713])\n\n\n\nX_centered = X - Xmean\n\n\nX_centered.mean(0)\n\narray([ 3.33066907e-17, -4.44089210e-17, -1.11022302e-17])\n\n\n\nXstd = X.std(0)\nXstd\n\narray([0.30363266, 0.26823818, 0.32697313])\n\n\n\nXstand = X_centered/Xstd\n\n\nXstand.std(0)\n\narray([1., 1., 1.])\n\n\n\nXstand.mean(0)\n\narray([ 1.33226763e-16, -1.77635684e-16,  2.22044605e-17])\n\n\n\n\n\n\nNumPy는 배열 내의 값을 검사하고 조작하는 데 부울 마스크를 사용한다. 여기서, 마스킹은 특정 기준에 따라 배열의 값을 추출하거나 수정, 계산, 조작하는 것을 의미한다.\n\n\n\nx = np.array([1, 2, 3, 4, 5])\nprint(x)\n\n[1 2 3 4 5]\n\n\n\nx &lt; 3  # less than\n\narray([ True,  True, False, False, False])\n\n\n\nx &gt; 3  # greater than\n\narray([False, False, False,  True,  True])\n\n\n\nx &lt;= 3  # less than or equal\n\narray([ True,  True,  True, False, False])\n\n\n\nx &gt;= 3  # greater than or equal\n\narray([False, False,  True,  True,  True])\n\n\n\nx != 3  # not equal\n\narray([ True,  True, False,  True,  True])\n\n\n\nx == 3  # equal\n\narray([False, False,  True, False, False])\n\n\n두 배열을 항목별로 비교할 수 있으며 복합 표현식을 적용할 수도 있다.\n\n(2 * x) == (x ** 2)\n\narray([False,  True, False, False, False])\n\n\n비교 연산자와 그에 대응하는 ufunc함수:\nOperator | Equivalent ufunc || Operator | Equivalent ufunc |\n|—————|———————||—————|———————| |== |np.equal ||!= |np.not_equal | |&lt; |np.less ||&lt;= |np.less_equal | |&gt; |np.greater ||&gt;= |np.greater_equal |\n2차원 예제:\n\nrng = np.random.RandomState(100) # random seed 와 비슷하게 기능 #\nx = rng.randint(10, size=(3, 4))\nx\n\narray([[8, 8, 3, 7],\n       [7, 0, 4, 2],\n       [5, 2, 2, 2]])\n\n\n\nx &lt; 6\n\narray([[False, False,  True, False],\n       [False,  True,  True,  True],\n       [ True,  True,  True,  True]])\n\n\n\n\n\n부울 배열에서 참인 요소의 개수를 셀 수 있다.\n\n# how many values less than 6?\nnp.count_nonzero(x &lt; 6)\n\n8\n\n\n\nnp.sum(x &lt; 6)\n\n8\n\n\n\n# 각 행별로 6보다 작은 값들을 세어봄 (연산은 열단위로 이루어짐)\nprint(np.sum(x &lt; 6, axis=1))\nprint(x&lt;6)\n\n[1 3 4]\n[[False False  True False]\n [False  True  True  True]\n [ True  True  True  True]]\n\n\n\nx == 6\n\narray([[False, False, False, False],\n       [False, False, False, False],\n       [False, False, False, False]])\n\n\n값 중 하나라도 참이 있는 지나 모든 값이 참인지 빠르게 확인할 수 있다.\n\n# are there any values greater than 8?\nnp.any(x &gt; 8)\n\nFalse\n\n\n\n# are there any values less than zero?\nnp.any(x &lt; 0)\n\nFalse\n\n\n\n# are all values less than 10?\nnp.all(x &lt; 10)\n\nTrue\n\n\n\n# are all values equal to 6?\nnp.all(x == 6)\n\nFalse\n\n\n\n# are all values in each row less than 8?\nnp.all(x &lt; 8, axis=1)\n\narray([False,  True,  True])\n\n\n부울연산자는 동시에 여러식을 비교할때 사용하는 연산자이다.\n\nnp.sum((x &gt; 3) & (x &lt; 8))\n\n4\n\n\n다음은 부울 연산자와 그에 상응하는 ufuncs이다.\nOperator | Equivalent ufunc || Operator | Equivalent ufunc |\n|—————|———————||—————|———————| |& |np.bitwise_and ||| |np.bitwise_or | |^ |np.bitwise_xor ||~ |np.bitwise_not |\n\n\n\n부울 배열을 마스크로 사용해 데이터 자체의 특정 부분 집합을 선택할 수 있다.\n\nx\n\narray([[8, 8, 3, 7],\n       [7, 0, 4, 2],\n       [5, 2, 2, 2]])\n\n\n\nx &lt; 5\n\narray([[False, False,  True, False],\n       [False,  True,  True,  True],\n       [False,  True,  True,  True]])\n\n\n부울 배열을 인덱스로 사용 (마스킹 연산):\n\nx[x &lt; 5]\n\narray([3, 0, 4, 2, 2, 2, 2])\n\n\n\n\n\nand/or는 전체 객체에 대해 단일 부울 평가를 수행한다.\n\nbool(42), bool(0)\n\n(True, False)\n\n\nbool 문은 0이 거짓, 양수는 참으로 반환\n\nbool(42 and 0)\n\nFalse\n\n\n\nbool(42 or 0)\n\nTrue\n\n\n&/|는 객체의 내용에 대해 여러 번 부울 평가를 수행한다.\n\nbin(42)\n\n'0b101010'\n\n\n\nbin(59)\n\n'0b111011'\n\n\n\nbin(42 & 59) # 각 원소별로 평가\n\n'0b101010'\n\n\n\nbin(42 | 59) # 각 원소별로 평가\n\n'0b111011'\n\n\n\nA = np.array([1, 0, 1, 0, 1, 0], dtype=bool)\nB = np.array([1, 1, 1, 0, 1, 1], dtype=bool)\nA | B\n\narray([ True,  True,  True, False,  True,  True])\n\n\n\nx = np.arange(10)\n(x &gt; 4) & (x &lt; 8)\n\narray([False, False, False, False, False,  True,  True,  True, False,\n       False])\n\n\n주의. or와 and연산자는 전체 객체에 대해 단일 부울 평가를 수행한다.\n\nA or B\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-180-ea2c97d9d9ee&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 A or B\n\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n\n\n\n\n(x &gt; 4) & (x &lt; 8)\n\narray([False, False, False, False, False,  True,  True,  True, False,\n       False])\n\n\n\n\n\n\nNumPy 배열의 팬시 인덱싱은 정수 리스트(혹은 배열)를 이용하여 여러 개를 동시에 선택하는 방식이다.\n\n\n\nrand = np.random.RandomState(42)\nx = rand.randint(100, size=10)\nprint(x)\n\n[51 92 14 71 60 20 82 86 74 74]\n\n\n세 개의 다른 요소에 접근할 수 있다.\n\n[x[3], x[7], x[2]]\n\n[71, 86, 14]\n\n\n인덱스의 단일 리스트나 배열을 전달해 접근할 수 있다.\n\nx[x &gt; 70]\n\narray([92, 71, 82, 86, 74, 74])\n\n\n\nind = np.where(x&gt;70)[0]\nind\n\narray([1, 3, 6, 7, 8, 9])\n\n\n\nx[ind]\n\narray([92, 71, 82, 86, 74, 74])\n\n\n\nind = [3, 7, 4]\nx[ind]\n\narray([71, 86, 60])\n\n\n펜시 인덱싱을 이용하면 인덱스 배열의 형상을 반영할 수 있다.\n\nind = np.array([[3, 7],\n                [4, 5]])\nprint(x)\nx[ind]\n\n[51 92 14 71 60 20 82 86 74 74]\n\n\narray([[71, 86],\n       [60, 20]])\n\n\nindex로 형상이 따라가게 됨\n다차원 예제:\n\nX = np.arange(12).reshape((3, 4))\nX\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\nrow = np.array([0, 1, 2])\ncol = np.array([2, 1, 3])\nX[row, col]\n\narray([ 2,  5, 11])\n\n\n2차원 인덱싱을 하고 있음에 유의\n\nX[row[:,np.newaxis], col] #[0,1,2]^T [2,1,3]: 첨자행렬#\n\narray([[ 2,  1,  3],\n       [ 6,  5,  7],\n       [10,  9, 11]])\n\n\n(0,0) 원소의 인텍싱은 (0,2), (2,2) 원소의 인텍싱은 (2,3)과 같이 됨\n\nprint(row)\nrow[:,np.newaxis]  #[0,1,2]^T [2,1,3]: 왼쪽#\n\n[0 1 2]\n\n\narray([[0],\n       [1],\n       [2]])\n\n\n\ncol #[0,1,2]^T [2,1,3]: 오른쪽#\n\narray([2, 1, 3])\n\n\n\n\n\n\nprint(X)\n\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n\n\nX[2, [2, 0, 1]]\n\narray([10,  8,  9])\n\n\n\nX[1:, [2, 0, 1]]\n\narray([[ 6,  4,  5],\n       [10,  8,  9]])\n\n\n2차원 인덱싱 방법\n\nrow = np.array([0, 1, 2])\nprint(row[:, np.newaxis])\n\nprint(X)\nmask = np.array([1, 0, 1, 0], dtype=bool) # (0,2) 만 유효함\nX[row[:, np.newaxis], mask] #[0,1,2]^T [0,2]\n\n[[0]\n [1]\n [2]]\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n\narray([[ 0,  2],\n       [ 4,  6],\n       [ 8, 10]])\n\n\n\nmask #[0,2] 와 동일 #\n\narray([ True, False,  True, False])\n\n\n\n\n\n\nx = np.arange(10)\ni = np.array([2, 1, 8, 4])\nx[i] = 99\nprint(x)\n\n[ 0 99 99  3 99  5  6  7 99  9]\n\n\n\nx[i] -= 10\nprint(x)\n\n[ 0 89 89  3 89  5  6  7 89  9]\n\n\n다음의 예는 반복되는 인덱스를 사용했을 때의 결과이다. 먼저 x[0] = 4가 할당되고 x[1] = 6이 할당된다.\n\nx = np.zeros(10)\nx[[0, 1]] = [4, 6]\nprint(x)\n\n[4. 6. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ni = [2, 3, 3, 4, 4, 4, 5]\nx[i] += 1\nprint(x)\n## 중복이 영향을 안줌 (위치만 확인하고 비중은 없음)\n\n[4. 6. 1. 1. 1. 1. 0. 0. 0. 0.]\n\n\n\nx = np.zeros(10)\nprint(i)\nnp.add.at(x, i, 1)\nprint(x)\n# 중복이 영향을 주는 경우\n\n[2, 3, 3, 4, 4, 4, 5]\n[0. 0. 1. 2. 3. 1. 0. 0. 0. 0.]\n\n\n\n\n\n\nNumPy에서는 배열의 값을 정렬하는 알고리즘을 제공한다.\n\n\n기본적으로 퀵 정렬(quick sorts) 알고리즘을 사용한다.\n\nx = np.array([2, 1, 4, 3, 5])\nnp.sort(x)\n\narray([1, 2, 3, 4, 5])\n\n\n\nx.sort()\nprint(x)\n\n[1 2 3 4 5]\n\n\n참고. 옵션을 사용하면 병합정렬(mergesort)와 힙정렬(heapsort)도 사용할 수 있다 (알고리즘의 구분).\n정렬된 요소의 인덱스를 반환\n\nx = np.array([2, 1, 4, 3, 5])\ni = np.argsort(x)\nprint(i)\n\n[1 0 3 2 4]\n\n\n\nx[i]\n\narray([1, 2, 3, 4, 5])\n\n\n\n\n\n\nrand = np.random.RandomState(42)\nX = rand.randint(0, 10, (4, 6))\nprint(X)\n\n[[6 3 7 4 6 9]\n [2 6 7 4 3 7]\n [7 2 5 4 1 7]\n [5 1 4 0 9 5]]\n\n\n\n# sort each column of X\nnp.sort(X, axis=0)\n\narray([[2, 1, 4, 0, 1, 5],\n       [5, 2, 5, 4, 3, 7],\n       [6, 3, 7, 4, 6, 7],\n       [7, 6, 7, 4, 9, 9]])\n\n\n\n# sort each row of X\nnp.sort(X, axis=1)\n\narray([[3, 4, 6, 6, 7, 9],\n       [2, 3, 4, 6, 7, 7],\n       [1, 2, 4, 5, 7, 7],\n       [0, 1, 4, 5, 5, 9]])\n\n\n\n\n\n\n배열과 숫자 K를 취해 새로운 배열을 반환할 수 있다. 이때, K개의 가장 작은 값이 왼쪽에 있고 오른쪽에는 나머지 값이 채워진다. 순서는 임의로 정해진다.\n\nx = np.array([7, 2, 3, 1, 6, 5, 4])\nprint(np.partition(x, 2))\n\n[1 2 3 7 6 5 4]\n\n\n(2,1,3) / (4,6,5,7) = (1,2,3) / (4,5,6,7)\n참고. 인덱스를 반환하는 np.argpartition 함수가 있다."
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#python-list를-이용한-numpy-배열-만들기",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#python-list를-이용한-numpy-배열-만들기",
    "title": "P02_Numpy",
    "section": "",
    "text": "가장 기본적으로 NumPy배열을 생성하는 방법은 리스트를 이용하는 것이다.\n\nnp.array([1, 4, 2, 5, 3])\n\narray([1, 4, 2, 5, 3])\n\n\n주의. list와 달리 NumPy는 배열의 모든 요소가 같은 타입이어야 한다.\n\nnp.array([3.14, 4, 2, 3])\n\narray([3.14, 4.  , 2.  , 3.  ])\n\n\n참고. dtype키워드를 사용하면 데이터 타입을 설정할 수 있다.\n\nnp.array([1, 2, 3, 4], dtype='float32')\n\narray([1., 2., 3., 4.], dtype=float32)\n\n\n참고. 리스트와 달리 NumPy 배열은 명시적으로 다차원이 가능하다. 내부 리스트는 결과로 얻은 이차원 배열의 행으로 취급된다.\n\nnp.array([range(i, i + 3) for i in [2, 4, 6]])\n\narray([[2, 3, 4],\n       [4, 5, 6],\n       [6, 7, 8]])\n\n\nrange(2,5), range(4,7), range(6,9)를 각각 행 구조로 입력함"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy에-내장된-메소드를-사용하여-배열-만들기",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy에-내장된-메소드를-사용하여-배열-만들기",
    "title": "P02_Numpy",
    "section": "",
    "text": "다음의 예제들은 내장된 메소드를 이용하여 NumPy배열을 만드는 방법을 나타낸다.\n\nnp.zeros(10, dtype=int)\n\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nnp.ones, np.zeros 는 모든 원소의 값을 0이나 1로 하고 차원과 값의 유형을 지정한다.\n\nnp.ones((3, 5), dtype=float)\n\narray([[1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1.]])\n\n\n\nnp.full((3, 5), 3.14)\n\narray([[3.14, 3.14, 3.14, 3.14, 3.14],\n       [3.14, 3.14, 3.14, 3.14, 3.14],\n       [3.14, 3.14, 3.14, 3.14, 3.14]])\n\n\n0이나 1이 아닌 특정값을 채우고 싶다면 이 구문을 이용\n\nnp.arange(0, 20, 2)\n\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\n\n\n\nnp.linspace(0, 1, 5)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n\n그리드를 잡고 싶을 때 이용, 1부터 1까지 5개의 값으로 분할\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nIdentity 행렬을 만듬\n\nnp.empty(1)\n\narray([1.])\n\n\n참고. np.empty는 해당 메모리 위치에 이미 존재하고 있는 값으로 채운다. 메모리 번호를 알고 있어야 함"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-표준-데이터-타입",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-표준-데이터-타입",
    "title": "P02_Numpy",
    "section": "",
    "text": "NumPy는 C로 구현되어 있기 때문에 NumPy의 데이터 타입은 C와 Fortran언어 혹은 관련된 다른언어와 비슷하다.\n\n\n\n\n\n\n\nData type\nDescription\n\n\n\n\nbool_\nBoolean (True or False) stored as a byte\n\n\nint_\nDefault integer type (same as C long; normally either int64 or int32)\n\n\nintc\nIdentical to C int (normally int32 or int64)\n\n\nintp\nInteger used for indexing (same as C ssize_t; normally either int32 or int64)\n\n\nint8\nByte (-128 to 127)\n\n\nint16\nInteger (-32768 to 32767)\n\n\nint32\nInteger (-2147483648 to 2147483647)\n\n\nint64\nInteger (-9223372036854775808 to 9223372036854775807)\n\n\nuint8\nUnsigned integer (0 to 255)\n\n\nuint16\nUnsigned integer (0 to 65535)\n\n\nuint32\nUnsigned integer (0 to 4294967295)\n\n\nuint64\nUnsigned integer (0 to 18446744073709551615)\n\n\nfloat_\nShorthand for float64.\n\n\nfloat16\nHalf precision float: sign bit, 5 bits exponent, 10 bits mantissa\n\n\nfloat32\nSingle precision float: sign bit, 8 bits exponent, 23 bits mantissa\n\n\nfloat64\nDouble precision float: sign bit, 11 bits exponent, 52 bits mantissa\n\n\ncomplex_\nShorthand for complex128.\n\n\ncomplex64\nComplex number, represented by two 32-bit floats\n\n\ncomplex128\nComplex number, represented by two 64-bit floats"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-배열-속성-지정",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-배열-속성-지정",
    "title": "P02_Numpy",
    "section": "",
    "text": "배열의 속성을 지정해서 배열의 크기 혹은 데이터 타입을 정할 수 있다.\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx3 = np.random.randint(10, size=(3, 4, 5))\nprint(x3)\n\n[[[5 0 3 3 7]\n  [9 3 5 2 4]\n  [7 6 8 8 1]\n  [6 7 7 8 1]]\n\n [[5 9 8 9 4]\n  [3 0 3 5 0]\n  [2 3 8 1 3]\n  [3 3 7 0 1]]\n\n [[9 9 0 4 7]\n  [3 2 7 2 0]\n  [0 4 5 5 6]\n  [8 4 1 4 9]]]\n\n\nrandom.randint는 지정된 개수의 정수를 (0부터 시작) 랜덤하게 추출함\n\nprint(\"x3 ndim: \", x3.ndim)\nprint(\"x3 shape:\", x3.shape)\nprint(\"x3 size: \", x3.size)\n\nx3 ndim:  3\nx3 shape: (3, 4, 5)\nx3 size:  60\n\n\ndim: 배열의 차원, shape: 배열의 구조, size: 총 원소의 개수\n\nprint(\"dtype:\", x3.dtype)\nxx3 = np.array(x3, dtype='int32')\nprint(xx3.dtype)\nxx3 = np.array([ [[3,4],[4,5]],[[3,4],[2,1]] ] )\nprint(xx3[1,1,range(2)])\n\ndtype: int64\nint32\n[2 1]\n\n\ndtype 문을 이용하여 값의 유형을 지정"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-인덱싱-단일-요소에-접근하기",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-인덱싱-단일-요소에-접근하기",
    "title": "P02_Numpy",
    "section": "",
    "text": "일차원 배열\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx1 = np.random.randint(10, size=6)\nprint(x1)\n\n[5 0 3 3 7 9]\n\n\n\nx1[0]\n\n5\n\n\n\nx1[4]\n\n7\n\n\n\nx1[-1]\n\n9\n\n\n\nx1[-2]\n\n7\n\n\n인덱싱의 규칙은 리스트와 동일\n다차원 배열\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\nx2 = np.random.randint(10, size=(3, 4))\nprint(x2)\n\n[[5 0 3 3]\n [7 9 3 5]\n [2 4 7 6]]\n\n\n\nx2[0,0]\n\n5\n\n\n리스트와 다르게 2차원 인덱싱이 가능함\n\nx2[2,0]\n\n2\n\n\n\nprint(x2[range(2),0])\nprint(x2[0,range(2)])\nprint(x1[range(2),range(2)])\n\n[5 7]\n[5 0]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-25-3503418328f1&gt; in &lt;cell line: 3&gt;()\n      1 print(x2[range(2),0])\n      2 print(x2[0,range(2)])\n----&gt; 3 print(x1[range(2),range(2)])\n\nIndexError: too many indices for array: array is 1-dimensional, but 2 were indexed\n\n\n\n범위를 지정하는 경우 반드시 한 차원에서만 해야 함 (전체만 예외)\n\nprint(x2[range(2),range(2)])\nprint(x2[range(2),range(2)].shape)\n# 총 4개의 원소를 불러오려고 하나 두 개만 가져옴\n\nprint(x2[range(2),:][:,range(2)])\nprint(x2[range(2),:][:,range(2)].shape)\n# 영역을 설정할때는 반드시 쪼개서 해야 함\n\n[5 9]\n(2,)\n[[5 0]\n [7 9]]\n(2, 2)\n\n\n\nx2 = np.random.randint(10, size=(3, 4))\nx2[2,3] = 12\nx2[0:2,:][:,0:3] = np.array([[0,0,0],[2,2,2]])\nx2\n\narray([[ 0,  0,  0,  1],\n       [ 2,  2,  2,  4],\n       [ 7,  3,  2, 12]])\n\n\n값을 배열 단위로 입력하는 것도 가능하나 전체를 제외한 범위 지정의 경우 한 차원에서만 가능함\n주의. list와 달리 NumPy 배열은 고정 타입을 가진다. - 값의 유형이 같아야 한다는 의미\n\nimport numpy as np\nx1 = np.array([2,3,4])\nprint(x1)\n\nx2 = x1\nx2[0] = 4\nprint(x2)\n\n[2 3 4]\n[4 3 4]"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-슬라이싱-하위-배열에-접근하기",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-슬라이싱-하위-배열에-접근하기",
    "title": "P02_Numpy",
    "section": "",
    "text": "기본 접근 방법은 아래와 같다.\nx[start:stop:step] start:시작, stop-start:길이, step:잘라낼 배수\n\n### 1차원 하위 배열\n\n::: {#cell-59 .cell executionInfo='{\"elapsed\":383,\"status\":\"ok\",\"timestamp\":1725240822777,\"user\":{\"displayName\":\"김광수\",\"userId\":\"04260902725982947063\"},\"user_tz\":-540}' outputId='fae0094f-b468-4916-cb20-1d8d337986f2'}\n``` {.python .cell-code}\nx = np.arange(10)\nx\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n:::\n\nx[:5]\n\narray([0, 1, 2, 3, 4])\n\n\n\nx[5:]\n\narray([5, 6, 7, 8, 9])\n\n\n\nx[4:7]\n\narray([4, 5, 6])\n\n\n\nx[::2] # 2칸씩 뛰어서 반환\n\narray([0, 2, 4, 6, 8])\n\n\n\nx[1::2] #시작점을 첨자 1로 해서 2칸씩 뛰어서 반환\n\narray([1, 3, 5, 7, 9])\n\n\nstep이 음수일 때는 start와 stop이 기본값이 서로 바뀐다.\n시작점에서 뒤로 가는 것으로 이해해도 됨.\n\nx[::-1]\n\narray([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])\n\n\n\nx[5::-2] #첨자 5에서 시작해서 뒤로 감 (-2배수로 자름)\n\narray([5, 3, 1])\n\n\n\n\n\nnp.random.seed(0)  # 재현 가능성을 위한 시드 값\n\nx2 = np.random.randint(10, size=(3, 4))\nprint(x2)\n\n[[5 0 3 3]\n [7 9 3 5]\n [2 4 7 6]]\n\n\n\nx2[:2, :3]\n\narray([[5, 0, 3],\n       [7, 9, 3]])\n\n\n슬라이싱이 범위로 되는 것은 :을 사용했기 때문임\n\nx2[:3, ::2]\n\narray([[5, 3],\n       [7, 3],\n       [2, 7]])\n\n\n첫번째 첨자는 0에서 시작해 2까지, 두번째 처음부터 끝까지 가되 2배씩 자름\n\nx2[::-1, ::-1]\n#1차원, 2차원 모드 끝에서 앞으로 정렬\n\narray([[6, 7, 4, 2],\n       [5, 3, 9, 7],\n       [3, 3, 0, 5]])\n\n\n\n\n\nprint(x2[:, 0].shape)\n\n(3,)\n\n\n\nprint(x2[0, :])\n\n[5 0 3 3]\n\n\n\nprint(x2[0].shape)  # == x2[0, :]\n\n(4,)\n\n\n\n\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n\nx2_sub = x2[:2, :2]\nprint(x2_sub)\n\n[[99  0]\n [ 7  9]]\n\n\n\nx2_sub[0, 0] = 99\nprint(x2_sub)\n\n[[99  0]\n [ 7  9]]\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n여기에서 사본의 값이 바뀌는 것이 원래 배열에도 영향을 줌\n\n\n\n\nx2_sub_copy = x2[:2, :2].copy()\nprint(x2_sub_copy)\n\n[[99  0]\n [ 7  9]]\n\n\n\nx2_sub_copy[0, 0] = 42\nprint(x2_sub_copy)\n\n[[42  0]\n [ 7  9]]\n\n\n\nprint(x2)\n\n[[99  0  3  3]\n [ 7  9  3  5]\n [ 2  4  7  6]]\n\n\n이제 더이상 사본 배열이 원 배열에 영향을 안 줌"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-재구조화",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-재구조화",
    "title": "P02_Numpy",
    "section": "",
    "text": "reshape 메소드와 newaxis 메소드를 이용하여 배열의 구조를 바꿀 수 있다.\n\ngrid = np.arange(1, 10).reshape((3, 3))\nprint(grid)\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n\n\n기본 방식은 꺽쇠의 위치를 바꾸는 방식임에 유의\n\nx = np.array([1, 2, 3])\nprint(x)\nx.shape\n\n[1 2 3]\n\n\n(3,)\n\n\n\n# 행 벡터\nx.reshape((1, 3))\n\narray([[1, 2, 3]])\n\n\n\n# newaxis을 이용한 행 벡터\nprint(x[np.newaxis, :].shape)\n\n(1, 3)\n\n\n\n# 열 벡터\nx.reshape((3, 1))\n\narray([[1],\n       [2],\n       [3]])\n\n\n\n# newaxis을 이용한 열 벡터\nx[:, np.newaxis]\n\narray([[1],\n       [2],\n       [3]])"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-연결-및-분할",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-연결-및-분할",
    "title": "P02_Numpy",
    "section": "",
    "text": "여러 배열을 하나로 결합(배열 연결)하거나 그 반대로 하나의 배열을 여러 개의 배열로 분할(배열 분할)할 수 있다.\n\n\n배열 연결은 concatenate, vstack(vertical stack), hstack(horizontal stack)메소드를 이용하여 할 수 있다.\n\nimport numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 2, 1])\nnp.concatenate([x, y])\n\narray([1, 2, 3, 3, 2, 1])\n\n\n배열을 합칠때 최소 차원의 일치성이 필요함\n\nz = [99, 99, 99]\nprint(np.concatenate([x, y, z]))\n\n[ 1  2  3  3  2  1 99 99 99]\n\n\n\ngrid = np.array([[1, 2, 3],\n                 [4, 5, 6]])\nprint(grid)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 첫 번째 축: 두개의 배열을 합칠때 0(첫번째) 첨자를 늘림\nnp.concatenate([grid, grid], axis=0)\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [1, 2, 3],\n       [4, 5, 6]])\n\n\n\n# 두 번째 축: 두개의 배열을 합칠때 1(두번째) 첨자를 늘림\nnp.concatenate([grid, grid], axis=1)\n\narray([[1, 2, 3, 1, 2, 3],\n       [4, 5, 6, 4, 5, 6]])\n\n\n혼합된 차원 배열\n\nx = np.array([1, 2, 3])\ngrid = np.array([[9, 8, 7],\n                 [6, 5, 4]])\n\nnp.vstack([x, grid])\n\narray([[1, 2, 3],\n       [9, 8, 7],\n       [6, 5, 4]])\n\n\n수직축으로 통합, 0번 축을 늘림\n\ny = np.array([[99],\n              [99]])\nnp.hstack([grid, y])\n\narray([[ 9,  8,  7, 99],\n       [ 6,  5,  4, 99]])\n\n\n수평축으로 통합, 1번축을 늘림\n\n\n\n배열 분할은 split, vsplit, hsplit메소드를 이용한다.\n\nx = [1, 2, 3, 99, 99, 3, 2, 1]\nx1, x2, x3 = np.split(x, [2, 5])\nprint(x1, x2, x3)\n\n[1 2] [ 3 99 99] [3 2 1]\n\n\n2번째 위치, 5번째 위치가 분할점이 됨\n\ngrid = np.arange(16).reshape((4, 4))\ngrid\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\n\nupper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)\n\n[[0 1 2 3]\n [4 5 6 7]]\n[[ 8  9 10 11]\n [12 13 14 15]]\n\n\n수직축으로 2개로 쪼갬\n\nleft, right = np.hsplit(grid, [2])\nprint(left)\nprint(right)\n\n[[ 0  1]\n [ 4  5]\n [ 8  9]\n [12 13]]\n[[ 2  3]\n [ 6  7]\n [10 11]\n [14 15]]\n\n\n수평축으로 두개로 쪼갬"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-배열-연산-유니버설-함수",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#numpy-배열-연산-유니버설-함수",
    "title": "P02_Numpy",
    "section": "",
    "text": "인터프리터 언어에서 루프(반복문)를 이용한 연산은 매우 느리게 수행될 수 있다. 따라서 연산을 빠르게 하기 위해서는 벡터화(vectorized)연산을 사용해야 한다. 일반적으로 Python의 NumPy는 유니버설 함수(universal function, ufuncs)을 통해 구현된다.\n\n\n\nimport numpy as np\n\ndef compute_reciprocals(values):\n    output = np.empty(len(values)) #메모리 값을 불러옴#\n    for i in range(len(values)):\n        output[i] = 1.0 / values[i] #받은 배열 값의 역수를 계산\n    return output\n\n\nnp.random.seed(0)\n\nvalues = np.random.randint(1, 10, size=5)\nprint(values)\n\n[6 1 4 4 8]\n\n\n\nprint(compute_reciprocals(values))\nprint(1.0 / values) # 역수를 확인\n\n[0.16666667 1.         0.25       0.25       0.125     ]\n[0.16666667 1.         0.25       0.25       0.125     ]\n\n\n\nnp.arange(5) / np.arange(1, 6)\n# 각 원소별로 연산이 이루어짐\n\narray([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])\n\n\n\nx = np.arange(9).reshape((3, 3))\nprint(x)\n2 ** x\n\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\n\narray([[  1,   2,   4],\n       [  8,  16,  32],\n       [ 64, 128, 256]])\n\n\n\n\n\n\n\nNumPy의 ufuncs는 Python의 기본 산술 연산자를 사용한다.\n\nx = np.arange(4)\nprint(\"x     =\", x)\nprint(\"x + 5 =\", x + 5)\nprint(\"x - 5 =\", x - 5)\nprint(\"x * 2 =\", x * 2)\nprint(\"x / 2 =\", x / 2)\nprint(\"x // 2 =\", x // 2)  # floor division (나누고 나서 값을 버림, 3.45 -&gt; 3)\n\nx     = [0 1 2 3]\nx + 5 = [5 6 7 8]\nx - 5 = [-5 -4 -3 -2]\nx * 2 = [0 2 4 6]\nx / 2 = [0.  0.5 1.  1.5]\nx // 2 = [0 0 1 1]\n\n\n\nprint(\"-x     = \", -x)\nprint(\"x ** 2 = \", x ** 2)\nprint(\"x % 2  = \", x % 2)   # remainder (나누고 나서 남은 값을 반환, 5/4 -&gt;1)\n\n-x     =  [ 0 -1 -2 -3]\nx ** 2 =  [0 1 4 9]\nx % 2  =  [0 1 0 1]\n\n\n\n-(0.5*x + 1) ** 2\n\narray([-1.  , -2.25, -4.  , -6.25])\n\n\n다음은 NumPy에 구현된 산술 연산자이다.\n\n\n\n\n\n\n\n\nOperator\nEquivalent ufunc\nDescription\n\n\n\n\n+\nnp.add\nAddition (e.g., 1 + 1 = 2)\n\n\n-\nnp.subtract\nSubtraction (e.g., 3 - 2 = 1)\n\n\n-\nnp.negative\nUnary negation (e.g., -2)\n\n\n*\nnp.multiply\nMultiplication (e.g., 2 * 3 = 6)\n\n\n/\nnp.divide\nDivision (e.g., 3 / 2 = 1.5)\n\n\n//\nnp.floor_divide\nFloor division (e.g., 3 // 2 = 1)\n\n\n**\nnp.power\nExponentiation (e.g., 2 ** 3 = 8)\n\n\n%\nnp.mod\nModulus/remainder (e.g., 9 % 4 = 1)\n\n\n\n\n\n\nPython에 내장된 절대값 함수 abs도 사용할 수 있다.\n\nx = np.array([-2, -1, 0, 1, 2])\nabs(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\nnp.absolute(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\nnp.abs(x)\n\narray([2, 1, 0, 1, 2])\n\n\n\n\n\n\ntheta = np.linspace(0, np.pi, 3)\n\n\nprint(\"theta      = \", theta)\nprint(\"sin(theta) = \", np.sin(theta))\nprint(\"cos(theta) = \", np.cos(theta))\nprint(\"tan(theta) = \", np.tan(theta))\n\ntheta      =  [0.         1.57079633 3.14159265]\nsin(theta) =  [0.0000000e+00 1.0000000e+00 1.2246468e-16]\ncos(theta) =  [ 1.000000e+00  6.123234e-17 -1.000000e+00]\ntan(theta) =  [ 0.00000000e+00  1.63312394e+16 -1.22464680e-16]\n\n\n\nx = [-1, 0, 1]\nprint(\"x         = \", x)\nprint(\"arcsin(x) = \", np.arcsin(x))\nprint(\"arccos(x) = \", np.arccos(x))\nprint(\"arctan(x) = \", np.arctan(x))\n\nx         =  [-1, 0, 1]\narcsin(x) =  [-1.57079633  0.          1.57079633]\narccos(x) =  [3.14159265 1.57079633 0.        ]\narctan(x) =  [-0.78539816  0.          0.78539816]\n\n\n\n\n\n\nx = [1, 2, 3]\nprint(\"x     =\", x)\nprint(\"e^x   =\", np.exp(x))\nprint(\"2^x   =\", np.power(2, x))\nprint(\"3^x   =\", np.power(3, x))\n\nx     = [1, 2, 3]\ne^x   = [ 2.71828183  7.3890561  20.08553692]\n2^x   = [2 4 8]\n3^x   = [ 3  9 27]\n\n\n\nx = [1, 2, 4, 10]\nprint(\"x        =\", x)\nprint(\"ln(x)    =\", np.log(x))\nprint(\"log2(x)  =\", np.log2(x))\nprint(\"log10(x) =\", np.log10(x))\n\nx        = [1, 2, 4, 10]\nln(x)    = [0.         0.69314718 1.38629436 2.30258509]\nlog2(x)  = [0.         1.         2.         3.32192809]\nlog10(x) = [0.         0.30103    0.60205999 1.        ]\n\n\n\n\n\n통계학에서 자주 사용되는 전문적인 함수는 scipy패키지의 special모듈을 사용해서 계산할 수 있다.\n\nfrom scipy import special\n\n\nx = [1, 5, 10]\nprint(\"gamma(x)     =\", special.gamma(x))\nprint(\"ln|gamma(x)| =\", special.gammaln(x))\nprint(\"beta(x, 2)   =\", special.beta(x, 2))\n\ngamma(x)     = [1.0000e+00 2.4000e+01 3.6288e+05]\nln|gamma(x)| = [ 0.          3.17805383 12.80182748]\nbeta(x, 2)   = [0.5        0.03333333 0.00909091]"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#요약-통계량-계산",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#요약-통계량-계산",
    "title": "P02_Numpy",
    "section": "",
    "text": "자료의 특성을 파악하는 첫 번째 단계는 요약 통계를 계산하는 것이다. NumPy에서는 다양한 내장 집계 함수를 제공한다.\n\n\n배열의 합은 내장함수 sum을 이용해서도 구할 수 있다.\n\nnp.random.seed(1)\n\nL = np.random.random(100)\nprint(L)\nsum(L)\n\n[4.17022005e-01 7.20324493e-01 1.14374817e-04 3.02332573e-01\n 1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01\n 3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01\n 2.04452250e-01 8.78117436e-01 2.73875932e-02 6.70467510e-01\n 4.17304802e-01 5.58689828e-01 1.40386939e-01 1.98101489e-01\n 8.00744569e-01 9.68261576e-01 3.13424178e-01 6.92322616e-01\n 8.76389152e-01 8.94606664e-01 8.50442114e-02 3.90547832e-02\n 1.69830420e-01 8.78142503e-01 9.83468338e-02 4.21107625e-01\n 9.57889530e-01 5.33165285e-01 6.91877114e-01 3.15515631e-01\n 6.86500928e-01 8.34625672e-01 1.82882773e-02 7.50144315e-01\n 9.88861089e-01 7.48165654e-01 2.80443992e-01 7.89279328e-01\n 1.03226007e-01 4.47893526e-01 9.08595503e-01 2.93614148e-01\n 2.87775339e-01 1.30028572e-01 1.93669579e-02 6.78835533e-01\n 2.11628116e-01 2.65546659e-01 4.91573159e-01 5.33625451e-02\n 5.74117605e-01 1.46728575e-01 5.89305537e-01 6.99758360e-01\n 1.02334429e-01 4.14055988e-01 6.94400158e-01 4.14179270e-01\n 4.99534589e-02 5.35896406e-01 6.63794645e-01 5.14889112e-01\n 9.44594756e-01 5.86555041e-01 9.03401915e-01 1.37474704e-01\n 1.39276347e-01 8.07391289e-01 3.97676837e-01 1.65354197e-01\n 9.27508580e-01 3.47765860e-01 7.50812103e-01 7.25997985e-01\n 8.83306091e-01 6.23672207e-01 7.50942434e-01 3.48898342e-01\n 2.69927892e-01 8.95886218e-01 4.28091190e-01 9.64840047e-01\n 6.63441498e-01 6.21695720e-01 1.14745973e-01 9.49489259e-01\n 4.49912133e-01 5.78389614e-01 4.08136803e-01 2.37026980e-01\n 9.03379521e-01 5.73679487e-01 2.87032703e-03 6.17144914e-01]\n\n\n48.58779276001459\n\n\n\nnp.sum(L)\n\n48.587792760014565\n\n\n합, 합연산은 배열의 차원과 관계없이 전체 원소의 합을 반환\nNumPy의 경우 연산이 컴파일된 코드에서 계산되기 때문에 계산시간을 단축할 수 있다.\n\nnp.random.seed(2)\n\nbig_array = np.random.rand(100)\n%timeit sum(big_array)\n%timeit np.sum(big_array)\n\n11.3 µs ± 636 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n4.74 µs ± 1.45 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\n시간이 훨씬 적게 걸림을 확인할 수 있음\n\nmin(big_array), max(big_array)\n\n(0.01301733669455063, 0.9938520114212729)\n\n\n\n%timeit min(big_array)\n%timeit np.min(big_array)\n\n9.38 µs ± 2.94 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n4.24 µs ± 495 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\nNumPy 배열의 객체는 자체 메서드를 가지고 있다.\n\nprint(big_array.min(), big_array.max(), big_array.sum())\n\n0.01301733669455063 0.9938520114212729 46.002824535219375\n\n\n일반적으로 .ftn 형태를 가지게 됨\n\n\n\n\nnp.random.seed(1)\nM = np.random.random((3, 4)) # 3*4 차원 #\nprint(M)\n\n[[4.17022005e-01 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n\n\n\nM.sum()\n\n4.250707092634627\n\n\n축의 지정을 통해 열별 계산을 할 수 있다. 열에 대한 축 지정은 axis=0를 이용한다.\n\nM.min(axis=0)\n\narray([1.46755891e-01, 9.23385948e-02, 1.14374817e-04, 3.02332573e-01])\n\n\naxis 지정은 연산이 이루어지는 축임, 이는 R과 규칙이 다름\n행별 계산은 axis=1을 이용한다.\n\nM.max(axis=1)\n\narray([0.72032449, 0.34556073, 0.6852195 ])\n\n\n\n\n\n다음은 NumPy에서 사용할 수 있는 함수의 목록을 나타낸다.\n\n\n\n\n\n\n\n\nFunction Name\nNaN-safe Version\nDescription\n\n\n\n\nnp.sum\nnp.nansum\nCompute sum of elements\n\n\nnp.prod\nnp.nanprod\nCompute product of elements\n\n\nnp.mean\nnp.nanmean\nCompute mean of elements\n\n\nnp.std\nnp.nanstd\nCompute standard deviation\n\n\nnp.var\nnp.nanvar\nCompute variance\n\n\nnp.min\nnp.nanmin\nFind minimum value\n\n\nnp.max\nnp.nanmax\nFind maximum value\n\n\nnp.argmin\nnp.nanargmin\nFind index of minimum value\n\n\nnp.argmax\nnp.nanargmax\nFind index of maximum value\n\n\nnp.median\nnp.nanmedian\nCompute median of elements\n\n\nnp.percentile\nnp.nanpercentile\nCompute rank-based statistics of elements\n\n\nnp.any\nN/A\nEvaluate whether any elements are true\n\n\nnp.all\nN/A\nEvaluate whether all elements are true\n\n\n\n\nprint(M)\nM[0,0] = np.log(0)\nprint(M)\nnp.max(M,axis=0)\n# -Inf 로 오류가 발생하지는 않으나 오류 발생시 np.nanmax 이용\n\n[[          -inf 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n[[          -inf 7.20324493e-01 1.14374817e-04 3.02332573e-01]\n [1.46755891e-01 9.23385948e-02 1.86260211e-01 3.45560727e-01]\n [3.96767474e-01 5.38816734e-01 4.19194514e-01 6.85219500e-01]]\n\n\nRuntimeWarning: divide by zero encountered in log\n  M[0,0] = np.log(0)\n\n\narray([0.39676747, 0.72032449, 0.41919451, 0.6852195 ])"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열연산-broadcasting",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열연산-broadcasting",
    "title": "P02_Numpy",
    "section": "",
    "text": "Broadcasting은 다른 크기의 배열에 이항 ufuncs함수(덧셈, 뺄셈, 곱셈등)를 적용하기 위한 규칙의 집합이다.\n\n\n일차원 배열\n\na = np.array([0, 1, 2])\nb = np.array([5, 5, 5])\nprint(a)\nprint(b)\nprint(a + b)\n\n[0 1 2]\n[5 5 5]\n[5 6 7]\n\n\n\na + 5 #배열과 상수의 연산은 각 원소와 상수의 연산으로 됨\n\narray([5, 6, 7])\n\n\n이차원 배열\n\nM = np.ones((3, 3))\nM\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nprint(M.shape)\nprint(a[0:2].shape)\nprint(M+a)\nprint(M+a[0:2])\n\n(3, 3)\n(2,)\n[[1. 2. 3.]\n [1. 2. 3.]\n [1. 2. 3.]]\n\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-125-2d77659103c9&gt; in &lt;cell line: 4&gt;()\n      2 print(a[0:2].shape)\n      3 print(M+a)\n----&gt; 4 print(M+a[0:2])\n\nValueError: operands could not be broadcast together with shapes (3,3) (2,) \n\n\n\n\na = np.arange(3)\nb = np.arange(3)[:,np.newaxis]\nprint(a)\nprint(b)\n\n[0 1 2]\n[[0]\n [1]\n [2]]\n\n\n1차원으로 (d,)와 2차원으로 (d,1)은 엄격히 구분됨\n\na + b\n# 이 경우 외적의 형태로 연산\n# a의 모든 원소와 b의 모든 원소들 간의 연산이 이루어짐\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n\na = np.arange(3)\naa = a[:,np.newaxis]\nprint(aa)\nprint(np.min(aa,axis=0))\n\n[[0]\n [1]\n [2]]\n[0]\n\n\n\n\n\n\n규칙 1: 두 배열의 차원 수가 다르면 더 작은 수의 차원을 가진 배열 형상의 차원 수를 늘린다 (이 때 1차원의 수를 1로 한다).\n규칙 2: 두 배열의 형상이 어떤 차원에서도 일치하지 않는다면 해당 차원의 형상이 1인 배열이 다른 형상과 일치하도록 늘린다.\n규칙 3: 임의의 차원에서 크기가 일치하지 않고 1도 아니라면 오류가 발생한다.\n\n\n\n1차원 배열에 2차원 배열 더하기\n\nM = np.ones((2, 3))\na = np.arange(3)\n\nprint(M)\nprint(a)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n[0 1 2]\n\n\n배열의 형상:\n\nM.shape = (2, 3)\na.shape = (3,)\n\n규칙 1을 따라 배열 a가 더 작은 차원을 가지므로 왼쪽을 1로 채운다:\n\nM.shape -&gt; (2, 3)\na.shape -&gt; (1, 3)\n\n규칙 2에 따라 첫 번째 차원이 일치하지 않으므로 차원을 일치하도록 늘린다:\n\nM.shape -&gt; (2, 3)\na.shape -&gt; (2, 3)\n\n\nprint(M)\nprint(a)\nprint(M+a)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n[0 1 2]\n[[1. 2. 3.]\n [1. 2. 3.]]\n\n\n[0,1,2]가 반복될 때, 열 단위로 반복됨에 주의\n\n\n\n두 배열 모두 broadcasting이 필요한 예제\n\na = np.arange(3).reshape((3, 1))\nb = np.arange(3)\n\nprint(a)\nprint(b)\n\n[[0]\n [1]\n [2]]\n[0 1 2]\n\n\n배열의 형상: - a.shape = (3, 1) - b.shape = (3,)\n규칙 1을 따라 b의 형상에 1을 덧붙여야 한다:\n\na.shape -&gt; (3, 1)\nb.shape -&gt; (1, 3)\n\n규칙 2을 따라 각 차원을 그에 대응하는 다른 배열의 크기에 일치하도록 늘린다:\n\na.shape -&gt; (3, 3)\nb.shape -&gt; (3, 3)\n\n\na + b\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n확장은 열 단위로 이루어짐\n\n\n\n두 개의 배열이 호환되지 않는 경우\n\nM = np.ones((3, 2))\na = np.arange(3)\n\nprint(M)\nprint(a)\n\n[[1. 1.]\n [1. 1.]\n [1. 1.]]\n[0 1 2]\n\n\n배열 형상:\n\nM.shape = (3, 2)\na.shape = (3,)\n\n규칙 1:\n\nM.shape -&gt; (3, 2)\na.shape -&gt; (1, 3)\n\n규칙 2:\n\nM.shape -&gt; (3, 2)\na.shape -&gt; (3, 3)\n\n규칙 3:\n\nM + a\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-138-8cac1d547906&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 M + a\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n\n\n\nnp.newaxis 를 이용한 형상 변경:\n\nprint(a[:, np.newaxis].shape)\nM.shape\n\n(3, 1)\n\n\n(3, 2)\n\n\na: (3, ) -&gt; (3,1) -&gt; (3,2) b: (3, 2)\n\nprint(M)\nprint(a[:, np.newaxis])\nM + a[:, np.newaxis]\n\n[[1. 1.]\n [1. 1.]\n [1. 1.]]\n[[0]\n [1]\n [2]]\n\n\narray([[1., 1.],\n       [2., 2.],\n       [3., 3.]])\n\n\n\na[:, np.newaxis]\n\narray([[0],\n       [1],\n       [2]])\n\n\n참고. broadcasting 규칙은 모든 이항 ufunc에 적용이 된다.\n\n\n\n\n다음의 예는 통계학에서 자주 사용되는 배열을 표준화(Standardization)하는 것이다. \\[ Z = \\frac{X - \\bar{X}}{S},\\] 식에서 \\(\\bar{X}\\)는 평균, \\(S\\)는 표준편차를 나타낸다.\n\nimport numpy as np\nnp.random.seed(1)\n\nX = np.random.random((10, 3))\nprint(X)\n\n[[4.17022005e-01 7.20324493e-01 1.14374817e-04]\n [3.02332573e-01 1.46755891e-01 9.23385948e-02]\n [1.86260211e-01 3.45560727e-01 3.96767474e-01]\n [5.38816734e-01 4.19194514e-01 6.85219500e-01]\n [2.04452250e-01 8.78117436e-01 2.73875932e-02]\n [6.70467510e-01 4.17304802e-01 5.58689828e-01]\n [1.40386939e-01 1.98101489e-01 8.00744569e-01]\n [9.68261576e-01 3.13424178e-01 6.92322616e-01]\n [8.76389152e-01 8.94606664e-01 8.50442114e-02]\n [3.90547832e-02 1.69830420e-01 8.78142503e-01]]\n\n\n\nXmean = X.mean(0)\nXmean\n\narray([0.43434437, 0.45032206, 0.42167713])\n\n\n\nX_centered = X - Xmean\n\n\nX_centered.mean(0)\n\narray([ 3.33066907e-17, -4.44089210e-17, -1.11022302e-17])\n\n\n\nXstd = X.std(0)\nXstd\n\narray([0.30363266, 0.26823818, 0.32697313])\n\n\n\nXstand = X_centered/Xstd\n\n\nXstand.std(0)\n\narray([1., 1., 1.])\n\n\n\nXstand.mean(0)\n\narray([ 1.33226763e-16, -1.77635684e-16,  2.22044605e-17])"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#비교-마스크-부울-로직",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#비교-마스크-부울-로직",
    "title": "P02_Numpy",
    "section": "",
    "text": "NumPy는 배열 내의 값을 검사하고 조작하는 데 부울 마스크를 사용한다. 여기서, 마스킹은 특정 기준에 따라 배열의 값을 추출하거나 수정, 계산, 조작하는 것을 의미한다.\n\n\n\nx = np.array([1, 2, 3, 4, 5])\nprint(x)\n\n[1 2 3 4 5]\n\n\n\nx &lt; 3  # less than\n\narray([ True,  True, False, False, False])\n\n\n\nx &gt; 3  # greater than\n\narray([False, False, False,  True,  True])\n\n\n\nx &lt;= 3  # less than or equal\n\narray([ True,  True,  True, False, False])\n\n\n\nx &gt;= 3  # greater than or equal\n\narray([False, False,  True,  True,  True])\n\n\n\nx != 3  # not equal\n\narray([ True,  True, False,  True,  True])\n\n\n\nx == 3  # equal\n\narray([False, False,  True, False, False])\n\n\n두 배열을 항목별로 비교할 수 있으며 복합 표현식을 적용할 수도 있다.\n\n(2 * x) == (x ** 2)\n\narray([False,  True, False, False, False])\n\n\n비교 연산자와 그에 대응하는 ufunc함수:\nOperator | Equivalent ufunc || Operator | Equivalent ufunc |\n|—————|———————||—————|———————| |== |np.equal ||!= |np.not_equal | |&lt; |np.less ||&lt;= |np.less_equal | |&gt; |np.greater ||&gt;= |np.greater_equal |\n2차원 예제:\n\nrng = np.random.RandomState(100) # random seed 와 비슷하게 기능 #\nx = rng.randint(10, size=(3, 4))\nx\n\narray([[8, 8, 3, 7],\n       [7, 0, 4, 2],\n       [5, 2, 2, 2]])\n\n\n\nx &lt; 6\n\narray([[False, False,  True, False],\n       [False,  True,  True,  True],\n       [ True,  True,  True,  True]])\n\n\n\n\n\n부울 배열에서 참인 요소의 개수를 셀 수 있다.\n\n# how many values less than 6?\nnp.count_nonzero(x &lt; 6)\n\n8\n\n\n\nnp.sum(x &lt; 6)\n\n8\n\n\n\n# 각 행별로 6보다 작은 값들을 세어봄 (연산은 열단위로 이루어짐)\nprint(np.sum(x &lt; 6, axis=1))\nprint(x&lt;6)\n\n[1 3 4]\n[[False False  True False]\n [False  True  True  True]\n [ True  True  True  True]]\n\n\n\nx == 6\n\narray([[False, False, False, False],\n       [False, False, False, False],\n       [False, False, False, False]])\n\n\n값 중 하나라도 참이 있는 지나 모든 값이 참인지 빠르게 확인할 수 있다.\n\n# are there any values greater than 8?\nnp.any(x &gt; 8)\n\nFalse\n\n\n\n# are there any values less than zero?\nnp.any(x &lt; 0)\n\nFalse\n\n\n\n# are all values less than 10?\nnp.all(x &lt; 10)\n\nTrue\n\n\n\n# are all values equal to 6?\nnp.all(x == 6)\n\nFalse\n\n\n\n# are all values in each row less than 8?\nnp.all(x &lt; 8, axis=1)\n\narray([False,  True,  True])\n\n\n부울연산자는 동시에 여러식을 비교할때 사용하는 연산자이다.\n\nnp.sum((x &gt; 3) & (x &lt; 8))\n\n4\n\n\n다음은 부울 연산자와 그에 상응하는 ufuncs이다.\nOperator | Equivalent ufunc || Operator | Equivalent ufunc |\n|—————|———————||—————|———————| |& |np.bitwise_and ||| |np.bitwise_or | |^ |np.bitwise_xor ||~ |np.bitwise_not |\n\n\n\n부울 배열을 마스크로 사용해 데이터 자체의 특정 부분 집합을 선택할 수 있다.\n\nx\n\narray([[8, 8, 3, 7],\n       [7, 0, 4, 2],\n       [5, 2, 2, 2]])\n\n\n\nx &lt; 5\n\narray([[False, False,  True, False],\n       [False,  True,  True,  True],\n       [False,  True,  True,  True]])\n\n\n부울 배열을 인덱스로 사용 (마스킹 연산):\n\nx[x &lt; 5]\n\narray([3, 0, 4, 2, 2, 2, 2])\n\n\n\n\n\nand/or는 전체 객체에 대해 단일 부울 평가를 수행한다.\n\nbool(42), bool(0)\n\n(True, False)\n\n\nbool 문은 0이 거짓, 양수는 참으로 반환\n\nbool(42 and 0)\n\nFalse\n\n\n\nbool(42 or 0)\n\nTrue\n\n\n&/|는 객체의 내용에 대해 여러 번 부울 평가를 수행한다.\n\nbin(42)\n\n'0b101010'\n\n\n\nbin(59)\n\n'0b111011'\n\n\n\nbin(42 & 59) # 각 원소별로 평가\n\n'0b101010'\n\n\n\nbin(42 | 59) # 각 원소별로 평가\n\n'0b111011'\n\n\n\nA = np.array([1, 0, 1, 0, 1, 0], dtype=bool)\nB = np.array([1, 1, 1, 0, 1, 1], dtype=bool)\nA | B\n\narray([ True,  True,  True, False,  True,  True])\n\n\n\nx = np.arange(10)\n(x &gt; 4) & (x &lt; 8)\n\narray([False, False, False, False, False,  True,  True,  True, False,\n       False])\n\n\n주의. or와 and연산자는 전체 객체에 대해 단일 부울 평가를 수행한다.\n\nA or B\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-180-ea2c97d9d9ee&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 A or B\n\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n\n\n\n\n(x &gt; 4) & (x &lt; 8)\n\narray([False, False, False, False, False,  True,  True,  True, False,\n       False])"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#펜시-인덱싱",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#펜시-인덱싱",
    "title": "P02_Numpy",
    "section": "",
    "text": "NumPy 배열의 팬시 인덱싱은 정수 리스트(혹은 배열)를 이용하여 여러 개를 동시에 선택하는 방식이다.\n\n\n\nrand = np.random.RandomState(42)\nx = rand.randint(100, size=10)\nprint(x)\n\n[51 92 14 71 60 20 82 86 74 74]\n\n\n세 개의 다른 요소에 접근할 수 있다.\n\n[x[3], x[7], x[2]]\n\n[71, 86, 14]\n\n\n인덱스의 단일 리스트나 배열을 전달해 접근할 수 있다.\n\nx[x &gt; 70]\n\narray([92, 71, 82, 86, 74, 74])\n\n\n\nind = np.where(x&gt;70)[0]\nind\n\narray([1, 3, 6, 7, 8, 9])\n\n\n\nx[ind]\n\narray([92, 71, 82, 86, 74, 74])\n\n\n\nind = [3, 7, 4]\nx[ind]\n\narray([71, 86, 60])\n\n\n펜시 인덱싱을 이용하면 인덱스 배열의 형상을 반영할 수 있다.\n\nind = np.array([[3, 7],\n                [4, 5]])\nprint(x)\nx[ind]\n\n[51 92 14 71 60 20 82 86 74 74]\n\n\narray([[71, 86],\n       [60, 20]])\n\n\nindex로 형상이 따라가게 됨\n다차원 예제:\n\nX = np.arange(12).reshape((3, 4))\nX\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\nrow = np.array([0, 1, 2])\ncol = np.array([2, 1, 3])\nX[row, col]\n\narray([ 2,  5, 11])\n\n\n2차원 인덱싱을 하고 있음에 유의\n\nX[row[:,np.newaxis], col] #[0,1,2]^T [2,1,3]: 첨자행렬#\n\narray([[ 2,  1,  3],\n       [ 6,  5,  7],\n       [10,  9, 11]])\n\n\n(0,0) 원소의 인텍싱은 (0,2), (2,2) 원소의 인텍싱은 (2,3)과 같이 됨\n\nprint(row)\nrow[:,np.newaxis]  #[0,1,2]^T [2,1,3]: 왼쪽#\n\n[0 1 2]\n\n\narray([[0],\n       [1],\n       [2]])\n\n\n\ncol #[0,1,2]^T [2,1,3]: 오른쪽#\n\narray([2, 1, 3])\n\n\n\n\n\n\nprint(X)\n\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n\n\nX[2, [2, 0, 1]]\n\narray([10,  8,  9])\n\n\n\nX[1:, [2, 0, 1]]\n\narray([[ 6,  4,  5],\n       [10,  8,  9]])\n\n\n2차원 인덱싱 방법\n\nrow = np.array([0, 1, 2])\nprint(row[:, np.newaxis])\n\nprint(X)\nmask = np.array([1, 0, 1, 0], dtype=bool) # (0,2) 만 유효함\nX[row[:, np.newaxis], mask] #[0,1,2]^T [0,2]\n\n[[0]\n [1]\n [2]]\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n\narray([[ 0,  2],\n       [ 4,  6],\n       [ 8, 10]])\n\n\n\nmask #[0,2] 와 동일 #\n\narray([ True, False,  True, False])\n\n\n\n\n\n\nx = np.arange(10)\ni = np.array([2, 1, 8, 4])\nx[i] = 99\nprint(x)\n\n[ 0 99 99  3 99  5  6  7 99  9]\n\n\n\nx[i] -= 10\nprint(x)\n\n[ 0 89 89  3 89  5  6  7 89  9]\n\n\n다음의 예는 반복되는 인덱스를 사용했을 때의 결과이다. 먼저 x[0] = 4가 할당되고 x[1] = 6이 할당된다.\n\nx = np.zeros(10)\nx[[0, 1]] = [4, 6]\nprint(x)\n\n[4. 6. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\ni = [2, 3, 3, 4, 4, 4, 5]\nx[i] += 1\nprint(x)\n## 중복이 영향을 안줌 (위치만 확인하고 비중은 없음)\n\n[4. 6. 1. 1. 1. 1. 0. 0. 0. 0.]\n\n\n\nx = np.zeros(10)\nprint(i)\nnp.add.at(x, i, 1)\nprint(x)\n# 중복이 영향을 주는 경우\n\n[2, 3, 3, 4, 4, 4, 5]\n[0. 0. 1. 2. 3. 1. 0. 0. 0. 0.]"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-정렬",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#배열-정렬",
    "title": "P02_Numpy",
    "section": "",
    "text": "NumPy에서는 배열의 값을 정렬하는 알고리즘을 제공한다.\n\n\n기본적으로 퀵 정렬(quick sorts) 알고리즘을 사용한다.\n\nx = np.array([2, 1, 4, 3, 5])\nnp.sort(x)\n\narray([1, 2, 3, 4, 5])\n\n\n\nx.sort()\nprint(x)\n\n[1 2 3 4 5]\n\n\n참고. 옵션을 사용하면 병합정렬(mergesort)와 힙정렬(heapsort)도 사용할 수 있다 (알고리즘의 구분).\n정렬된 요소의 인덱스를 반환\n\nx = np.array([2, 1, 4, 3, 5])\ni = np.argsort(x)\nprint(i)\n\n[1 0 3 2 4]\n\n\n\nx[i]\n\narray([1, 2, 3, 4, 5])\n\n\n\n\n\n\nrand = np.random.RandomState(42)\nX = rand.randint(0, 10, (4, 6))\nprint(X)\n\n[[6 3 7 4 6 9]\n [2 6 7 4 3 7]\n [7 2 5 4 1 7]\n [5 1 4 0 9 5]]\n\n\n\n# sort each column of X\nnp.sort(X, axis=0)\n\narray([[2, 1, 4, 0, 1, 5],\n       [5, 2, 5, 4, 3, 7],\n       [6, 3, 7, 4, 6, 7],\n       [7, 6, 7, 4, 9, 9]])\n\n\n\n# sort each row of X\nnp.sort(X, axis=1)\n\narray([[3, 4, 6, 6, 7, 9],\n       [2, 3, 4, 6, 7, 7],\n       [1, 2, 4, 5, 7, 7],\n       [0, 1, 4, 5, 5, 9]])"
  },
  {
    "objectID": "posts/P02_NumPy(1)/P02_NumPy(1).html#부분-정렬-파티션",
    "href": "posts/P02_NumPy(1)/P02_NumPy(1).html#부분-정렬-파티션",
    "title": "P02_Numpy",
    "section": "",
    "text": "배열과 숫자 K를 취해 새로운 배열을 반환할 수 있다. 이때, K개의 가장 작은 값이 왼쪽에 있고 오른쪽에는 나머지 값이 채워진다. 순서는 임의로 정해진다.\n\nx = np.array([7, 2, 3, 1, 6, 5, 4])\nprint(np.partition(x, 2))\n\n[1 2 3 7 6 5 4]\n\n\n(2,1,3) / (4,6,5,7) = (1,2,3) / (4,5,6,7)\n참고. 인덱스를 반환하는 np.argpartition 함수가 있다."
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "이번 강의에서는 if, while, for등의 조건문, 반복문과 사용자 정의 함수에 대해 학습한다.\n\n\n논리 연산(logical operation) 혹은 불 연산(boolean operation)은 참, 거짓 두 가지 원소(진리값으로 불림)만 존재하는 집합에서의 연산으로, 제어문(조건문, 반복문)에 필수적이다.\n\n\n\n\n\n부호\n정의\n\n\n\n\n&gt;\nx &gt; y : x가 y보다 크다\n\n\n&gt;=\nx가 y보다 크거나 같다\n\n\n&lt;\nx가 y보다 작다\n\n\n&lt;=\nx가 y보다 작거나 같다\n\n\n==\nx와 y가 같다\n\n\n!=\nx와 y가 같지 않다\n\n\n\n\nx = 1\nx == 1\n\nTrue\n\n\n\nx &gt;= 2\n\nFalse\n\n\n\n\n\n\n\n\n키워드\n비트\n설명\n\n\n\n\nand\n&\n논리식이 모두 참이면 참\n\n\nor\n|\n논리식 중에서 하나라도 참이면 참\n\n\nnot\n~\n논리식의 결과가 참이면 거짓을, 거짓이면 참\n\n\n\n^\n논리식중 하나가 참이고 다른하나가 거짓이면 참 (XOR)\n\n\n\n\nx == 1 & x == 2\n\nFalse\n\n\n\nx == 1 and x == 2\nprint((x == 1)^(x == 2))\n\nTrue\n\n\n\n\n\n\n\n\nin\nnot in\n\n\n\n\nx in 리스트\nx not in 리스트\n\n\nx in 튜플\nx not in 튜플\n\n\nx in 문자열\nx not in 문자열\n\n\n\n\n1 in [1, 2, 3]\n\nTrue\n\n\n\n1 not in [1, 2, 3]\n\nFalse\n\n\n\n\n\n\nPython프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰인다. if문의 사용법은 다음과 같다.\nif 조건문:  \n\n    수행할 문장 1  \n    수행할 문장 2  \n    ...    \n    \nelif 조건문2:  \n\n    수행할 문장 2-1  \n    수행할 문장 2-2  \n    ...  \n\nelif 조건문N:  \n\n    수행할 문장 N-1  \n    수행할 문장 N-2  \n    ...  \n    \nelse:  \n\n    수행할 문장 A  \n    수행할 문장 B  \n    ...  \n주의. Python에서는 들여쓰기로 코드의 블럭을 나눈다.\n\nx = 5\nif x &lt; 5:\n   x += 1\nelse:\n   x -= 1\n\nprint(x)\n\n4\n\n\n\nx = 5\nif x &lt; 5:\n    x = x + 1\nelif x &gt; 5:\n    x = x - 1\nelse:\n    x = x * 2\n\nprint(x)\n\n10\n\n\n\n\n\n반복문은 반복해서 문장을 수행해야 할 경우 사용된다. Python에서 사용되는 반복문은 for문과 while문이 있다.\n\n\nfor문의 기본구조는 다음과 같다.\nfor 변수 in 리스트(또는 튜플, 문자열, range):  \n\n    수행할 문장1\n    수행할 문장2\n    ...\n0부터 99까지 더하는 예제\n0에서 시작하는 루프임에 유의\n\ncount = 0\nfor i in range(100):\n    count += i\n    if i % 10 == 0:\n      print(count)\n\nprint(count)\n\n0\n55\n210\n465\n820\n1275\n1830\n2485\n3240\n4095\n4950\n\n\n\ncount = 0\nx = list(range(31))\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n\n\n\nfor i in x:\n    count += i\n\nprint(count)\n\n465\n\n\n0부터 9까지 더하는 것을 10번 반복\n\ncount = 0\nfor i in range(10):\n    for j in range(10):\n        count += j\n\nprint(count)\n\n450\n\n\n순서와 값을 이용하는 예제\n\nx = range(0,100,11)\nprint(list(x))\nfor i, y in enumerate(x): # 순서와 값을 반환\n    print('i (order) is : ', i, ', y (index) is : ', y)\n\n[0, 11, 22, 33, 44, 55, 66, 77, 88, 99]\ni (order) is :  0 , y (index) is :  0\ni (order) is :  1 , y (index) is :  11\ni (order) is :  2 , y (index) is :  22\ni (order) is :  3 , y (index) is :  33\ni (order) is :  4 , y (index) is :  44\ni (order) is :  5 , y (index) is :  55\ni (order) is :  6 , y (index) is :  66\ni (order) is :  7 , y (index) is :  77\ni (order) is :  8 , y (index) is :  88\ni (order) is :  9 , y (index) is :  99\n\n\n튜플을 이용한 예제\n\nx = [(1,2), (3,4), (5,6)]\nfor (f,l) in x:\n    print(f+l)\n\n3\n7\n11\n\n\n\n\nbreak문은 반복문을 강제 종료할 때 사용된다.\n\nx = range(0,100,11)\nfor i in x:\n    print(i)\n    if i &gt; 50:\n        break\n\n0\n11\n22\n33\n44\n55\n\n\n\n\n\ncontinue문은 반복문에서 특정 반복을 건너뛸 때 사용된다.\n\nx = range(0, 10)\nfor i in x:\n    print(i)\n    if i &lt;= 4:\n        continue\n    # 여기에서 조건이 맞으면 위로 돌아감\n    print(10*i)\n    # 여기에서 조건이 안맞으면 계속 실행\n\n0\n1\n2\n3\n4\n5\n50\n6\n60\n7\n70\n8\n80\n9\n90\n\n\n\n\n\n리스트 안에 for문을 포함하는 리스트 내포를 이용하면 편리하고 직관적인 프로그램을 만들 수 있다.\n\nx = [1, 2, 3, 4]\nr = []\n\nfor i in x:\n    r.append(i*3)\n\nprint(r)\n\n[3, 6, 9, 12]\n\n\n\nr = [i*10 for i in x]\nprint(r)\n\n[10, 20, 30, 40]\n\n\n\nr = [i*3 for i in x if i == 2]\nprint(r)\n\n[6]\n\n\n루프를 돌아가면서도 조건을 확인해서 조건이 맞을 떄만 작동\n\nr = [x*y for x in range(2,10) for y in range(1,10)]\nprint(r)\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n\n\n내포문에서 이중 루프도 가능함\n\n\n\n\nx = range(-5, 5)\nprint(list(x))\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n\n\n\nz_tuple = tuple(i**3 for i in x)\nprint(z_tuple)\n# 튜프 내포\n\n(-125, -64, -27, -8, -1, 0, 1, 8, 27, 64)\n\n\n\nprint(list(x))\nz_set = {x[i]**2.0 for i in x}\nprint(z_set)\n# 집합 내포\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n{0.0, 1.0, 4.0, 9.0, 16.0, 25.0}\n\n\n\nz_dict = {str(i):i*2 for i in x}\nprint(z_dict)\n# dictionary: 이름-값\n\n{'-5': -10, '-4': -8, '-3': -6, '-2': -4, '-1': -2, '0': 0, '1': 2, '2': 4, '3': 6, '4': 8}\n\n\n\n\n\n\n정수값을 받아서 짝수를 화면에 출력하는 코드를 작성하시오.\nA학급에 총 10명의 학생에 대한 중간점수가 있다. 평균을 구하시오.\n\n[70, 60, 55, 75, 95, 90, 80, 80, 85, 100]\n\ncount = 0\ni = 1\nwhile i &lt; 10:\n    count += i\n    i += 1\n\nprint(i)\nprint(count)\n\n10\n45\n\n\n\ncount = 0\nfor i in range(0,10):\n    count += i\n\nprint(i)\n\n9\n\n\n\nimport numpy as np\ncondition = True\ni = 0\nx = range(-10,10)\nprint(np.array(x))\n\nwhile condition:\n    if x[i] &gt; 0:\n        break    # condition = False\n    print(x[i])\n    i += 1\n# 양수가 되는 순간 루프를 나오고 아래 구문을 작동시키지 않음\n\n[-10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7\n   8   9]\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n\n\n\n\n\n\n1부터 50까지의 수 중 짝수를 화면에 출력하는 코드를 작성하시오.\nwhile문을 이용하여 아래와 같이 *를 표시하시오.\n*\n**\n***\n****\n*****\n\n참고. 문자열에 상수를 곱하면 해당 문자가 반복된다.\n\n\"*\" * 10\n\n'**********'\n\n\n\n\n\n\n\n사용자 정의 함수는 사용자가 직접 새로운 함수를 정의하는 방법으로 똑같은 내용이 반복되는 부분을 주로 함수로 정의하여 사용한다.\nPython에서 사용자 정의 함수를 정의하는 구조는 아래와 같다.\ndef 함수명(입력 인수):\n\n    수행할 문장1\n    수행할 문장2\n    ...\n    return 결과값\n제곱\n\ndef square(x):\n    return x**2\n\n\nx = 2\ny = square(x)\nprint(x,y)\n\n2 4\n\n\n거리\n\ndef l2dist(x,y):\n    return (x-y)**2\n\n\nx = 3\ny = 10\nz = l2dist(x,y)\nprint(x,y,z)\n\n3 10 49\n\n\n\nz = l2dist(y=10,x=3)\nprint(z)\n\n49\n\n\nPython에서 사용자 정의 함수는 입력 인수에 초기값을 설정할 수 있다. 단, 초기값을 가지는 인수는 맨 뒤에 위치해야 한다.\n\ndef lp_norm(x,y,p=2):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    return sum(d)**(1/p)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\nprint(x)\nprint(y)\nl2 = lp_norm(x,y)\nl1 = lp_norm(x,y,1)\nprint(l1,l2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n41.0 15.7797338380595\n\n\n입력 인수의 갯수를 변하도록 정의할 수 있다.\n\ndef lp_norm(x,y,p=2,*args):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n    out = [sum(d)**(1/p)]\n\n    print('Number of *args:', len(args))\n    for p in args:\n        d = []\n        for i in range(n):\n            d.append(abs(x[i] - y[i])**p)\n        print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n        out.append(sum(d)**(1/p))\n\n    return tuple(out)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\n\n\nlp = lp_norm(x,y)\nprint(lp)\n\nThe L2 distance is : 15.7797338380595\nNumber of *args: 0\n(15.7797338380595,)\n\n\n\nlp = lp_norm(x,y,1)\nprint(lp)\n\nThe L1 distance is : 41.0\nNumber of *args: 0\n(41.0,)\n\n\n\nlp = lp_norm(x,y,1,2,3,4,1.5,2.5,0.5)\nprint(lp)\n# number 역시 0부터 시작함\n\nThe L1 distance is : 41.0\nNumber of *args: 6\nThe L2 distance is : 15.7797338380595\nThe L3 distance is : 11.983774366920516\nThe L4 distance is : 10.631810414384907\nThe L1.5 distance is : 21.370708630062115\nThe L2.5 distance is : 13.317802359045247\nThe L0.5 distance is : 332.2505125167682\n(41.0, 15.7797338380595, 11.983774366920516, 10.631810414384907, 21.370708630062115, 13.317802359045247, 332.2505125167682)\n\n\n1 이후가 새로운 인수가 됨\n정의된 함수의 설명을 추가 할 수 있다.\n\ndef lp_norm(x,y,p = 2):\n    r\"\"\" Compute the distance between vectors.\n\n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n\n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n\n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n\n    Notes\n    -----\n\n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n\n    L2 norm is the default\n\n    &gt;&gt;&gt; lp_norm(x,y)\n\n    Lp can be computed using the optional third input\n\n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n    \"\"\"\n\n    if p&lt;0: p=0\n\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n\n    if p == 0:\n        count = 0\n        for i in range(n):\n            if d[i] != 0:\n                count += 1\n        return count\n    elif p &lt; 1:\n        return sum(d)\n    else:\n        return sum(d)**(1/p)\n\n\nhelp(lp_norm)\n\nHelp on function lp_norm in module __main__:\n\nlp_norm(x, y, p=2)\n    Compute the distance between vectors.\n    \n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n    \n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n    \n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n    \n    Notes\n    -----\n    \n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n    \n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n    \n    L2 norm is the default\n    \n    &gt;&gt;&gt; lp_norm(x,y)\n    \n    Lp can be computed using the optional third input\n    \n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n\n\n변수의 적용 범위 - 로컬과 글로벌이 존재 - 로컬은 함수 안에서 글로벌은 전체에 작용함\n\ndef scope_local():\n    a = -1\n    print('Inside scope_local, a is ',a)\n\ndef scope_global():\n    global a\n    a = -10\n    print('Inside scope_global, a is ',a)\n\n\na=1\nprint('a is ',a)\nprint('')\nscope_local()\nprint('a is now ',a)\nprint('')\nscope_global()\nprint('a is now ',a)\n\na is  1\n\nInside scope_local, a is  -1\na is now  1\n\nInside scope_global, a is  -10\na is now  -10\n\n\nlambda명령어를 사용하여 익명 함수를 정의할 수 있다.\n\nnested = [('John','Doe','Oxford'),\\\n          ('Jane','Dearing','Cambridge'),\\\n          ('Jerry','Dawn','Harvard')]\n\n\nnested.sort()\nprint(nested)\n\n[('Jane', 'Dearing', 'Cambridge'), ('Jerry', 'Dawn', 'Harvard'), ('John', 'Doe', 'Oxford')]\n\n\n\nprint( (lambda x:x**2)(5) )\n# 함수 정의\nnested.sort(key=lambda x:x[1])\nprint(nested)\n# 1번 첨자로 소팅\n\n25\n[('Jerry', 'Dawn', 'Harvard'), ('Jane', 'Dearing', 'Cambridge'), ('John', 'Doe', 'Oxford')]\n\n\n\n\n\n입력을 정수 n으로 받았을 때, n이하까지의 피보나치 수열을 출력하는 함수를 작성하시오.\n0, 1, 1, 2, 3, 5, 8, 13, ...\n다음의 값을 오름차순으로 정력하는 함수를 작성하시오.\n3, 2, 8, 4, 9, 13, 5\n\n\n\n\n\n모듈(module)이란 함수나 변수 또는 클래스(class) 들을 모아 놓은 파일로, 다른 Python프로그램에서 import명령어를 통해 불러와 사용할 수 있다.\n모듈 사용 방법: 1. import 모듈이름 as 별명 2. from 모듈이름 import 모듈함수\n\nimport numpy as np\n\nx = np.random.rand(10)\nprint(x)\n\n[0.80674241 0.89986497 0.04826    0.84636809 0.32832791 0.99544924\n 0.23648638 0.89739243 0.48834308 0.12587896]\n\n\n사용자 정의 모듈\n\n%%writefile -a core.py\nr\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nWriting core.py\n\n\n\n!pwd\n#현재 작동되는 위치를 표시\n\n/content\n\n\n\nimport core\n\ny = -3\nprint(core.square(y))\nprint(core.cube(y))\n\n9\n-27\n\n\n__main__의 역할\n`# This is formatted as code`\n모듈 자체에 실행이 가능한 프로그램을 포함할 수 있도록 도와준다. 단, 다른 프로그램에서 불러와 사용될 때는 모듈안에 있는 실행 가능한 코드는 실행되지 않는다 (모듈이 연결되어 있는 경우, 독립성을 최대한 유지)\n\n%%writefile -a core1.py\n\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nif __name__ == \"__main__\":\n    print('Program called directly.')\nelse:\n    print('Program called indirectly using name: ', __name__)\n\nAppending to core1.py\n\n\n\n!python3 core1.py\n\nProgram called directly.\n\n\n\n\n\n!pip3 install numpy\n\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.26.4)"
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#논리-연산-logical-operator",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#논리-연산-logical-operator",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "논리 연산(logical operation) 혹은 불 연산(boolean operation)은 참, 거짓 두 가지 원소(진리값으로 불림)만 존재하는 집합에서의 연산으로, 제어문(조건문, 반복문)에 필수적이다.\n\n\n\n\n\n부호\n정의\n\n\n\n\n&gt;\nx &gt; y : x가 y보다 크다\n\n\n&gt;=\nx가 y보다 크거나 같다\n\n\n&lt;\nx가 y보다 작다\n\n\n&lt;=\nx가 y보다 작거나 같다\n\n\n==\nx와 y가 같다\n\n\n!=\nx와 y가 같지 않다\n\n\n\n\nx = 1\nx == 1\n\nTrue\n\n\n\nx &gt;= 2\n\nFalse\n\n\n\n\n\n\n\n\n키워드\n비트\n설명\n\n\n\n\nand\n&\n논리식이 모두 참이면 참\n\n\nor\n|\n논리식 중에서 하나라도 참이면 참\n\n\nnot\n~\n논리식의 결과가 참이면 거짓을, 거짓이면 참\n\n\n\n^\n논리식중 하나가 참이고 다른하나가 거짓이면 참 (XOR)\n\n\n\n\nx == 1 & x == 2\n\nFalse\n\n\n\nx == 1 and x == 2\nprint((x == 1)^(x == 2))\n\nTrue\n\n\n\n\n\n\n\n\nin\nnot in\n\n\n\n\nx in 리스트\nx not in 리스트\n\n\nx in 튜플\nx not in 튜플\n\n\nx in 문자열\nx not in 문자열\n\n\n\n\n1 in [1, 2, 3]\n\nTrue\n\n\n\n1 not in [1, 2, 3]\n\nFalse"
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#조건문-if문",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#조건문-if문",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "Python프로그래밍에서 조건을 판단하여 해당 조건에 맞는 상황을 수행하는 데 쓰인다. if문의 사용법은 다음과 같다.\nif 조건문:  \n\n    수행할 문장 1  \n    수행할 문장 2  \n    ...    \n    \nelif 조건문2:  \n\n    수행할 문장 2-1  \n    수행할 문장 2-2  \n    ...  \n\nelif 조건문N:  \n\n    수행할 문장 N-1  \n    수행할 문장 N-2  \n    ...  \n    \nelse:  \n\n    수행할 문장 A  \n    수행할 문장 B  \n    ...  \n주의. Python에서는 들여쓰기로 코드의 블럭을 나눈다.\n\nx = 5\nif x &lt; 5:\n   x += 1\nelse:\n   x -= 1\n\nprint(x)\n\n4\n\n\n\nx = 5\nif x &lt; 5:\n    x = x + 1\nelif x &gt; 5:\n    x = x - 1\nelse:\n    x = x * 2\n\nprint(x)\n\n10"
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#반복문-for문-while문",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#반복문-for문-while문",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "반복문은 반복해서 문장을 수행해야 할 경우 사용된다. Python에서 사용되는 반복문은 for문과 while문이 있다.\n\n\nfor문의 기본구조는 다음과 같다.\nfor 변수 in 리스트(또는 튜플, 문자열, range):  \n\n    수행할 문장1\n    수행할 문장2\n    ...\n0부터 99까지 더하는 예제\n0에서 시작하는 루프임에 유의\n\ncount = 0\nfor i in range(100):\n    count += i\n    if i % 10 == 0:\n      print(count)\n\nprint(count)\n\n0\n55\n210\n465\n820\n1275\n1830\n2485\n3240\n4095\n4950\n\n\n\ncount = 0\nx = list(range(31))\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n\n\n\nfor i in x:\n    count += i\n\nprint(count)\n\n465\n\n\n0부터 9까지 더하는 것을 10번 반복\n\ncount = 0\nfor i in range(10):\n    for j in range(10):\n        count += j\n\nprint(count)\n\n450\n\n\n순서와 값을 이용하는 예제\n\nx = range(0,100,11)\nprint(list(x))\nfor i, y in enumerate(x): # 순서와 값을 반환\n    print('i (order) is : ', i, ', y (index) is : ', y)\n\n[0, 11, 22, 33, 44, 55, 66, 77, 88, 99]\ni (order) is :  0 , y (index) is :  0\ni (order) is :  1 , y (index) is :  11\ni (order) is :  2 , y (index) is :  22\ni (order) is :  3 , y (index) is :  33\ni (order) is :  4 , y (index) is :  44\ni (order) is :  5 , y (index) is :  55\ni (order) is :  6 , y (index) is :  66\ni (order) is :  7 , y (index) is :  77\ni (order) is :  8 , y (index) is :  88\ni (order) is :  9 , y (index) is :  99\n\n\n튜플을 이용한 예제\n\nx = [(1,2), (3,4), (5,6)]\nfor (f,l) in x:\n    print(f+l)\n\n3\n7\n11\n\n\n\n\nbreak문은 반복문을 강제 종료할 때 사용된다.\n\nx = range(0,100,11)\nfor i in x:\n    print(i)\n    if i &gt; 50:\n        break\n\n0\n11\n22\n33\n44\n55\n\n\n\n\n\ncontinue문은 반복문에서 특정 반복을 건너뛸 때 사용된다.\n\nx = range(0, 10)\nfor i in x:\n    print(i)\n    if i &lt;= 4:\n        continue\n    # 여기에서 조건이 맞으면 위로 돌아감\n    print(10*i)\n    # 여기에서 조건이 안맞으면 계속 실행\n\n0\n1\n2\n3\n4\n5\n50\n6\n60\n7\n70\n8\n80\n9\n90\n\n\n\n\n\n리스트 안에 for문을 포함하는 리스트 내포를 이용하면 편리하고 직관적인 프로그램을 만들 수 있다.\n\nx = [1, 2, 3, 4]\nr = []\n\nfor i in x:\n    r.append(i*3)\n\nprint(r)\n\n[3, 6, 9, 12]\n\n\n\nr = [i*10 for i in x]\nprint(r)\n\n[10, 20, 30, 40]\n\n\n\nr = [i*3 for i in x if i == 2]\nprint(r)\n\n[6]\n\n\n루프를 돌아가면서도 조건을 확인해서 조건이 맞을 떄만 작동\n\nr = [x*y for x in range(2,10) for y in range(1,10)]\nprint(r)\n\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]\n\n\n내포문에서 이중 루프도 가능함\n\n\n\n\nx = range(-5, 5)\nprint(list(x))\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n\n\n\nz_tuple = tuple(i**3 for i in x)\nprint(z_tuple)\n# 튜프 내포\n\n(-125, -64, -27, -8, -1, 0, 1, 8, 27, 64)\n\n\n\nprint(list(x))\nz_set = {x[i]**2.0 for i in x}\nprint(z_set)\n# 집합 내포\n\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n{0.0, 1.0, 4.0, 9.0, 16.0, 25.0}\n\n\n\nz_dict = {str(i):i*2 for i in x}\nprint(z_dict)\n# dictionary: 이름-값\n\n{'-5': -10, '-4': -8, '-3': -6, '-2': -4, '-1': -2, '0': 0, '1': 2, '2': 4, '3': 6, '4': 8}\n\n\n\n\n\n\n정수값을 받아서 짝수를 화면에 출력하는 코드를 작성하시오.\nA학급에 총 10명의 학생에 대한 중간점수가 있다. 평균을 구하시오.\n\n[70, 60, 55, 75, 95, 90, 80, 80, 85, 100]\n\ncount = 0\ni = 1\nwhile i &lt; 10:\n    count += i\n    i += 1\n\nprint(i)\nprint(count)\n\n10\n45\n\n\n\ncount = 0\nfor i in range(0,10):\n    count += i\n\nprint(i)\n\n9\n\n\n\nimport numpy as np\ncondition = True\ni = 0\nx = range(-10,10)\nprint(np.array(x))\n\nwhile condition:\n    if x[i] &gt; 0:\n        break    # condition = False\n    print(x[i])\n    i += 1\n# 양수가 되는 순간 루프를 나오고 아래 구문을 작동시키지 않음\n\n[-10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7\n   8   9]\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n\n\n\n\n\n\n1부터 50까지의 수 중 짝수를 화면에 출력하는 코드를 작성하시오.\nwhile문을 이용하여 아래와 같이 *를 표시하시오.\n*\n**\n***\n****\n*****\n\n참고. 문자열에 상수를 곱하면 해당 문자가 반복된다.\n\n\"*\" * 10\n\n'**********'"
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#사용자-정의-함수",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#사용자-정의-함수",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "사용자 정의 함수는 사용자가 직접 새로운 함수를 정의하는 방법으로 똑같은 내용이 반복되는 부분을 주로 함수로 정의하여 사용한다.\nPython에서 사용자 정의 함수를 정의하는 구조는 아래와 같다.\ndef 함수명(입력 인수):\n\n    수행할 문장1\n    수행할 문장2\n    ...\n    return 결과값\n제곱\n\ndef square(x):\n    return x**2\n\n\nx = 2\ny = square(x)\nprint(x,y)\n\n2 4\n\n\n거리\n\ndef l2dist(x,y):\n    return (x-y)**2\n\n\nx = 3\ny = 10\nz = l2dist(x,y)\nprint(x,y,z)\n\n3 10 49\n\n\n\nz = l2dist(y=10,x=3)\nprint(z)\n\n49\n\n\nPython에서 사용자 정의 함수는 입력 인수에 초기값을 설정할 수 있다. 단, 초기값을 가지는 인수는 맨 뒤에 위치해야 한다.\n\ndef lp_norm(x,y,p=2):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    return sum(d)**(1/p)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\nprint(x)\nprint(y)\nl2 = lp_norm(x,y)\nl1 = lp_norm(x,y,1)\nprint(l1,l2)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n41.0 15.7797338380595\n\n\n입력 인수의 갯수를 변하도록 정의할 수 있다.\n\ndef lp_norm(x,y,p=2,*args):\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n    print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n    out = [sum(d)**(1/p)]\n\n    print('Number of *args:', len(args))\n    for p in args:\n        d = []\n        for i in range(n):\n            d.append(abs(x[i] - y[i])**p)\n        print('The L' + str(p) + ' distance is :', sum(d)**(1/p))\n        out.append(sum(d)**(1/p))\n\n    return tuple(out)\n\n\nx = list(range(1,10))\ny = list(range(10,1,-1))\n\n\nlp = lp_norm(x,y)\nprint(lp)\n\nThe L2 distance is : 15.7797338380595\nNumber of *args: 0\n(15.7797338380595,)\n\n\n\nlp = lp_norm(x,y,1)\nprint(lp)\n\nThe L1 distance is : 41.0\nNumber of *args: 0\n(41.0,)\n\n\n\nlp = lp_norm(x,y,1,2,3,4,1.5,2.5,0.5)\nprint(lp)\n# number 역시 0부터 시작함\n\nThe L1 distance is : 41.0\nNumber of *args: 6\nThe L2 distance is : 15.7797338380595\nThe L3 distance is : 11.983774366920516\nThe L4 distance is : 10.631810414384907\nThe L1.5 distance is : 21.370708630062115\nThe L2.5 distance is : 13.317802359045247\nThe L0.5 distance is : 332.2505125167682\n(41.0, 15.7797338380595, 11.983774366920516, 10.631810414384907, 21.370708630062115, 13.317802359045247, 332.2505125167682)\n\n\n1 이후가 새로운 인수가 됨\n정의된 함수의 설명을 추가 할 수 있다.\n\ndef lp_norm(x,y,p = 2):\n    r\"\"\" Compute the distance between vectors.\n\n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n\n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n\n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n\n    Notes\n    -----\n\n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n\n    L2 norm is the default\n\n    &gt;&gt;&gt; lp_norm(x,y)\n\n    Lp can be computed using the optional third input\n\n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n    \"\"\"\n\n    if p&lt;0: p=0\n\n    n = len(x)\n    d = []\n    for i in range(n):\n        d.append(abs(x[i] - y[i])**p)\n\n    if p == 0:\n        count = 0\n        for i in range(n):\n            if d[i] != 0:\n                count += 1\n        return count\n    elif p &lt; 1:\n        return sum(d)\n    else:\n        return sum(d)**(1/p)\n\n\nhelp(lp_norm)\n\nHelp on function lp_norm in module __main__:\n\nlp_norm(x, y, p=2)\n    Compute the distance between vectors.\n    \n    The Lp normed distance is sum(abs(x-y)**p)**(1/p)\n    \n    Parameters\n    ----------\n    x : ndarray\n        First argument\n    y : ndarray\n        Second argument\n    p : float, optional\n        Power used in distance calculation, &gt;=0\n    \n    Returns\n    -------\n    output : scalar\n        Returns the Lp normed distance between x and y\n    \n    Notes\n    -----\n    \n    For p&gt;=1, returns the Lp norm described above. For 0&lt;=p&lt;1,\n    returns sum(abs(x-y)**p). If p&lt;0, p is set to 0.\n    \n    Examples\n    --------\n    &gt;&gt;&gt; x=[0,1,2]\n    &gt;&gt;&gt; y=[1,2,3]\n    \n    L2 norm is the default\n    \n    &gt;&gt;&gt; lp_norm(x,y)\n    \n    Lp can be computed using the optional third input\n    \n    &gt;&gt;&gt; lp_norm(x,y,1)\n\n\n\n변수의 적용 범위 - 로컬과 글로벌이 존재 - 로컬은 함수 안에서 글로벌은 전체에 작용함\n\ndef scope_local():\n    a = -1\n    print('Inside scope_local, a is ',a)\n\ndef scope_global():\n    global a\n    a = -10\n    print('Inside scope_global, a is ',a)\n\n\na=1\nprint('a is ',a)\nprint('')\nscope_local()\nprint('a is now ',a)\nprint('')\nscope_global()\nprint('a is now ',a)\n\na is  1\n\nInside scope_local, a is  -1\na is now  1\n\nInside scope_global, a is  -10\na is now  -10\n\n\nlambda명령어를 사용하여 익명 함수를 정의할 수 있다.\n\nnested = [('John','Doe','Oxford'),\\\n          ('Jane','Dearing','Cambridge'),\\\n          ('Jerry','Dawn','Harvard')]\n\n\nnested.sort()\nprint(nested)\n\n[('Jane', 'Dearing', 'Cambridge'), ('Jerry', 'Dawn', 'Harvard'), ('John', 'Doe', 'Oxford')]\n\n\n\nprint( (lambda x:x**2)(5) )\n# 함수 정의\nnested.sort(key=lambda x:x[1])\nprint(nested)\n# 1번 첨자로 소팅\n\n25\n[('Jerry', 'Dawn', 'Harvard'), ('Jane', 'Dearing', 'Cambridge'), ('John', 'Doe', 'Oxford')]\n\n\n\n\n\n입력을 정수 n으로 받았을 때, n이하까지의 피보나치 수열을 출력하는 함수를 작성하시오.\n0, 1, 1, 2, 3, 5, 8, 13, ...\n다음의 값을 오름차순으로 정력하는 함수를 작성하시오.\n3, 2, 8, 4, 9, 13, 5"
  },
  {
    "objectID": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#모듈modules",
    "href": "posts/P03_LoopFunction(1)/P03_LoopFunction(1).html#모듈modules",
    "title": "P03_LoopFunction(1)",
    "section": "",
    "text": "모듈(module)이란 함수나 변수 또는 클래스(class) 들을 모아 놓은 파일로, 다른 Python프로그램에서 import명령어를 통해 불러와 사용할 수 있다.\n모듈 사용 방법: 1. import 모듈이름 as 별명 2. from 모듈이름 import 모듈함수\n\nimport numpy as np\n\nx = np.random.rand(10)\nprint(x)\n\n[0.80674241 0.89986497 0.04826    0.84636809 0.32832791 0.99544924\n 0.23648638 0.89739243 0.48834308 0.12587896]\n\n\n사용자 정의 모듈\n\n%%writefile -a core.py\nr\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nWriting core.py\n\n\n\n!pwd\n#현재 작동되는 위치를 표시\n\n/content\n\n\n\nimport core\n\ny = -3\nprint(core.square(y))\nprint(core.cube(y))\n\n9\n-27\n\n\n__main__의 역할\n`# This is formatted as code`\n모듈 자체에 실행이 가능한 프로그램을 포함할 수 있도록 도와준다. 단, 다른 프로그램에서 불러와 사용될 때는 모듈안에 있는 실행 가능한 코드는 실행되지 않는다 (모듈이 연결되어 있는 경우, 독립성을 최대한 유지)\n\n%%writefile -a core1.py\n\"\"\"Demonstraion module.\nThis is the module docstring.\n\"\"\"\n\ndef square(x):\n    r\"\"\"Returns the square of a scalar input\n    \"\"\"\n    return x*x\n\ndef cube(x):\n    r\"\"\"Returns the cube of a scalar input\n    \"\"\"\n    return x*x*x\n\nif __name__ == \"__main__\":\n    print('Program called directly.')\nelse:\n    print('Program called indirectly using name: ', __name__)\n\nAppending to core1.py\n\n\n\n!python3 core1.py\n\nProgram called directly.\n\n\n\n\n\n!pip3 install numpy\n\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.26.4)"
  },
  {
    "objectID": "posts/P01_DataType/P01_DataType.html",
    "href": "posts/P01_DataType/P01_DataType.html",
    "title": "P01_DataType",
    "section": "",
    "text": "##Python의 기초##\nPython는 1980년대 후반에 Guido Van Rossum이 개발한 인터프리터 언어(한 줄씩 소스 코드를 해석해서 실행해 결과를 바로 확인할 수 있는 언어)로 문법이 쉬워 빨리 배울 수 있고, 공동 작업과 유지 보수가 매우 쉽고 편한 언어이다.\n본 강의에서는 Python의 기본적인 사용법을 익히고, Numpy, Pandas, Matplotlib, Seaborn, Plotnine등 데이터 사이언스(Data Science)에 필요한 기초적인 핵심 패키지의 사용법에 대해 학습한다."
  },
  {
    "objectID": "posts/P01_DataType/P01_DataType.html#python-설치",
    "href": "posts/P01_DataType/P01_DataType.html#python-설치",
    "title": "P01_DataType",
    "section": "Python 설치",
    "text": "Python 설치\nPython의 설치는 직접 홈페이지(https://www.python.org) 에 들어가 프로그램을 다운받아 설치하는 방법과 Anaconda (https://www.anaconda.com) 를 설치하는 방법이 있다."
  },
  {
    "objectID": "posts/P01_DataType/P01_DataType.html#python-에디터",
    "href": "posts/P01_DataType/P01_DataType.html#python-에디터",
    "title": "P01_DataType",
    "section": "Python 에디터",
    "text": "Python 에디터\nPython프로그램을 작성하기 위해서는 인터프리터보다 에디터를 이용해서 작성하는 것이 편하다. 다음은 잘 알려진 에디터이다.\n\nPyCharm\nSpyder\nAtom\nNotepad++\nSublimetext\netc.\n\n크게 리눅스 계열과 윈도우 계열 두 개로 구분된다."
  },
  {
    "objectID": "posts/P01_DataType/P01_DataType.html#python-실행",
    "href": "posts/P01_DataType/P01_DataType.html#python-실행",
    "title": "P01_DataType",
    "section": "Python 실행",
    "text": "Python 실행\n\nprint(\"Hello world!\")  # Hello world!를 화면에 출력한다.\n\nHello world!\n\n\n\n1 + 2\n\n3\n\n\n\n3 / 2.4\n\n1.25\n\n\n\na = 1\nb = 2\na + b\n\n3\n\n\n\n3/2.0\n\n1.5"
  },
  {
    "objectID": "posts/P01_DataType/P01_DataType.html#python의-자료형",
    "href": "posts/P01_DataType/P01_DataType.html#python의-자료형",
    "title": "P01_DataType",
    "section": "Python의 자료형",
    "text": "Python의 자료형\n\n객체 (변수)\n객체(변수)란 값을 저장하는 공간을 말한다. 예를 들어 a = 3에서 a는 정수 3이라는 값을 가지는 변수이다. 변수는 값이 저장된 메모리의 위치를 가리키는 레퍼런스 (Reference)라고도 한다.\n\n\n변수명\n변수명은 숫자, 문자(대문자, 소문자), 밑줄을 사용하여 정의할 수 있다. 단, 시작은 문자 혹은 밑줄로 시작하여야 하며, 대소문자를 구분한다(case sensitive).\n\nx = 1\nX = 1.0\nX1 = 1.0\nx1 = 1.0\n_x = 1.0\nx_ = 3\n\nprint(x, X, X1, x1, _x, x_)\n\n1 1.0 1.0 1.0 1.0 3\n\n\n여러 변수들을 한번에 정의할 수 있다. 이를 unpacking이라고 한다.\n\n[x, y, z] = [1, 3.14, 2.0]\n\n\nprint(x, y, z)\n\n1 3.14 2.0\n\n\n\n\n숫자형\n숫자형(number)이란 숫자 형태로 이루어진 자료형으로, 정수(integer), 실수(floating-point), 복소수(complex)등이 있다.\n\n실수(float)\n수치계산을 위해 가장 중요한 숫자형으로 점(dot)을 포함하여 정의한다.\n\nx = 1\ntype(x)\n\nint\n\n\n\nx = 1.0\ntype(x)\n\nfloat\n\n\n\nx = float(1)\ntype(x)\n\nfloat\n\n\n\nx = 4.24E10\nprint(x)\n\n42400000000.0\n\n\n\nx = 4.24e-10\nprint(x)\n\n4.24e-10\n\n\n\n\n복소수\n복소수는 j 또는 complex()를 이용하여 정의한다.\n\nx = 1.0\ntype(x)\n\nfloat\n\n\n\nx = 1j\ntype(x)\n\ncomplex\n\n\n\nx = 2 + 3j\nprint(x)\n\n(2+3j)\n\n\n\n# real and imginary parts.\nprint(x.real, x.imag)\n\n0.0 1.0\n\n\n\nx = complex(1)\nprint(x)\n\n(1+0j)\n\n\n\n\n정수\n정수형은 실수와 달리 근사치를 사용하지 않는다. 즉, 정확한 숫자를 저장한다.\n\nx = 1\ntype(x)\n\nint\n\n\n\nx = 1.0\ntype(x)\n\nfloat\n\n\n\nx = int(x)\ntype(x)\n\nint\n\n\nbold text정수를 저장하는 공간은 동적(dynamic)이기 때문에 범위의 제한이 상대적으로 적다.\n\nx = 2 ** 147 + 2 ** 65  # **는 거듭제곱을 나타낸다.\nprint(x)\n\n178405961588244985132285783074675039466946560\n\n\n논리형 내지 불리언(Boolean)형\n불리언(boolean) 자료형은 참(true)과 거짓(false)을 나타내기 위해 사용하는 자료형으로 키워드(keyword) True와 False를 사용하여 정의한다. 불리언 자료는 논리연산에 중요한 역활을 한다.\n\nx = True\ntype(x)\n\nbool\n\n\n\nx = bool(1)\ntype(x)\n\nbool\n\n\n\nx = bool(0)\nprint(x)\ntype(x)\n\nFalse\n\n\nbool\n\n\n\nprint(bool(1), bool(0))\n\nTrue False\n\n\n\n\n\n문자형\n문자열(string)이란 문자, 단어 등으로 구성된 문자들의 집합을 의하는 것으로 작은 따옴표(’ ’)와 큰 따옴표(” “)를 이용하여 정의한다. 둘 중 하나로만 정의해서 사용해야 한다.\n\nx = 'abc'\ntype(x)\n\nstr\n\n\n\ny = '\"A quotation!\"'\nprint(y)\n\n\"A quotation!\"\n\n\n\nz = \"\"\"\nmultiple\nlines\n\"\"\"\n# 여러 줄의 문자들을 입력하는 방법\nprint(z)\n\n\nmultiple\nlines\n\n\n\n\n인덱싱과 슬라이싱\n인덱싱(indexing)은 특정한 문자(또는 값)를 가리키는 것이고, 슬라이싱(slicing)은 부분 문자열을 추출하는 것이다. 시작은 0이고 마지막은 n-1이다. 다음은 슬라이싱의 규칙이다.\n\n\n\n슬라이싱\n추출된 문자열\n\n\n\n\ns[:]\n전제 문자열\n\n\ns[i]\ni+1번째 문자\n\n\ns[i:]\ni+1번째 부터 n번째 까지의 문자열\n\n\ns[:i]\n처음부터 (i번째 까지의 문자열\n\n\ns[i:j]\ni+1번째 부터 j번째 까지의 문자열\n\n\ns[i:j:m]\ni+1번째 부터 j번째 까지 m개 마다 추출된 문자열\n\n\ns[-i]\nn-i+1번째 문자\n\n\ns[-i:]\nn-i+1번째 부터 n번째 까지의 문자열\n\n\ns[:-i]\n처음부터 n-i번째 까지의 문자열\n\n\ns[-j:-i]\nn-j+1번째 부터 n-i번째 까지의 문자열, 단 -j &lt; -i\n\n\ns[-j:-i:m]\nn-j+1번째 부터 n-i+1번째 까지 m개 마다 추출된 문자열\n\n\n\n\n인텍싱은 특정 첨자 값을 반환, 슬라이싱은 특정 구간 첨자들 값을 반환, 필터링은 특정 조건을 만족하는 첨자들의 값을 반환 하는 것을 의미\n구문의 기본 규칙은 a:b라고 하면 (a+1)번째부터 시작해서 총 (b-a)개의 첨자를 선택 / 각 첨자는 -1씩 위치를 옮겨 놓은 것임 (R 대비)\n-1 첨자는 0 바로 뒤로 끝 위치를 의미\n\n\ntext = \"Python strins are sliceable.\"\nprint(text[0])\nprint(text[-2:])\nprint(text[:-2])  # 양수로 첨자를 확인하고 규칙을 따름\n\nP\ne.\nPython strins are sliceabl\n\n\n\ntext[-1]\n\n'.'\n\n\n\nL = len(text)\ntext[-L]\n\n'P'\n\n\n\ntext[L-1]\n\n'.'\n\n\n\ntext[:10]  # from 0 to 9\n\n'Python str'\n\n\n\ntext[10:]  # from 10 to L-1\n\n'ins are sliceable.'\n\n\n\n\n\n리스트형\n리스트(list)는 Python의 핵심이 되는 자료형으로 실수, 정수, 복소수, 문자형 혹은 리스트의 모임이다. 리스트는 슬라이싱을 사용하여 특정 위치의 값이나 부분 리스트를 추출할 수 있다.\n\n리스트는 벡터와 다르게 여러 유형을 담아 넣는 것으로 리스트 안에 리스트도 집어 넣을 수 있다.\n\n\nx = []\ntype(x)\n\nlist\n\n\n\nx = [1, 2, 3, 4]\nprint(x)\n\n[1, 2, 3, 4]\n\n\n\nx = [[1, 2, 3, 4], [5, 6, 7,8]]\nprint(x[0][1])\n\n2\n\n\n\nx = [[1, 1.0, 1+0j], 'one', None, True]\nprint(x[1])\n\none\n\n\n\n인덱싱과 슬라이싱\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nx[0]\n\n0\n\n\n\nx[10]\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-48-0bcbedae9f7e&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 x[10]\n\nIndexError: list index out of range\n\n\n\n\nx[4:]\n\n[4, 5, 6, 7, 8, 9]\n\n\n\nx[:4]\n\n[0, 1, 2, 3]\n\n\n\nx[1:4]\n\n[1, 2, 3]\n\n\n\nx[-0]\n\n0\n\n\n-0는 0과 동일하게 취급\n\nx[-1]\n\n9\n\n\n\nx[-10:-1]\n# 처음부터 마지막 앞까지 반환\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n\n길이가 -1+10 = 9 개이며 최종 도착점이 리스트의 마지막 원소 바로 앞임\n2차원 리스트의 예\n\nx = [[1, 2, 3, 4], [5, 6, 7, 8]]\nprint(x)\n\n[[1, 2, 3, 4], [5, 6, 7, 8]]\n\n\n기본 유형은 꺽쇠 안에 꺽쇠로 구별함 / 이는 행렬과 다름 먄약에 a = [[[2,3],[4,5]],[[4,5],[6,9]]] 라고 하면 앞뒤 세 개의 꺽쇠는 [:,:,:]형태의 리스트임을 암시\na[0][1][1] = 5\n\nx[0]\na = [[[2,3],[4,5]],[[4,5],[6,9]]]\nprint( a[0][1][1] ) # 5\n# print(a[0,1,1])\n\n5\n\n\n인데싱을 할 때 모든 차원에 대해서 한꺼번에 하면 안됨 하나의 차원에 대해서 진행하고 그 객체에서 다시 인덱싱을 함 (한번에 하는 경우도 존재)\n\nx[1]\n\n[5, 6, 7, 8]\n\n\n\nx[0][0]\n\n1\n\n\n\nx[0][1:4]\n#a[0][1:4]\n\n[2, 3, 4]\n\n\n\nx[1][-4:-1]\n\n[5, 6, 7]\n\n\n\n\n리스트 관련 함수들\n\n\n\n\n\n\n\n\n함수명\n메소드\n설명\n\n\n\n\nlist.append(x, value)\nx.append(value)\n리스트의 마지막에 값을 추가\n\n\nlen(x)\n-\n리스트안의 값의 갯수를 반환\n\n\nlist.extend(x, list)\nx.extend(list)\n리스트를 추가\n\n\nlist.pop(x, index)\nx.pop(index)\n리스트의 index위치에 있는 값을 제거하고, 해당값을 반환\n\n\nlist.remove(x, value)\nx.remove(value)\n리스트에서 첫번째 value를 제거\n\n\nlist.count(x, value)\nx.count(value)\n리스트에서 value의 갯수를 반환\n\n\ndel x[slice]\n\nslice안의 값을 제거\n\n\n\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nx = []\nx.append(0)\nx.append(9)\nprint(x)\n\n[0, 9]\n\n\n리스트 뒤에 값을 추가\n\nprint(len(x))\nprint(x)\n\n2\n[0, 9]\n\n\n\nx.extend([11, 12, 13]) # 여러 개의 값을 뒤에 붙임\nprint(x)\n\n[0, 9, 11, 12, 13]\n\n\n\nx.pop(1) # 2번째 원소를 제외시킴\nprint(x)\n\n[0, 12, 13]\n\n\n첨자 0/1에 있는 값을 없앰\n\nx.remove(0)  # 0의 값을 찾아서 지움\nprint(x)\nx.count(1)\n\n[12, 13]\n\n\n0\n\n\n특정한 값에 해당하는 것을 찾아서 다 삭제 / 특정한 값이 몇 개 있는지를 확인\n리스트의 값은 del함수와 슬라이싱을 이용하여 제거할 수 있다.\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n\n\n\ndel x[10]\nprint(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nx[:3]\n\n[0, 1, 2]\n\n\n\ndel x[:3]\nprint(x)\n\n[3, 4, 5, 6, 7, 8, 9]\n\n\n\ndel x[1:3]\nprint(x)\n\n[3, 6, 7, 8, 9]\n\n\n\ndel x[:]\nprint(x)\n\n[]\n\n\n주의: 리스트는 수정이 가능하기 때문에 별도의 복사를 만들지 않는다. 따라서 리스트로 할당된 리스트는 값은 동시에 변한다. 이는 R과 다른 점.\n\nx = [1, 2, 3]\ny = x # 여기에서 y 객체는 x와 연동되어 있음\ny[0] = -10\nprint(y, x)\n\n[-10, 2, 3] [-10, 2, 3]\n\n\n\nprint(id(y), id(x))\n\n134269777843520 134269777843520\n\n\nid(x), id(y) 는 값이 저장되 물리적 위치에 대한 주소같은 것임\n\nx = [1, 2, 3]\ny = x[:]\ny = y + [3,3,3] # 여기서부터 다른 객체로 인식됨\nprint(id(y), id(x))\nprint(x,y)\n\n134270613754048 134270613655360\n[1, 2, 3] [1, 2, 3, 3, 3, 3]\n\n\n리스트 안의 리스트는 슬라이싱 방법으로 복사를 만들 수 없다. 따라서 리스트 안의 리스트를 복사하기 위해서는 모듈을 사용해야 한다.\n\nx = [[0, 1], [2, 3]]\ny = x[:]\nprint(id(x[0]), id(y[0]))\n\n134270342909504 134270342909504\n\n\n\nprint(id(x[0][0]), id(y[0][0]))\n\n134270827528400 134270827528400\n\n\n\ny[0][0] = -10\nprint(y, x)\nprint(id(x),id(y))\n\n[[-10, 1], [2, 3]] [[-10, 1], [2, 3]]\n134269777819904 134269777846080\n\n\n이것은 리스트안의 리스트를 거쳐서 최종 원소까지 내려가야 다른 것으로 지정함을 의미\n\nimport copy as cp\nx = [[0, 1], [2, 3]]\ny = cp.deepcopy(x)\ny[0][0] = -20.0\nprint(y, x)\nprint(id(y),id(x))\n\n[[-20.0, 1], [2, 3]] [[0, 1], [2, 3]]\n134270615143744 134270397329728\n\n\ndeepcopy 명령문으로 메모리 주소를 다른 것으로 처음부터 잡음\n\n\n\n튜플형\n튜플(tuple)은 리스트와 비슷한 성질을 가진 자료형이다. 다만, 수정이 불가능하다. 만약에 수정을 원한다면 리스트로 바꾸어 놓고 수정하고 다시 튜플로 변환한다.\n\nx = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\ntype(x)\n\ntuple\n\n\n\nx[0]\n\n0\n\n\n\nx[-10:-5]\n\n(0, 1, 2, 3, 4)\n\n\n\nx = list(x)\ntype(x)\n\nlist\n\n\n\nx = tuple(x)\ntype(x)\n\ntuple\n\n\n\nx[0] = -10\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-98-cddb899faf03&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 x[0] = -10\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n튜플에서는 값을 바꾸지 못한다.\n주의. 하나의 값을 이용하여 튜플을 만들때는 콤마(,)를 포함해야 한다.\n\nx = (2)\ntype(x)\nx + 2\n\n4\n\n\n\nx = (2,)\ntype(x)\n\ntuple\n\n\n1차원 튜플의 표기법, 2차원의 경우는 (,)가 됨.\n\n\n딕셔너리형\n딕셔너리(dictionary) 자료형은 자료들의 대응 관계를 나타낼 수 있는 자료형으로 리스트나 튜플과 같이 순차적으로 해당 요소값을 구하지 않고 키(key)와 값(value)으로 구성된다.\n\ndata = {'age' : 34, 'children' : [1, 2], 1: 'apple'}\ntype(data)\n\ndict\n\n\n\nprint(data)\n\n{'age': 34, 'children': [1, 2], 1: 'apple'}\n\n\n\ndata['age']\n\n34\n\n\n변수명을 이용하여 불러온다.\n\ndata['age'] = 50\nprint(data['age'])\n\n50\n\n\n변경\n\ndata['name'] = ['abc','fg']\nprint(data)\n\n{'age': 50, 'children': [1, 2], 1: 'apple', 'name': ['abc', 'fg']}\n\n\n변수를 추가\n\ndel data['age']\nprint(data)\n\n{'children': [1, 2], 1: 'apple', 'name': ['abc', 'fg']}\n\n\n변수를 삭제\n\n\n집합형\n집합(set, frozenset)은 고유한 값들로 구성된 자료형이다. set은 고유한 값들로 구성된 리스트와 비슷한 특성을 가지고 있고, frozenset은 고유한 값들로 구성된 튜플과 비슷한 특성을 가지고 있다.\n\n집합 관련 함수들\n\n\n\n함수명\n메소드\n설명\n\n\n\n\nset.add(x, element)\nx.add(element)\n집합에 element를 추가\n\n\nlen(x)\n-\n집합안의 element 갯수를 반환\n\n\nset.difference(x, set)\nx.difference(set)\n차집합\n\n\nset.intersection(x, set)\nx.intersection(set)\n교집합\n\n\nset.remove(x, element)\nx.remove(element)\n집합에서 element를 제거\n\n\nset.union(x, set)\nx.union(set)\n합집합\n\n\n\n\nx = set(['MSFT', 'GOOG', 'AAPL', 'HPQ', 'MSFT', 'MSFT'])\nprint(x)\n\n{'GOOG', 'AAPL', 'MSFT', 'HPQ'}\n\n\n집합은 원소의 중복을 허용하지 않음\n\nx.add('CSCO')\nprint(x)\n\n{'CSCO', 'HPQ', 'AAPL', 'GOOG', 'MSFT'}\n\n\n\ny = set(['XOM', 'GOOG'])\nx.intersection(y)\n\n{'GOOG'}\n\n\n교집합 연산\n\nx = x.union(y)\nprint(x)\n\n{'CSCO', 'GOOG', 'HPQ', 'MSFT', 'AAPL', 'XOM'}\n\n\n\nx.remove('XOM')\nprint(x)\n\n{'CSCO', 'GOOG', 'HPQ', 'MSFT', 'AAPL'}\n\n\n참고. frozenset은 set과 같은 메소드를 적용할 수 있지만, add와 remove는 적용되지 않는다. 즉, 값의 변화를 주지 않는다는 의미임.\n\n\n\nrange\nrange는 반복문에서 가장 많이 사용되는 자료형으로 열(sequence)을 생성한다.\n\nx = range(10)\ntype(x)\n\nrange\n\n\n특별히 range 라는 타입을 사용하며, 리스트와 유사함\n\nList item\nList item\n\n\nprint(x)\n\nrange(0, 10)\n\n\n\nlist(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nx = range(3,10)\nlist(x)\n\n[3, 4, 5, 6, 7, 8, 9]\n\n\n\nx = range(3,10,3)\nlist(x)\n\n[3, 6, 9]\n\n\n3부터 시작해서 3칸씩 건너가되 10-1까지 가는 것임.\n\n\n과제 P1\n\npin = \"881120-1068234\"\n\n\n주민등록번호(pin)의 연월일 부분과 그 뒤의 숫자 부분으로 나누어 출력하시오.\n주민등록번호(pin)에서 성별을 나타내는 숫자를 출력하시오.\n\n\nx = [1, 3, 5, 4, 2]\n\n[5, 4, 3, 2, 1]\n\n\n\n[1, 3, 5, 4, 2]라는 리스트를 [5, 4, 2, 3, 1]로 만들어 보시오.\n\n\nx = (1, 2, 3) ;\n\n[1, 2, 3, 4]\n\n\n(1, 2, 3, 4)\n\n\n\n(1, 2, 3)이라는 튜플에 4라는 값을 추가하여 (1, 2, 3, 4)처럼 만들어 출력해 보시오.\n\n\na = {'A': 90, 'B': 80, 'C': 70}\n\n80\n\n\n\n딕셔너리 a에서 ’B’에 해당되는 값을 추출하고 삭제해 보시오.\n\n\na = [1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5]\n\n{1, 2, 3, 4, 5}\n\n\n\n리스트에서 중복된 숫자들을 제거해 보시오."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "lablab",
    "section": "",
    "text": "P05_Matplot\n\n\n\n\n\n\n\n\n\n\n\nDec 21, 2024\n\n\n김수환\n\n\n\n\n\n\n\n\n\n\n\n\nP04_Pandas_Supp_(3)\n\n\n\n\n\n\n\n\n\n\n\nDec 20, 2024\n\n\n김수환\n\n\n\n\n\n\n\n\n\n\n\n\nP03_LoopFunction(2)\n\n\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\n김수환\n\n\n\n\n\n\n\n\n\n\n\n\nP03_LoopFunction(1)\n\n\n\n\n\n\n\n\n\n\n\nDec 18, 2024\n\n\n김수환\n\n\n\n\n\n\n\n\n\n\n\n\nP02_Numpy\n\n\n\n\n\n\n\n\n\n\n\nDec 17, 2024\n\n\n김수환\n\n\n\n\n\n\n\n\n\n\n\n\nP01_DataType\n\n\n\n\n\n\n\n\n\n\n\nDec 16, 2024\n\n\n김수환\n\n\n\n\n\n\nNo matching items"
  }
]